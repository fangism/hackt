to do list:

this TODO list is way outdated... clean TODO list.

UNROLL that sh--

Write objects!!!
	resolved issues: converting pointers to indices (done)
	dump binary to file (done)
	load back in from file (done)
	linkability: -- not yet
	translation tables:
	compare object dumps (done)

specifically:
	definitions: write used_id_maps (done)
	type_refs: definition and param references (done)
	instances:  (done)
	instance references:  (done)
	expressions: (done)
	assignments, connections: (done)

make simplest tests possible:
	empty definitions
	enum type

PRS -- new context for type-checking expressions, 
	expecting bool (not pbool) and returning bool.  (datatype)


code rework:
	rewrite majority of traversals using functors
		replace iterator code with for_each...
		source code cleaning for sake of maintainability


type-check and build typedefs
	need to resolve semantic ambiguity first!
		typedef a b;	// treated as a definition alias
	partially done, 
	still too conservative with resective to template argument matching
	Need to be able to pass parameter context down recursively first...

CHANGE the check_build framework.
make specific signatures for type-checking, so that return values
may be of some use.  
Limit the use of the context object.  

count_ptr (pointer-classes)
	make .deep_copy method?

collapse parse-tree tokens, subclass keywords...
	(low-priority)

complex-aggregate arrays-building and concatenation, using { } and #

Rename ART::entity::index_expr to something else to prevent ambiguity with
	ART::parser::index_expr

type ref cache? distinguish parameter dependent/independent
	until unroll time

source-to-source translation from art++ to cyc-art [SIK art] or LLkart

DOCUMENTATION

stack (reverse):
1) implement type-reference cache: one per scope? name/def-space? not global?
	re-using used_id_map
2) need expression cache for parameters (work out hashing)
3) would need to check template formals or param insts
4) expression type-checking, return types, etc...
	expr::check_build() for subclasses
5) built-in type and reference mechanism in progress
6) template argument type checking: int<pint>

minor: de-virtualize final classes

future: loop and conditional scopespaces

major: do away with redundant hash_maps, and sets in namespace/scopespace
	stick to used_id_map.
perhaps eliminate redundant object hash_maps/sets
	only use used_id_map, but then add dynamic casts on top of lookup
	in the lookup_blah() methods
	keep definitions separate from identifiers, or mash them together?
	placing everything in used_id_map => less maintenance, 
		but more run-time type resolution
	(ok, since we forbid name clashes anyways)
	what about owned sub-namespaces?
	open using/aliases are kept separate for searching, 
		but registered in used_id_map (as is)

-------------------------------------------------------------------------------
MASSIVE CODE CLEAN UP after major deletions... after all the above

array_instantiations:
add array construction to grammar, with semantics
	1) { array array } ... === array (concatenation)
	2) { array, array, ... } === 2d-array (building) new 1st index 0,1,...
	strict: types and sizes must match!

un-related idea:
	pointer-library for typing... better error checking
		dynamic const-ness, run-time const checking?
		"dynconst_ptr"
		exclusive ownership, non-ownership, shared ownership...
		exclusive pointers compatible assign with non-owned...

semantic error handling: build tree/list of errors and print all at end

multiple parsers?, single lexer: (nah.)
	art, chp, prs, hse, expr (first)...
	how does one report syntax errors then?  :)
	awk, awk, awk, awk...

major: if bison is installed under fink, yacc will execute bison
	which breaks some compatibilty because of differing assumed
	internal identifiers.  :(
	Pehaps configure...

GENERAL NOTES:
	Inline constructors and destructors when it is certain that they
	will not be referenced directly outside of their compilation module.


-------------------------------------------------------------------------------
DONE

(30.07.04)
member type-checking for x.y.z

define connection-objects:
	list of instance_references for aliasing
	list of instance_references for port connection
	expression assignments?
		1) resolved to constants -- keep around? for now, why not?
			but propagate all constants when type-checking
		2) resolved to parameters

WRITE MORE REGRESSION TESTS, esp. for arrays, and parameters
	then commit

minor: pointers that are absolutely NEVER null (and never deleted)
	should be converted to references (CANCELLED)

sparse/dense arrays:
	how is the following pseudo-redeclaration to be handled?
	int a[0];
	int a[1];
	or sparse instantiations within loop? aiiiieeee!
	as we discussed in 5/30/04 meeting...

major: update grammar to deal with arrays
	empty template arguments, default template arguments

Grammer updates:
	typedefs (type-aliases) (templated)
	array construction {...} into complex_aggregates
	enums (done)
	blank/default arguments in grammar, such as ports
		(not type-checked)

(11.07.04)
segment large .cc files into pieces (art_parser.cc, art_object.cc)
	also with .h files?
	Then go through each .h, .cc file and reduce header to 
		only what is needed, for efficiency.  

index type-checking of static indices:
	dimensionality and ranges -- work on object_expr's
	must check for static coverage.  
	basically report overlaps between index_colection_stack items
	and indices.  

(10.07.04)
More Makefile madness: differing recursive invocations
	Makefile.BSD -- canned
	Makefile.GNU -- canned
	use sed on Make.inc to dynamically include one of them.  
	a phony whichmake target before everything...
	SOLUTION: bsdmake will use Makefile, gmake will use GNUmakefile.  done

(07.07.04)
Switch range_array_list and related classes over to expr_objs.  (done)

template formal arguments in definitions and declarations
	hashlist implementation and such
	scrapped hashlist for separate list and hash_qmap

instance-collection-stack:
	define functional interface


(24.06.04)
alias_list::check_build() -- self-contain checking
	if more than one item in list, 

token_identifier sub-type?
	wrap as expression, new ID, namespace id...
	don't need, let list-wrapper classes handle cases

(12.06.04)
something wrong with open J as K (add_using_alias)
must fix this first! done... was using deleted memory because 
	ownership was not properly transferred (fixed)

TEMPLATES: only for processes, extend language to generalize for data types
	and channels.
	Currently, type-check doesn't support template specialization, 
	must fix this!!!
	Even built in int<> needs to be checked as template.

minor: id.copy_namespace_portion()...
	encapsulate into method called starting_search_namespace();
	made obsolete by sublist (virtual list-slice) class

MAJOR: re-hash set_of_ptr class definitions!
	const-ness doesn't imply not owned memory!
	also needs boolean ownership flag.  
	list_of_owned_const_ptr... etc...
	list<auto_ptr<T> > ?
	solution: list<count_const_ptr<T> >


(30.05.04)
namespace_id class (like id_expr, but for namespaces)

object_handle:
	remember to always self() on what's returned by used_id_map[]!!!
	overload [] operator for scopespace to use used_id_map?

grammar, templates: change grammar to use C++ style templates
	e.g. template <pint N, pint A[N]> ... definition ...

phase-out type-specific query and lookup methods in name_space class.

(13.05.04)
phase out: inherit_built_in_types
	just always look them up in global space

(07.05.04)
migrate non-terminal types to their specific sub-classes instead of 
	generic nodes, and update the class constructors accordingly. 
	Much better for static type-checking.  
	Need to change node_list!  

(05.05.04)
function: qualified identifiers:
	subroutine that returns list of namespaces that match
	all but last identifier in list (scopes)

qualified identifiers: in various namespace lookup functions, 
	honor the ::-prefixed absolute qualified identifiers

minor: make symbol-table and object parent pointers const, read-only
(26.04.04)

parser:
depending on state stack, get correct union member of value stack, 
	cast to node*

work out const (read-only) semantics for object* in type-checking

-------------------------------------------------------------------------------
CANCELLED

more qualified identifier to do: trim linked list such that delimiters 
	are deleted, and can pass iterators recursively to lookup functions
	at least for the scope delimiter...

