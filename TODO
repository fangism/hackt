to do list:

this TODO list is way outdated... clean TODO list.

REVISION TARGETS:

Current series: 0.1.3 -- main trunk of development line.

0.1.4 Goals:
	BASIC parameter unrolling only (scalars)
	MAJOR ISSUES with parameter unrolling and assignment ordering
		(resolved: ordered items are decoupled from scopes)
	Hold off on parameter assignments until after restructuring
		parameter_assignment classes.  
		(Yeah, I know, useless without assignments!)
		(*done* -- 10/09/04)
	keep definitions around as back-references in unpacked objects.
	unpack instantiation_bases into live instances
		using multidimensional_qmap, or now, multikey_qmap.  
	
	Documentation: add documentation headers to beginning of
		every source file, so doxygen will create file
		inclusion dependence graphs! (*done* -- 10/09/04)

0.1.5 Goals:
	unrolling parameter expression assignments
	for 0.1.5 unrolling with collections
	Parameters MUST be fully implemented before proceeding with
		other physical entities.  
	Decide whether to support loops and conditional scopes 
		in this series.

0.1.6 Goals:
	General language support for PRS needs to catch up.  
	Introduce PRS object classes, based on old prsim.
	Unrolling production rules

At any point, preferably ASAP:
*	In object file format, identify which VERSION/REVISION of the ART
	compiler generated the object file.  
	Will be critical in future version systems.

*	CHANGE the check_build framework in AST parser classes.
	Namely, make specific signatures for type-checking, 
		so that return values may be of some use in most cases.  
		Presently, most return values are useless.  
	Limit the use of the context object.  
	Rework may drastically shrink the role of the context object,
		will still be useful for scope stacks and the likes.  
	User should not have to create a context, that should be
		hidden in a top-level check_build function call.

and beyond...
	cflat -prsim backwards compatibility mode
		(and other tools)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
instantiation statement needs to check template arguments of type!

multikey_map type -- extend to accept generic sequences of key_types
	as multidimensional index arguments.
	(much like multidimensional_qmap and _sparse_set)

Object serialization rework: (*DONE* -- 10/12/04)
	sub-type instance collections by dimension, using size_t template
	extend reconstruction table entry to contain additional
		field for dimension subtype (another index)
	modify construct_empty() to take another argument (index)
		for subtype, 2nd level table of constructors
	factor out serial_object interface out of object
		into own IO interface class "persistent".
	NOTE: for sake of compatible extensibility in adding types
		to art_object_type_enum.h, we cannot use dense enumerations.  
		Conflicts will arise between independently developed
		types added.  
		Solution: run-time registration of types, using
		unique strings (or hash) instead of compile-time constants.  
	remaining: actually use/store/retrieve extra integer argument
		for ::construct_empty()


param_expression_assignment: sub-type into pint vs. pbool (*done*)
	maybe even subtype by dimension.  (not yet...)
	will need to update object_list::make_param_assignment... (done)
param_expression_assignment: split apart rhs from rest (done)
	lhs must be references. (done)


language front-end: parser:
	modular parsers for extensible sub-languages.  
	Will they share the same lexer?  or have their own?
		Consider FILE* manipulations...
	@LANG extensions to "escape" into another language, 
		useful for new languages, before reserving new keywords.  
	Re-use AST classes?
	Copy pieces of grammar into others for reuse.
	Grammar may become piecewise.
	Could become ugly.  

Type-scope for unrolling.  

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

REDO: instantiation creation: (done! 2004-09-14)
	can keep track of index collection in instantiation classes, 
	but each creation should get its own instantiation_statement.  
	an instantiation need not even track the precise type, 
	as type should be tracked per statement.  
	Name will be tracked in instantiation_base, 
	instantiation_statement will have back-reference to base.

Distinguish between name-scope and sequence-scope. (done)

before unrolling: need major rework (done! 2004-09-14)
put instance management items in the top-level in some
	globally ordered list in the context object.
		when instance is declared (or extended) either
		add to definition or the global scope. 
	remove connect_list and assign_list from scopespace?
		replace them with list<ptr<instance_management> >
		in certain definition types?
		definition_base? only definitions with scopes?
	either add to global action list or definition's list.
	account for loop and conditional scopes, 
		treat them as sequential items.  
	in context, manage stack of instance_management spaces...

psuedo code high level linking and unrolling, etc...


type-specific and dimension-specific param_expression_assignment?
	also apply to instantiations, instance_references?
	don't want to go overboard...

Write objects!!! (need to do linking)
	resolved issues: converting pointers to indices (done)
	dump binary to file (done)
	load back in from file (done)
	linkability: -- not yet
	translation tables:
	compare object dumps (done)

specifically:
	definitions: write used_id_maps (done)
	type_refs: definition and param references (done)
	instances:  (done)
	instance references:  (done)
	expressions: (done)
	assignments, connections: (done)

make simplest tests possible:
	empty definitions
	enum type

PRS -- new context for type-checking expressions, 
	expecting bool (not pbool) and returning bool.  (datatype)


code rework:
	rewrite majority of traversals using functors
		replace iterator code with for_each...
		source code cleaning for sake of maintainability


type-check and build typedefs
	need to resolve semantic ambiguity first!
		typedef a b;	// treated as a definition alias
	partially done, 
	still too conservative with resective to template argument matching
	Need to be able to pass parameter context down recursively first...

count_ptr (pointer-classes)
	make .deep_copy method?

collapse parse-tree tokens, subclass keywords...
	(low-priority)

complex-aggregate arrays-building and concatenation, using { } and #

Rename ART::entity::index_expr to something else to prevent ambiguity with
	ART::parser::index_expr

type ref cache? distinguish parameter dependent/independent
	until unroll time

source-to-source translation from art++ to cyc-art [SIK art] or LLkart

DOCUMENTATION

stack (reverse):
1) implement type-reference cache: one per scope? name/def-space? not global?
	re-using used_id_map
2) need expression cache for parameters (work out hashing)
3) would need to check template formals or param insts
4) expression type-checking, return types, etc...
	expr::check_build() for subclasses
5) built-in type and reference mechanism in progress
6) template argument type checking: int<pint>

minor: de-virtualize final classes

future: loop and conditional scopespaces

major: do away with redundant hash_maps, and sets in namespace/scopespace
	stick to used_id_map.
perhaps eliminate redundant object hash_maps/sets
	only use used_id_map, but then add dynamic casts on top of lookup
	in the lookup_blah() methods
	keep definitions separate from identifiers, or mash them together?
	placing everything in used_id_map => less maintenance, 
		but more run-time type resolution
	(ok, since we forbid name clashes anyways)
	what about owned sub-namespaces?
	open using/aliases are kept separate for searching, 
		but registered in used_id_map (as is)

-------------------------------------------------------------------------------
MASSIVE CODE CLEAN UP after major deletions... after all the above

array_instantiations:
add array construction to grammar, with semantics
	1) { array array } ... === array (concatenation)
	2) { array, array, ... } === 2d-array (building) new 1st index 0,1,...
	strict: types and sizes must match!

un-related idea:
	pointer-library for typing... better error checking
		dynamic const-ness, run-time const checking?
		"dynconst_ptr"
		exclusive ownership, non-ownership, shared ownership...
		exclusive pointers compatible assign with non-owned...

semantic error handling: build tree/list of errors and print all at end

multiple parsers?, single lexer: (nah.)
	art, chp, prs, hse, expr (first)...
	how does one report syntax errors then?  :)
	awk, awk, awk, awk...

major: if bison is installed under fink, yacc will execute bison
	which breaks some compatibilty because of differing assumed
	internal identifiers.  :(
	Pehaps configure...

GENERAL NOTES:
	Inline constructors and destructors when it is certain that they
	will not be referenced directly outside of their compilation module.


-------------------------------------------------------------------------------
DONE

(30.07.04)
member type-checking for x.y.z

define connection-objects:
	list of instance_references for aliasing
	list of instance_references for port connection
	expression assignments?
		1) resolved to constants -- keep around? for now, why not?
			but propagate all constants when type-checking
		2) resolved to parameters

WRITE MORE REGRESSION TESTS, esp. for arrays, and parameters
	then commit

minor: pointers that are absolutely NEVER null (and never deleted)
	should be converted to references (CANCELLED)

sparse/dense arrays:
	how is the following pseudo-redeclaration to be handled?
	int a[0];
	int a[1];
	or sparse instantiations within loop? aiiiieeee!
	as we discussed in 5/30/04 meeting...

major: update grammar to deal with arrays
	empty template arguments, default template arguments

Grammer updates:
	typedefs (type-aliases) (templated)
	array construction {...} into complex_aggregates
	enums (done)
	blank/default arguments in grammar, such as ports
		(not type-checked)

(11.07.04)
segment large .cc files into pieces (art_parser.cc, art_object.cc)
	also with .h files?
	Then go through each .h, .cc file and reduce header to 
		only what is needed, for efficiency.  

index type-checking of static indices:
	dimensionality and ranges -- work on object_expr's
	must check for static coverage.  
	basically report overlaps between index_colection_stack items
	and indices.  

(10.07.04)
More Makefile madness: differing recursive invocations
	Makefile.BSD -- canned
	Makefile.GNU -- canned
	use sed on Make.inc to dynamically include one of them.  
	a phony whichmake target before everything...
	SOLUTION: bsdmake will use Makefile, gmake will use GNUmakefile.  done

(07.07.04)
Switch range_array_list and related classes over to expr_objs.  (done)

template formal arguments in definitions and declarations
	hashlist implementation and such
	scrapped hashlist for separate list and hash_qmap

instance-collection-stack:
	define functional interface


(24.06.04)
alias_list::check_build() -- self-contain checking
	if more than one item in list, 

token_identifier sub-type?
	wrap as expression, new ID, namespace id...
	don't need, let list-wrapper classes handle cases

(12.06.04)
something wrong with open J as K (add_using_alias)
must fix this first! done... was using deleted memory because 
	ownership was not properly transferred (fixed)

TEMPLATES: only for processes, extend language to generalize for data types
	and channels.
	Currently, type-check doesn't support template specialization, 
	must fix this!!!
	Even built in int<> needs to be checked as template.

minor: id.copy_namespace_portion()...
	encapsulate into method called starting_search_namespace();
	made obsolete by sublist (virtual list-slice) class

MAJOR: re-hash set_of_ptr class definitions!
	const-ness doesn't imply not owned memory!
	also needs boolean ownership flag.  
	list_of_owned_const_ptr... etc...
	list<auto_ptr<T> > ?
	solution: list<count_const_ptr<T> >


(30.05.04)
namespace_id class (like id_expr, but for namespaces)

object_handle:
	remember to always self() on what's returned by used_id_map[]!!!
	overload [] operator for scopespace to use used_id_map?

grammar, templates: change grammar to use C++ style templates
	e.g. template <pint N, pint A[N]> ... definition ...

phase-out type-specific query and lookup methods in name_space class.

(13.05.04)
phase out: inherit_built_in_types
	just always look them up in global space

(07.05.04)
migrate non-terminal types to their specific sub-classes instead of 
	generic nodes, and update the class constructors accordingly. 
	Much better for static type-checking.  
	Need to change node_list!  

(05.05.04)
function: qualified identifiers:
	subroutine that returns list of namespaces that match
	all but last identifier in list (scopes)

qualified identifiers: in various namespace lookup functions, 
	honor the ::-prefixed absolute qualified identifiers

minor: make symbol-table and object parent pointers const, read-only
(26.04.04)

parser:
depending on state stack, get correct union member of value stack, 
	cast to node*

work out const (read-only) semantics for object* in type-checking

-------------------------------------------------------------------------------
CANCELLED

more qualified identifier to do: trim linked list such that delimiters 
	are deleted, and can pass iterators recursively to lookup functions
	at least for the scope delimiter...

