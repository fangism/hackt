#!/usr/bin/awk -f
# "wrap_verilog_modules_to_hacprsim.awk"
#	$Id: wrap_verilog_modules_to_hacprsim.awk,v 1.14 2010/05/21 23:19:26 fang Exp $
# input should be C-preprocessed
# defines wrappers that automatically connect verilog to hacprsim

# implemented as a crude verilog module parser
# "Never parse Verilog with awk when death is on the line."

# optional arguments:
# -v options
#	wrapper_prefix= string to prefix wrapper definitions (default = "HAC_")
#	max_strlen= maximum size of string for identifiers before mangling
#	wrapper_ports= 0,1 whether make wrappers' ports public (default = 0)
#	reverse= 0,1 if 1, then reverse direction of to_prsim/from_prsim
#		useful when wrapper is intended for HAC/prsim to implement.
#		if 1, then also suppress forwarding of port to a dummy instance
#	loopvar= name of auxiliary loop variable
#	output_format= [verilog|hac]
#		if hac, output an empty defproc with ports only
#	repack_arrays= 0,1
#		if 1, repack ports declared with trailing array dimensions into
#		bus dimensions, so:
#			input wire [x:0] in [y:0];
#		would be connected bit-by-bit to a locally declared:
#			wire [y:0][x:0] in;
#		This is a workaround around a limitation that prevents trailing
#		dimensions arrays from transporting values into prsim.

# TODO(fangism): This drops ` in `macros, even though this script is spec'd
#   to operate on a preprocessed source.

BEGIN {
	error = 0;
	FS = "[ \t][ \t]*";	# to tokenize desugarized lines
	# LR(0) parsing...
	# parse stack to track state
	parse_stack_ptr = -1;
	parse_push("top");
	if (!length(wrapper_prefix)) {
		wrapper_prefix = "HAC";
	}
	# strtonum is not POSIX awk, but += 0 does the same thing
	if (!length(max_strlen)) {
		max_strlen = 256;
	} else {
		max_strlen += 0;
	}
	if (!length(wrapper_ports)) {
		wrapper_ports = 0;
	} else {
		wrapper_ports += 0;
	}
	if (!length(reverse)) {
		reverse = 0;
	} else {
		reverse += 0;
	}
	if (!length(debug)) {
		debug = 0;
	} else {
		debug += 0;
	}
	if (!length(loopvar)) {
		loopvar = "_i_";	# "i" is too common
	}
	if (!length(repack_arrays)) {
		repack_arrays = 1;
	} else {
		repack_arrays = int(repack_arrays);
	}
	if (!length(output_format)) {
		output_format = "verilog";
	}
	print "// vi: syntax=verilog";	# :)
	print "// This file is automatically generated by wrap_verilog_modules_to_hacprsim.awk, maintained by David Fang.";
	print "// options:";
	print "//\t-v wrapper_prefix=" wrapper_prefix;
	print "//\t-v max_strlen=" max_strlen;
	print "//\t-v wrapper_ports=" wrapper_ports;
	print "//\t-v reverse=" reverse;
	print "//\t-v debug=" debug;
	print "//\t-v loopvar=" loopvar;
	print "//\t-v output_format=" output_format;
	print "//\t-v repack_arrays=" repack_arrays;
	print "";
	# global variables
	dimensions_stack = "";
	last_port_identifier = "";
}

function parse_error(str) {
	print "parse error on line " NR ": " str;
	error = 1;
	parse_debug();
	exit(1)
}

# shift
function parse_push(st) {
	++parse_stack_ptr;
	parse_stack[parse_stack_ptr] = st;
}

# reduce
function parse_pop() {
	--parse_stack_ptr;
}

function parse_replace(st) {
	parse_stack[parse_stack_ptr] = st;
}

# checks state of stack
# tok is optional current token
function parse_expect(st, tok) {
	if (parse_stack[parse_stack_ptr] != st) {
		parse_error("expected to be in state \"" st \
			"\" but got \"" parse_stack[parse_stack_ptr] "\".\n" \
			"current token [:" NR "]: " tok);
	}
}

function assert_token(tok, expect) {
	if (tok != expect) {
		parse_error("expected token \"" expect "\" but got \"" \
			tok "\" at [:" NR "].");
	}
}

function debug_print(str) {
	if (debug) {
		print "DEBUG: " str;
	}
}

# print the parse stack
function parse_debug(i) {
	printf("stack: ");
	for (i=0; i<=parse_stack_ptr; ++i) {
		printf(parse_stack[i] " ")
	}
	print "";
}

# pad syntactic sugar (tokens) with spaces for easy splitting
function tokenize(str) {
	gsub("[][(,:;'#)]", " & ", str);	# pad with spaces
	return str;
}

function reset_globals() {
	type_name = "";
	param_index = 0;
	port_index = 0;
	any_repack = -1;
	# clear the associative arrays
	# delete ports;		# not POSIX
	for (p in ports) {
		delete ports[p];
	}
	for (p in ordered_ports) {
		delete ordered_ports[p];
	}
	for (p in ordered_params) {
		delete ordered_params[p];
	}
	for (p in param_default_values) {
		delete param_default_values[p];
	}
	for (p in pre_dimensions) {
		delete pre_dimensions[p];
	}
	for (p in post_dimensions) {
		delete post_dimensions[p];
	}
}

function begin_parse_range() {
	# accumulate over multiple dimensions
	dimensions_stack = dimensions_stack "[";	# global
	parse_push("expect-range-first");
}

function first_of_range(range,
	# local vars
	toks) {
	# extract X from "[X:Y]"
	split(range, toks, ":");
	return substr(toks[1], 2);  # strip off [
}

function second_of_range(range,
	# local vars
	toks, rb) {
	# extract Y from "[X:Y]"
	split(range, toks, ":");
	rb = index(toks[2], "]");
	return substr(toks[2], 1, rb-1);
}

# param in_port declaration is local to ports-list (true) or module-body (false)
function set_port_dir(tok, dir, 
	# local vars
	in_port, id) {
	debug_print("set_port_dir(): tok = " tok);
if (tok == "[") {
	begin_parse_range();
} else if (tok == "wire") {
	# just ignore
	return;
} else {
	in_port = parse_stack[parse_stack_ptr -1] == "ports-list";
	if (tok != ";") {
	# permit declarations like "output reg ..."
	if (tok != "," && tok != "reg" && tok != ")") {
		# tok should be the identifier that names the port
		last_port_identifier = tok;
		# this may be parsed directly in the module-ports
		if (in_port) {
			ordered_ports[port_index] = tok;
			port_index++;
		}
		if (length(dimensions_stack)) {
			pre_dimensions[tok] = dimensions_stack;
			debug_print("pre_dim[" tok "] = " dimensions_stack);
		}
		ports[tok] = dir;
		dimensions_stack = "";
	} else if (tok == ")" || (tok == "," && in_port)) {
		# yuck: context dependent handling of comma
		id = last_port_identifier;
		post_dimensions[id] = dimensions_stack;
		dimensions_stack = "";
		debug_print("dimensions[" id "]: " post_dimensions[id] pre_dimensions[id]);
		parse_pop();
		parse_expect("ports-list", tok);
	} # else ignore
	} else {
		# check for trailing dimensions for multidimensional arrays
		id = last_port_identifier;
		post_dimensions[id] = dimensions_stack;
		dimensions_stack = "";
		debug_print("dimensions[" id "]: " post_dimensions[id] pre_dimensions[id]);
		parse_pop();
	}
}
}

# parse: parameter foo = ..., bar = ..., ... ;
function keep_parameter(tok) {
if (tok == "[") {
	begin_parse_range();
} else {
	if (tok != ";") {
	if (tok != ",") {
	if (tok != "=") {
		# this may be parsed directly in the module-ports
		ordered_params[param_index] = tok;
		param_index++;
		if (length(dimensions_stack)) {
			pre_dimensions[tok] = dimensions_stack;
		}
	} else {		# with default value
		rvalue = "";	# global variable:
		parse_replace("param-default-value");
	}
	} else if (tok == ",") {
		# yuck: context dependent handling of comma
		parse_pop();
		parse_expect("param-list", tok);
	} # else ignore:  = ...
	} else {
		parse_pop();
	}
}
}

# where the parsing happens...
function parse_it(tok, 
	# local vars
	state, tmp) {
state = parse_stack[parse_stack_ptr];
if (state == "top") {
	# expect module
	if (tok == "module") {
		reset_globals();
		parse_push("module");
		parse_push("expect-type-name");
	}
	# else nothing
} else if (state == "expect-type-name") {
	type_name = tok;
	parse_replace("expect-ports");
} else if (state == "expect-ports") {
	if (tok == ";") {
		parse_replace("module-body");
	} else if (tok == "(") {
		parse_replace("ports-list");
	} else {
		parse_error("expected '(' or ';'");
	}
} else if (state == "ports-list") {
	# reset globals, yuck!
	dimensions_stack = "";
	if (tok != ")" && tok != ";") {
	if (tok != ",") {
		# ports can just be identifier or directional identifier
		if (tok == "input") {
			parse_push("input-list");
		} else if (tok == "output") {
			parse_push("output-list");
		} else if (tok == "inout") {
			parse_push("inout-list");
		} else {
		# is just untyped identifier
		ordered_ports[port_index] = tok;
		port_index++;
		ports[tok] = "";	# initialize to unknown direction
		# technically this isn't really needed
		}
	} # else ignore commas
	} else {
		parse_replace("module-body");
	}
} else if (state == "module-body") {
	# now look for input and output direction specs
	# reset globals, yuck!
	dimensions_stack = "";
	if (tok == "input") {
		parse_push("input-list");
	} else if (tok == "output") {
		parse_push("output-list");
	} else if (tok == "inout") {
		parse_push("inout-list");
	} else if (tok == "parameter") {
		parse_push("param-list");
	} else if (tok == "reg") {
		parse_push("ignore-to-semicolon");
	} else if (tok == "initial" || tok == "#") {
		parse_push("ignore-block");
	} else if (tok == "specify") {
		parse_push("ignore-specify");
	} else if (tok == "function") {
		parse_push("ignore-function");
	} else if (tok == "endmodule") {
		parse_pop();
		parse_expect("module", tok);
		parse_pop();
		write_out_wrapper();
		parse_expect("top", tok);
	}
} else if (state == "expect-range-first") {
	dimensions_stack = dimensions_stack tok;
	if (tok == ":") {
		parse_replace("expect-range-second");
	}
} else if (state == "expect-range-second") {
	dimensions_stack = dimensions_stack tok;
	if (tok == "]") {
		dimensions_stack = dimensions_stack ",";
		parse_pop();
	}
} else if (state == "input-list") {
	set_port_dir(tok, "in");
} else if (state == "output-list") {
	set_port_dir(tok, "out");
} else if (state == "inout-list") {
	set_port_dir(tok, "inout");
} else if (state == "param-list") {
	keep_parameter(tok);
} else if (state == "param-default-value") {
	tmp = ordered_params[param_index-1];	# current param
	# rvalue is global variable
	if (tok == ",") {
		parse_replace("param-list");
		param_default_values[tmp] = rvalue;
		rvalue = "";
	} else if (tok == ";") {
		param_default_values[tmp] = rvalue;
		rvalue = "";
		parse_pop();
	} else {
		rvalue = rvalue tok;	# accumulate global var
	}
} else if (state == "ignore-block") {
	if (tok == "begin") {
		parse_replace("ignore-to-end");
	} else {
		parse_replace("ignore-to-semicolon");
	}
} else if (state == "ignore-specify") {
	if (tok == "endspecify") {
		parse_pop();
	}
} else if (state == "ignore-function") {
	if (tok == "endfunction") {
		parse_pop();
	}
} else if (state == "ignore-to-comma") {
	if (tok == ",") {
		parse_pop();
	} # else ignore
} else if (state == "ignore-to-semicolon") {
	if (tok == ";") {
		parse_pop();
	} # else ignore
} else if (state == "ignore-to-comma-or-semicolon") {
	if (tok == ";" || tok == ",") {
		parse_pop();
	} # else ignore
} else if (state == "ignore-to-end") {
	if (tok == "end") {
		parse_pop();
	} # else ignore
} else if (state == "module-finished") {
	
}
}

# just wrap name in quotes
function enquote_mem_ref(name) {
	return "\"." name "\"";
}

function verilog_strcat2(s1, s2) {
	return "{" s1 ", " s2 "}";
}

# string concatenation
function emit_from_prsim(name, vname) {
	return "$from_prsim(" verilog_strcat2("prsim_name", name) \
		", " verilog_strcat2("verilog_name", vname) ");";
}

# register concatenation
function emit_from_prsim_reg(name, vname) {
	return "$from_prsim(" verilog_strcat2("prsim_name_reg", name) \
		", " verilog_strcat2("verilog_name", vname) ");";
}

function emit_to_prsim(name, vname) {
	return "$to_prsim(" verilog_strcat2("verilog_name", vname) \
		", " verilog_strcat2("prsim_name", name) ");";
}

function find_max_dimensions(dim, ndim, dim_toks) {
	# local vars only
	max_dimensions = 0;
	for (p in ports) {
		dim = post_dimensions[p] pre_dimensions[p];
		ndim = split(dim, dim_toks, ",") -1;  # -1 because of trailing ,
		if (ndim > max_dimensions)
			max_dimensions = ndim;
	}
	return max_dimensions;
}

function loopvar_name(dim) {
	# dim (integer) is the nth dimension, starting at 1
	# don't bother with suffix for dim=1 (common case)
	if (dim > 1) {
		return loopvar dim;
	} else {
		return loopvar;
	}
}

function genvar_name(dim) {
	return "_g" loopvar_name(dim);
}

function connect_port(p, dir, ndim, dim_toks,
	# p (string) is port name
	# ndim is number of array dimensions
	# dim_toks is an array of range strings split from pre/post_dimensions
	# local vars:
	d, format_indices, format_actuals, n, lv, vname) {
	if (ndim > 0) {
		format_indices = "";
		format_actuals = "";
		for (d=1; d<=ndim; ++d) {
			format_indices = format_indices "[%d]";
			format_actuals = format_actuals ", " loopvar_name(d);
		}
		for (d=1; d<=ndim; ++d) {
			u = first_of_range(dim_toks[d]);
			l = second_of_range(dim_toks[d]);
			# Detect backward ranges and conditionally swap.
			if (u == "0") {
				n = u;
				u = l;
				l = n;
			}
			# TODO: nested-style indentation
			lv = loopvar_name(d);
			print "\tfor (" lv "=" l "; " lv "<=" u "; " lv "=" lv "+1) begin";
		}
		print "\t\t$sformat(tmp, \"." p format_indices "\"" format_actuals ");"
		if (port_needs_repack(p)) {
			print "\t\t$sformat(vtmp, \"." repack_name(p) format_indices "\"" format_actuals ");"
			vname = "vtmp";
		} else {
			vname = "tmp";
		}
		print "\t\t" (dir ? emit_to_prsim("tmp", vname) : emit_from_prsim_reg("tmp", vname));
		for (d=ndim; d>=1; --d) {
			print "\tend // end for " loopvar_name(d);
		}
	} else {
		n = enquote_mem_ref(p);
		print "\t" (dir ? emit_to_prsim(n, n) : emit_from_prsim(n, n));
	}
}

function port_needs_repack(p) {
	return repack_arrays && (length(post_dimensions[p]) > 0);
}

function any_port_needs_repack() {
	# cached result per module
	if (!repack_arrays) {
		return 0;
	}
	if (any_repack == -1) {
		any_repack = 0;
		for (p in ports) {
			if (port_needs_repack(p)) {
				any_repack = 1;
				break;
			}
		}
	}
	return any_repack;
}

function instantiate_original_module(instance_name,
	# local vars
	i) {
	# Then implementation is in verilog, so instantiate the original module.
	printf("\t" type_name);	# global
	if (param_index) {	# global
		printf(" #(");
	for (i=0; i<param_index; ++i) {
		tmp = ordered_params[i];
		printf(tmp (i+1 < param_index ? ", " : ""));
	}
		print ")";
		printf("\t");
	} else {
		printf(" ");
	}
	print instance_name " (";
	# order matters for port forwarding
	for (i=0; i<port_index; ++i) {	# global
		port = ordered_ports[i];
# this style depends on port ordering
#		print "\t\t" port (i+1 < port_index ? "," : "");
# this style uses named port connections
		print "\t\t." port " ( " port " )" (i+1 < port_index ? "," : "");
	}
	print "\t);";
}

function repack_name(p) {
	return p "_repack_";
}

function auto_repack_name(p) {
	if (port_needs_repack(p)) {
		return repack_name(p);
	} else {
		return p;
	}
}

function declare_local_repack_wires(i, p, dim) {	# all local vars
	for (i=0; i<port_index; ++i) {
		p = ordered_ports[i];
		if (port_needs_repack(p)) {
			# declare a repack array
			dim = post_dimensions[p] pre_dimensions[p];
			gsub(",", "", dim);
			print "\twire " dim " " repack_name(p) ";";
		}
	}
}

function connect_repack_port(p, ndim, dim_toks,
	# local vars
	dir, mo) {
	mo = match(ports[p], "out");
	dir = xor(mo, reverse);	 # global variable: reverse
	if (ndim > 0) {
		format_indices = "";
		for (d=1; d<=ndim; ++d) {
			format_indices = format_indices "[" genvar_name(d) "]";
		}
		for (d=1; d<=ndim; ++d) {
			u = first_of_range(dim_toks[d]);
			l = second_of_range(dim_toks[d]);
			# Detect backward ranges and conditionally swap.
			if (u == "0") {
				n = u;
				u = l;
				l = n;
			}
			# TODO: nested-style indentation
			lv = genvar_name(d);
			print "\tfor (" lv "=" l "; " lv "<=" u "; " lv "=" lv "+1) begin";
		}
		if (dir) {
			print "\t\tassign " repack_name(p) format_indices " = " p format_indices ";";
		} else {
			print "\t\tassign " p format_indices " = " repack_name(p) format_indices ";";
		}
		for (d=ndim; d>=1; --d) {
			print "\tend // end for " genvar_name(d);
		}
	}
	# else scalars never need repacking
}

function connect_repack_wires(i, p, dim, ndim, dim_toks) {	# all local vars
	print "\tgenerate  // repacking arrays";
	for (i=0; i<port_index; ++i) {	# global
		p = ordered_ports[i];
		if (port_needs_repack(p)) {
			dim = post_dimensions[p] pre_dimensions[p];
			ndim = split(dim, dim_toks, ",") -1;  # -1 because of trailing ,
			connect_repack_port(p, ndim, dim_toks);
		}
	}
	print "\tendgenerate  // repacking arrays";
}

function emit_wrapper_port_list(i, p, type, pre_dim, post_dim, endl, comment) {	# all local vars
	for (i=0; i<port_index; ++i) {	# global
		p = ordered_ports[i];
		type = (wrapper_ports ? ports[p] "put" : "wire");
		pre_dim = pre_dimensions[p];
		post_dim = post_dimensions[p];
		# strip out commas we used as dimension separators
		gsub(",", "", pre_dim);
		gsub(",", "", post_dim);
		if (length(pre_dim)) pre_dim = pre_dim " ";	 # pad space
		if (length(post_dim)) post_dim = " " post_dim;	# pad space
		endl = (wrapper_ports ? (i+1 < port_index ? "," : "") : ";")
		comment = (!wrapper_ports ? "  // " ports[p] "put" : "");
		print "\t" type " " pre_dim p post_dim endl comment;
	}
}

# emit wrapper function
# no parameters, variables are only local
function write_out_wrapper(tmp, d, i, u, l, n, p, type, dim, dim_toks, ndim, endl) {
if (output_format == "verilog") {
	print "module " wrapper_prefix "_" type_name (wrapper_ports ? " #(" : ";");
	# might as well preserve original port order
	for (i=0; i<param_index; ++i) {
		p = ordered_params[i];
		tmp = param_default_values[p];
		print "\tparameter " p (length(tmp) ? " = " tmp : "") (wrapper_ports ? "," : ";");
		# preserve RHS values and expressions
	}
	printf("\tparameter prsim_name=\"\"");	# always have name parameter
	if (wrapper_ports) {
		print "\n) (";	# end of parameters, start of ports list
	} else {
		print ";";
	}
	print "// need not be reg with acc: wn:*";
	emit_wrapper_port_list();
	if (wrapper_ports) {
		print ");";	# end of ports list
	}

	print "";
	# declare one loopvar for each dimension
	ndim = find_max_dimensions();
	for (d=1; d<=ndim; d++) {
		 # TODO: probably better as a genvar
		print "\tinteger " loopvar_name(d) ";";
		if (any_port_needs_repack()) {
			print "\tgenvar " genvar_name(d) ";";
		}
	}

	print "\treg [" max_strlen "*8:1] prsim_name_reg, verilog_name, tmp" (any_port_needs_repack() ? ", vtmp" : "") ";";
	# tmp is just local var for string manipulation

	if (any_port_needs_repack()) {
		print "";
		declare_local_repack_wires();
		connect_repack_wires();
	}

if (!reverse) {
	# Then implementation is in verilog, so instantiate the original module.
	print "";
	instantiate_original_module("dummy");
}

	print "";
	print "initial begin";
	print "#0\t// happens *after* initial";
	print "\tif (prsim_name != \"\") begin";
	print "\tprsim_name_reg = prsim_name;";
	print "\t$sformat(verilog_name, \"%m\");"
# this order does not matter
# but we preserve original order to avoid hash nondeterminism for testing
for (i=0; i<port_index; ++i) {
	p = ordered_ports[i];
	type = ports[p];
	dim = post_dimensions[p] pre_dimensions[p];
	ndim = split(dim, dim_toks, ",") -1;  # -1 because of trailing ,
	good = 0;
	# ports may be "inout" bidirectional, so I'm guessing both to and from
	if (match(type, "in")) {
		good = 1;
		connect_port(p, reverse, ndim, dim_toks);
	}
	if (match(type, "out")) {
		good = 1;
		connect_port(p, !reverse, ndim, dim_toks);
	}
	if (!good) {
		print "Error: unknown port direction for " p;
		exit(1);
	}
}	# end for port_index
	print "\tend // end if";
	print "end // end initial";
	print "endmodule";
	print "";
} else if (output_format == "hac") {
	# template parameters, if any
	if (param_index) {
	print "template <"
	for (i=0; i<param_index; ++i) {
		p = ordered_params[i];
		# tmp = param_default_values[p];
		tmp = "";	# for now, omit default values
		print "\tpint " p (length(tmp) ? " = " tmp : "") \
			(i+1 < param_index ? ";" : "");
		# preserve RHS values and expressions
	}
	print ">";
	}
	# print "defproc " wrapper_prefix "_" type_name " (";
	print "defproc " type_name " (";
	# ports
	for (i=0; i<port_index; ++i) {
		p = ordered_ports[i];
		# type = ports[p];
		type = "bool";	# blech, hard-coded
		dim = post_dimensions[p] pre_dimensions[p];
		ndim = split(dim, dim_toks, ",") -1;  # -1 because of trailing ,
		printf("\t" type " " p);
		for (d=1; d<=ndim; ++d) {
			u = first_of_range(dim_toks[d]);
			l = second_of_range(dim_toks[d]);
			# Detect backward ranges and conditionally swap.
			if (u == "0") {
				n = u;
				u = l;
				l = n;
			}
			printf ("[" u "-" l "+1]");
		}
		print (i+1 < port_index ? ";" : "");
	}
	print ") {";
	print "\t// implementation in verilog...";
	print "}";
}
# else unknown output format?
}

# to look like the following:
# module ACT_AND2;
#	wire A1, A2; // need not be reg with acc: wn:*
#	wire Z;
#	parameter prsim_name="";
#	reg [64*8:1] verilog_name;
#	AND2 dummy(A1, A2, Z);
# initial
# begin
# #0	// #0 comes *after* initial!
#	$sformat(verilog_name, "%m");
#	$from_prsim({prsim_name, ".A1"}, {verilog_name, ".A1"});
#	$from_prsim({prsim_name, ".A2"}, {verilog_name, ".A2"});
#	$to_prsim({verilog_name, ".Z"}, {prsim_name, ".Z"});
# end
# endmodule


# for every line
{
	# special handling of strings
	in_string = 0;
	# lex_it
	ntoks = split(tokenize($0), toks);
	for (i=1; i<= ntoks; ++i) {
	if (length(toks[i])) {
		next_tok = toks[i];
		start_str = match(next_tok, "^\"");
		if (start_str) {
			in_string = 1;	# open string
			str = next_tok;
		}
		if (in_string && !start_str) {
			str = str " " next_tok;
		}
		if (match(next_tok, "[^\\\\]\"$")) {
			in_string = 0;	# close string
			next_tok = str;
		}
		if (in_string) {
			continue;
		} else {
		if (debug) {
			parse_debug();
			print "token[line:" NR "][" i "]: " next_tok;
		}
		parse_it(next_tok);
		}
	}
	}
}

END {
# if (!error) { }
}
