/**
	\file "env.hac"
	vi: ft=cpp
	TODO: document/comment everything -- all definitions
		especially reset conventions
	TODO: CMOS implementability of production rules?
	Names: does 'bitbucket' make sense for general 1ofN?
		Just call it sink?
	$Id: env.hac,v 1.7 2006/09/13 02:28:47 fang Exp $
 */

import "channel.hac";
import "alternator.hac";

/**
	TODO: get rid of this and make it a relaxed parameter 
		possibly with default value.
		(requires relaxed parameters to work first.)
 */
pint EnvDelay = 100;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	unit cell for N state alternator
	TODO: consider making this CMOS implementable.
 */
template <pbool start>
defproc source_cell(bool l,le,s,se,r,re,_Reset)
  {
  bool x,y;
  s=r;
//  hse {*[[l]; le-; [~l]; le+; [se & re]; s+; [~se & ~re]; s-]}
  prs{
    [after=EnvDelay] _Reset & ~x & ~y & l -> le-
    [after=EnvDelay] _Reset &  ~y & ~le -> x+
    [after=EnvDelay] ~ _Reset | x & ~y & ~l -> le+
    [after=EnvDelay] _Reset & x & le -> y+
    [after=EnvDelay] _Reset & x & y & se & re -> s+
    [after=EnvDelay] ~_Reset | y & s -> x-
    [after=EnvDelay]  ~_Reset | ~x & y & ~se & ~re -> s-
    [after=EnvDelay] ~_Reset | ~x & ~s -> y-
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	initializes a token in the alternator
 */
defproc start_cell(bool l,le,r,re,_Reset)
  {
  bool x,y;
//  hse {*[[re]; r+; [~re]; r-; [l]; le-; [~l]; le+]}
  prs{
    [after=EnvDelay] _Reset & ~x & ~y & re -> r+
    [after=EnvDelay] _Reset & ~y & r -> x+
    [after=EnvDelay] ~_Reset | x & ~y & ~re -> r-
    [after=EnvDelay] _Reset & x & ~r -> y+
    [after=EnvDelay] _Reset & x & y & l -> le-
    [after=EnvDelay] ~_Reset | y & ~le -> x-
    [after=EnvDelay] ~_Reset | ~x & y & ~l -> le+
    [after=EnvDelay] ~_Reset | ~x & le -> y-
    }
  }

//-----------------------------------------------------------------------------
/**
	step through N values for an e1of(M) channel
 */
template <pint N, M, d[N]>
defproc source_e(e1of<M> rr; bool _Reset)
  {
  c1of<M> r;
  e1of<N> s;
  s.e=rr.e;
  bool l[N+1],le[N+1];
  source_cell<false> sc[N];
  (;i:0..N-1: sc[i](l[i],le[i],s.d[i],s.e,l[i+1],le[i+1],_Reset);)
  start_cell stc(l[N],le[N],l[0],le[0],_Reset);
  prs{
    (:i:N: [after=EnvDelay] s.d[i] -> r.d[d[i]]+ )
    (:i:M: [after=EnvDelay] (&:j:0..N-1: ~s.d[j] ) -> r.d[i]- ) 
    (:i:M: [after=EnvDelay] r.d[i] -> rr.d[i]+ )
    (:i:M: [after=EnvDelay] ~r.d[i] -> rr.d[i]- )
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	step through N values for an a1of(M) channel
 */
template <pint N, M, d[N]>
defproc source_a(a1of<M> rr; bool _Reset)
  {
  c1of<M> r;
  e1of<N> s;
  bool l[N+1],le[N+1];
  source_cell<false> sc[N];
  (;i:0..N-1: sc[i](l[i],le[i],s.d[i],s.e,l[i+1],le[i+1],_Reset);)
  start_cell stc(l[N],le[N],l[0],le[0],_Reset);
  prs{
    (:i:N: [after=EnvDelay] s.d[i] -> r.d[d[i]]+ )
    (:i:M: [after=EnvDelay] (&:j:0..N-1: ~s.d[j] ) -> r.d[i]- )
    (:i:M: [after=EnvDelay] r.d[i] -> rr.d[i]+ )
    (:i:M: [after=EnvDelay] ~r.d[i] -> rr.d[i]- )
    [after=EnvDelay] rr.a -> s.e-
    [after=EnvDelay] ~rr.a -> s.e+
    }
  }

//=============================================================================
// CMOS-implementable TOKEN SOURCES

/**
	Generalized channel source
	Implementation notes: no large shared dynamic logic nodes, 
		the only part that is O(N) is the fanout of R.e.  
	Note: this does not use any EnvDelay parameters.  
	env: R.e may be high or low on reset.  
	Tested: env-cmos-source-sink-e-01.{hac,prsimrc}
	Tested: env-cmos-source-sink-e-02.{hac,prsimrc}
	\param M is the number of rails of channel
	\param N is the number of values in sequence > 2
		(TODO: cases where N <= 2)
	\param D is the array of values to cycle through
 */
template <pint N, M, D[N]>
defproc cmos_source_e(e1of<M> R; bool _Reset, Reset) {
// cause failures for N < 3 for now...
[(N < 3) ->
	pbool N_must_be_greater_than_2_for_now;
[N_must_be_greater_than_2_for_now ->
	N_must_be_greater_than_2_for_now = true;
]
]
bool _s[N], s[N], _o[M];
// bool _se[N], se[N];
onehot_stage_init i0(R.e, _s[N-2], s[N-1], _s[0], s[0], _s[1], Reset);
onehot_stage i[1..N-1];
(;j:1..N-1:
	i[j](R.e, _s[(N+j-2)%N], s[j-1], _s[j], s[j], _s[(j+1)%N], _Reset);
)
prs {
		// first one needs a reset
		// ~_Reset				-> _se[0]+
	(:j:M:	// for each rail
		~_Reset				-> _o[j]+
			// reset is only needed for nodes that never fire
		_o[j]				=> R.d[j]-	// output inv.
	(:r:N:	// for each value
		// all rails reset
	[j == D[r] ->
		// if rail-number matches value, then add rules
/**
		~R.e & ~s[r]			-> _se[r]+
		R.e & s[r]			-> _se[r]-
		// _se[r]				=> se[r]-
		_se[r] & s[(r+1)%N]		-> se[r]-
		~_se[r]				-> se[r]+
		Reset				-> se[r]-

		// ~se[r] & ~_s[(r+1)%N] & ~s[(r+2)%N]	-> _o[j]+
		~se[r] & ~s[(r+2)%N]		-> _o[j]+
		se[r] & s[(r+1)%N]		-> _o[j]-
**/
		// ewww... 4p, but single-fanout
		~R.e & ~s[r] & ~_s[(r+1)%N] & ~s[(r+2)%N]	-> _o[j]+
		 R.e &  s[r] &  s[(r+1)%N]			-> _o[j]-
	]
	)
	)
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	CMOS-implementable a1ofN source.  
	\param M is the number of rails of channel
	\param N is the number of values in sequence
	\param D is the array of values to cycle through
 */
template <pint N, M, D[N]>
defproc cmos_source_a(a1of<M> R; bool _Reset, Reset) {
// being cheap...
e1of<M> r;
R.d = r.d;
prs {
	R.a					=> r.e-
}
cmos_source_e<N,M,D> s(r, _Reset, Reset);
}

//-----------------------------------------------------------------------------
/**
	TODO: faster, pipelined cmos_sources, using onehot_counter
	and full or half-buffers.
 */
// defproc fast_cmos_source_e(...)

//=============================================================================
// TOKEN SINKS

/**
	bitbucket for e1of(N) channel
	This is now CMOS-implementable.  
	This bucket resets with the enable 'e' low.  
 */
template <pint N>
defproc bitbucket_e1of(e1of<N> l; bool _Reset)
  {
  bool __le,_le;
  prs{
    [after=EnvDelay] (|:i:0..N-1: l.d[i]) -> __le-
    [after=EnvDelay] (&:i:0..N-1: ~l.d[i]) -> __le+
    [after=EnvDelay] ~_Reset | ~__le -> _le+
    [after=EnvDelay] _Reset & __le -> _le-
    [after=EnvDelay] _le -> l.e-
    [after=EnvDelay] ~_le -> l.e+
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	bitbucket for a1of(N) channel
	This is now CMOS-implementable.  
	This bucket resets with the acknowledge 'a' high.  
 */
template <pint N>
defproc bitbucket_a1of(a1of<N> l; bool _Reset)
  {
  bool _la;
  prs{
    [after=EnvDelay] (|:i:0..N-1: l.d[i]) -> _la-
    [after=EnvDelay] (&:i:0..N-1: ~l.d[i]) -> _la+
    [after=EnvDelay] ~_Reset | ~_la -> l.a+
    [after=EnvDelay] _Reset & _la -> l.a-
    }
  }

//-----------------------------------------------------------------------------
/**
	bundled bitbucket for a M x e1of(N) channel
 */
template <pint N, M>
defproc bitbucket_Mxe1of(e1of<N> r[M-1]; bool _Reset)
  {
  e1of<N> s[0..M-1];
  bool se, _se;
  bitbucket_e1of<N> be[M-1];
  (;i:0..M-1: r[i].d=s[i].d; r[i].e=se;)
  (;i:0..M-1: be[i](s[i],_Reset);)
  prs{
    [after=EnvDelay] (&:i:0..M-1: ~s[i].e) -> _se+
    [after=EnvDelay] (&:i:0..M-1: s[i].e) -> _se-
	_se				=> se-
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	bundled bitbucket for a M x a1of(N) channel
 */
template <pint N, M>
defproc bitbucket_Mxa1of(a1of<N> r[M-1]; bool _Reset)
  {
  a1of<N> s[0..M-1];
  bool sa, _sa;
  bitbucket_a1of<N> ba[M-1];
  (;i:0..M-1: r[i].d=s[i].d; r[i].a=sa;)
  (;i:0..M-1: ba[i](s[i],_Reset);)
  prs{
    [after=EnvDelay] (&:i:0..M-1: s[i].a) -> _sa-
    [after=EnvDelay] (&:i:0..M-1: ~s[i].a) -> _sa+
	_sa				=> sa-
    }
  }

/***************** WRAPPERS FOR SPECIFIC 1of(N) SOURCES *******************/

template <pint N, d[N]>
typedef source_e<N, 2, d> source_e1of2;

template <pint N, d[N]>
typedef source_a<N, 2, d> source_a1of2;

template <pint N, d[N]>
typedef cmos_source_e<N, 2, d> cmos_source_e1of2;

template <pint N, d[N]>
typedef cmos_source_a<N, 2, d> cmos_source_a1of2;

template <pint N, d[N]>
typedef source_e<N, 3, d> source_e1of3;

template <pint N, d[N]>
typedef source_a<N, 3, d> source_a1of3;

template <pint N, d[N]>
typedef cmos_source_e<N, 3, d> cmos_source_e1of3;

template <pint N, d[N]>
typedef cmos_source_a<N, 3, d> cmos_source_a1of3;

template <pint N, d[N]>
typedef source_e<N, 4, d> source_e1of4;

template <pint N, d[N]>
typedef source_a<N, 4, d> source_a1of4;

template <pint N, d[N]>
typedef cmos_source_e<N, 4, d> cmos_source_e1of4;

template <pint N, d[N]>
typedef cmos_source_a<N, 4, d> cmos_source_a1of4;

template <pint N, d[N]>
typedef source_e<N, 5, d> source_e1of5;

template <pint N, d[N]>
typedef source_a<N, 5, d> source_a1of5;

template <pint N, d[N]>
typedef cmos_source_e<N, 5, d> cmos_source_e1of5;

template <pint N, d[N]>
typedef cmos_source_a<N, 5, d> cmos_source_a1of5;

template <pint N, d[N]>
typedef source_e<N, 6, d> source_e1of6;

template <pint N, d[N]>
typedef source_a<N, 6, d> source_a1of6;

template <pint N, d[N]>
typedef cmos_source_e<N, 6, d> cmos_source_e1of6;

template <pint N, d[N]>
typedef cmos_source_a<N, 6, d> cmos_source_a1of6;

template <pint N, d[N]>
typedef source_e<N, 7, d> source_e1of7;

template <pint N, d[N]>
typedef source_a<N, 7, d> source_a1of7;

template <pint N, d[N]>
typedef cmos_source_e<N, 7, d> cmos_source_e1of7;

template <pint N, d[N]>
typedef cmos_source_a<N, 7, d> cmos_source_a1of7;

template <pint N, d[N]>
typedef source_e<N, 8, d> source_e1of8;

template <pint N, d[N]>
typedef source_a<N, 8, d> source_a1of8;

template <pint N, d[N]>
typedef cmos_source_e<N, 8, d> cmos_source_e1of8;

template <pint N, d[N]>
typedef cmos_source_a<N, 8, d> cmos_source_a1of8;


/***************** WRAPPERS FOR SPECIFIC 1of(N) BITBUCKETS *******************/

typedef	bitbucket_e1of<1>	bitbucket_e1of1;
typedef	bitbucket_e1of<2>	bitbucket_e1of2;
typedef	bitbucket_e1of<3>	bitbucket_e1of3;
typedef	bitbucket_e1of<4>	bitbucket_e1of4;
typedef	bitbucket_e1of<5>	bitbucket_e1of5;
typedef	bitbucket_e1of<6>	bitbucket_e1of6;
typedef	bitbucket_e1of<7>	bitbucket_e1of7;
typedef	bitbucket_e1of<8>	bitbucket_e1of8;

typedef	bitbucket_a1of<1>	bitbucket_a1of1;
typedef	bitbucket_a1of<2>	bitbucket_a1of2;
typedef	bitbucket_a1of<3>	bitbucket_a1of3;
typedef	bitbucket_a1of<4>	bitbucket_a1of4;
typedef	bitbucket_a1of<5>	bitbucket_a1of5;
typedef	bitbucket_a1of<6>	bitbucket_a1of6;
typedef	bitbucket_a1of<7>	bitbucket_a1of7;
typedef	bitbucket_a1of<8>	bitbucket_a1of8;

/***************** BUNDLED ACKNOWLEDGE BITBUCKETS ***************/

template <pint M>
typedef bitbucket_Mxe1of<2,M>	bitbucket_Mxe1of2;

template <pint M>
typedef bitbucket_Mxa1of<2,M>	bitbucket_Mxa1of2;

template <pint M>
typedef bitbucket_Mxe1of<4,M>	bitbucket_Mxe1of4;

template <pint M>
typedef bitbucket_Mxa1of<4,M>	bitbucket_Mxa1of4;


/******************** INACTIVE RESET BITBUCKETS ******************/

/**
	TODO: explain naming convention.  
	Q: what does inactive mean?
	This is CMOS-implementable.  
	Does it imply 'e' is high on reset? (my guess)
 */
template <pint N>
defproc inactive_reset_bitbucket_e1of(e1of<N> r; bool _Reset)
  {
  bool __re,_re;
  prs{
    [after=EnvDelay] _Reset & (|:i:N: r.d[i] ) -> __re- 
    [after=EnvDelay] ~_Reset | (&:i:N: ~r.d[i] ) -> __re+ 
    [after=EnvDelay] __re -> _re- 
    [after=EnvDelay] ~__re -> _re+
    [after=EnvDelay] _re -> r.e-
    [after=EnvDelay] ~_re -> r.e+ 
    }
  }

typedef	inactive_reset_bitbucket_e1of<1>	inactive_reset_bitbucket_e1of1;
typedef	inactive_reset_bitbucket_e1of<2>	inactive_reset_bitbucket_e1of2;
typedef	inactive_reset_bitbucket_e1of<3>	inactive_reset_bitbucket_e1of3;
typedef	inactive_reset_bitbucket_e1of<4>	inactive_reset_bitbucket_e1of4;
typedef	inactive_reset_bitbucket_e1of<5>	inactive_reset_bitbucket_e1of5;
typedef	inactive_reset_bitbucket_e1of<6>	inactive_reset_bitbucket_e1of6;
typedef	inactive_reset_bitbucket_e1of<7>	inactive_reset_bitbucket_e1of7;
typedef	inactive_reset_bitbucket_e1of<8>	inactive_reset_bitbucket_e1of8;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	TODO: explain naming convention.  
	This is CMOS-implementable.  
	Does it imply 'a' is low on reset? (my guess)
 */
template <pint N>
defproc inactive_reset_bitbucket_a1of(a1of<N> r; bool _Reset)
  {
  bool _ra;
  prs{
    [after=EnvDelay] (|:i:N: r.d[i] ) & _Reset -> _ra- 
    [after=EnvDelay] (&:i:N: ~r.d[i] ) | ~_Reset -> _ra+ 
    [after=EnvDelay] _ra -> r.a-
    [after=EnvDelay] ~_ra -> r.a+ 
    }
  }

typedef	inactive_reset_bitbucket_a1of<1>	inactive_reset_bitbucket_a1of1;
typedef	inactive_reset_bitbucket_a1of<2>	inactive_reset_bitbucket_a1of2;
typedef	inactive_reset_bitbucket_a1of<3>	inactive_reset_bitbucket_a1of3;
typedef	inactive_reset_bitbucket_a1of<4>	inactive_reset_bitbucket_a1of4;
typedef	inactive_reset_bitbucket_a1of<5>	inactive_reset_bitbucket_a1of5;
typedef	inactive_reset_bitbucket_a1of<6>	inactive_reset_bitbucket_a1of6;
typedef	inactive_reset_bitbucket_a1of<7>	inactive_reset_bitbucket_a1of7;
typedef	inactive_reset_bitbucket_a1of<8>	inactive_reset_bitbucket_a1of8;

/****************** MULTI-CHANNEL SOURCES *******************************/
/* Below are the old CAST versions of multi-channel sources
   They are commented out until relaxed templates are ready in HACKT.
define source_Mxe1of4(int M,N; int[N] d)(e1of4[M] r)
  {
  int[N,M] f;
  int[M] pow;
  pow[0]=1; <i:1..M-1: pow[i]=pow[i-1]*4;>
  <i:M: <j:N: f[j,i]=(d[j]/pow[i])%4;> source_e1of4(N,f[0..N-1,i])(r[i]);>
  }

define source_Mxa1of4(int M,N; int[N] d)(a1of4[M] r)
  {
  int[N,M] f;
  int[M] pow;
  pow[0]=1; <i:1..M-1: pow[i]=pow[i-1]*4;>
  <i:M: <j:N: f[j,i]=(d[j]/pow[i])%4;> source_a1of4(N,f[0..N-1,i])(r[i]);>
  }

*/
