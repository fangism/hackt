/**
	\file "env.hac"
	TODO: document/comment everything -- all definitions
		especially reset conventions
	TODO: CMOS implementability of production rules?
	Names: does 'bitbucket' make sense for general 1ofN?
		Just call it sink?
	$Id: env.hac,v 1.4 2006/08/04 15:00:29 sandra Exp $
 */
import "channel.hac";

/**
	TODO: get rid of this and make it a relaxed parameter 
		possibly with default value.
		(requires relaxed parameters to work first.)
 */
pint EnvDelay = 100;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	unit cell for N state alternator
	TODO: consider making this CMOS implementable.
 */
template <pbool start>
defproc source_cell(bool l,le,s,se,r,re,_Reset)
  {
  bool x,y;
  s=r;
//  hse {*[[l]; le-; [~l]; le+; [se & re]; s+; [~se & ~re]; s-]}
  prs{
    [after=EnvDelay] _Reset & ~x & ~y & l -> le-
    [after=EnvDelay] _Reset &  ~y & ~le -> x+
    [after=EnvDelay] ~ _Reset | x & ~y & ~l -> le+
    [after=EnvDelay] _Reset & x & le -> y+
    [after=EnvDelay] _Reset & x & y & se & re -> s+
    [after=EnvDelay] ~_Reset | y & s -> x-
    [after=EnvDelay]  ~_Reset | ~x & y & ~se & ~re -> s-
    [after=EnvDelay] ~_Reset | ~x & ~s -> y-
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	initializes a token in the alternator
 */
defproc start_cell(bool l,le,r,re,_Reset)
  {
  bool x,y;
//  hse {*[[re]; r+; [~re]; r-; [l]; le-; [~l]; le+]}
  prs{
    [after=EnvDelay] _Reset & ~x & ~y & re -> r+
    [after=EnvDelay] _Reset & ~y & r -> x+
    [after=EnvDelay] ~_Reset | x & ~y & ~re -> r-
    [after=EnvDelay] _Reset & x & ~r -> y+
    [after=EnvDelay] _Reset & x & y & l -> le-
    [after=EnvDelay] ~_Reset | y & ~le -> x-
    [after=EnvDelay] ~_Reset | ~x & y & ~l -> le+
    [after=EnvDelay] ~_Reset | ~x & le -> y-
    }
  }

//-----------------------------------------------------------------------------
/**
	step through N values for an e1of(M) channel
 */
template <pint N, M, d[N]>
defproc source_e(e1of<M> rr; bool _Reset)
  {
  c1of<M> r;
  e1of<N> s;
  s.e=rr.e;
  bool l[N+1],le[N+1];
  source_cell<false> sc[N];
  (;i:0..N-1: sc[i](l[i],le[i],s.d[i],s.e,l[i+1],le[i+1],_Reset);)
  start_cell stc(l[N],le[N],l[0],le[0],_Reset);
  prs{
    (:i:N: [after=EnvDelay] s.d[i] -> r.d[d[i]]+ )
    (:i:M: [after=EnvDelay] (&:j:0..N-1: ~s.d[j] ) -> r.d[i]- ) 
    (:i:M: [after=EnvDelay] r.d[i] -> rr.d[i]+ )
    (:i:M: [after=EnvDelay] ~r.d[i] -> rr.d[i]- )
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	step through N values for an a1of(M) channel
 */
template <pint N, M, d[N]>
defproc source_a(a1of<M> rr; bool _Reset)
  {
  c1of<M> r;
  e1of<N> s;
  bool l[N+1],le[N+1];
  source_cell<false> sc[N];
  (;i:0..N-1: sc[i](l[i],le[i],s.d[i],s.e,l[i+1],le[i+1],_Reset);)
  start_cell stc(l[N],le[N],l[0],le[0],_Reset);
  prs{
    (:i:N: [after=EnvDelay] s.d[i] -> r.d[d[i]]+ )
    (:i:M: [after=EnvDelay] (&:j:0..N-1: ~s.d[j] ) -> r.d[i]- )
    (:i:M: [after=EnvDelay] r.d[i] -> rr.d[i]+ )
    (:i:M: [after=EnvDelay] ~r.d[i] -> rr.d[i]- )
    [after=EnvDelay] rr.a -> s.e-
    [after=EnvDelay] ~rr.a -> s.e+
    }
  }

//=============================================================================
// TOKEN SINKS

/**
	bitbucket for e1of(N) channel
	This bucket resets with the enable 'e' low.  
 */
template <pint N>
defproc bitbucket_e1of(e1of<N> l; bool _Reset)
  {
  bool __le,_le;
  prs{
    [after=EnvDelay] ~_Reset | (|:i:0..N-1: l.d[i]) -> __le-
    [after=EnvDelay] _Reset & (&:i:0..N-1: ~l.d[i]) -> __le+
    [after=EnvDelay] ~__le -> _le+
    [after=EnvDelay] __le -> _le-
    [after=EnvDelay] _le -> l.e-
    [after=EnvDelay] ~_le -> l.e+
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	bitbucket for a1of(N) channel
	This bucket resets with the enable 'a' high.  
 */
template <pint N>
defproc bitbucket_a1of(a1of<N> l; bool _Reset)
  {
  bool __la,_la;
  prs{
    [after=EnvDelay] ~_Reset | (|:i:0..N-1: l.d[i]) -> __la+
    [after=EnvDelay] _Reset & (&:i:0..N-1: ~l.d[i]) -> __la-
    [after=EnvDelay] __la -> _la-
    [after=EnvDelay] ~__la -> _la+
    [after=EnvDelay] ~_la -> l.a+
    [after=EnvDelay] _la -> l.a-
    }
  }

//-----------------------------------------------------------------------------
/**
	bundled bitbucket for a M x e1of(N) channel
 */
template <pint N, M>
defproc bitbucket_Mxe1of(e1of<N> r[M-1]; bool _Reset)
  {
  e1of<N> s[0..M-1];
  bool se;
  bitbucket_e1of<N> be[M-1];
  (;i:0..M-1: r[i].d=s[i].d; r[i].e=se;)
  (;i:0..M-1: be[i](s[i],_Reset);)
  prs{
    [after=EnvDelay] (&:i:0..M-1: ~s[i].e) -> se-
    [after=EnvDelay] (&:i:0..M-1: s[i].e) -> se+  
    }
  }

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	bundled bitbucket for a M x a1of(N) channel
 */
template <pint N, M>
defproc bitbucket_Mxa1of(a1of<N> r[M-1]; bool _Reset)
  {
  a1of<N> s[0..M-1];
  bool sa;
  bitbucket_a1of<N> ba[M-1];
  (;i:0..M-1: r[i].d=s[i].d; r[i].a=sa;)
  (;i:0..M-1: ba[i](s[i],_Reset);)
  prs{
    [after=EnvDelay] (&:i:0..M-1: s[i].a) -> sa+
    [after=EnvDelay] (&:i:0..M-1: ~s[i].a) -> sa- 
    }
  }

/***************** WRAPPERS FOR SPECIFIC 1of(N) SOURCES *******************/

template <pint N, d[N]>
typedef source_e<N, 2, d> source_e1of2;

template <pint N, d[N]>
typedef source_a<N, 2, d> source_a1of2;

template <pint N, d[N]>
typedef source_e<N, 3, d> source_e1of3;

template <pint N, d[N]>
typedef source_a<N, 3, d> source_a1of3;

template <pint N, d[N]>
typedef source_e<N, 4, d> source_e1of4;

template <pint N, d[N]>
typedef source_a<N, 4, d> source_a1of4;

template <pint N, d[N]>
typedef source_e<N, 5, d> source_e1of5;

template <pint N, d[N]>
typedef source_a<N, 5, d> source_a1of5;

template <pint N, d[N]>
typedef source_e<N, 6, d> source_e1of6;

template <pint N, d[N]>
typedef source_a<N, 6, d> source_a1of6;

template <pint N, d[N]>
typedef source_e<N, 7, d> source_e1of7;

template <pint N, d[N]>
typedef source_a<N, 7, d> source_a1of7;

template <pint N, d[N]>
typedef source_e<N, 8, d> source_e1of8;

template <pint N, d[N]>
typedef source_a<N, 8, d> source_a1of8;


/***************** WRAPPERS FOR SPECIFIC 1of(N) BITBUCKETS *******************/

typedef	bitbucket_e1of<1>	bitbucket_e1of1;
typedef	bitbucket_e1of<2>	bitbucket_e1of2;
typedef	bitbucket_e1of<3>	bitbucket_e1of3;
typedef	bitbucket_e1of<4>	bitbucket_e1of4;
typedef	bitbucket_e1of<5>	bitbucket_e1of5;
typedef	bitbucket_e1of<6>	bitbucket_e1of6;
typedef	bitbucket_e1of<7>	bitbucket_e1of7;
typedef	bitbucket_e1of<8>	bitbucket_e1of8;

typedef	bitbucket_a1of<1>	bitbucket_a1of1;
typedef	bitbucket_a1of<2>	bitbucket_a1of2;
typedef	bitbucket_a1of<3>	bitbucket_a1of3;
typedef	bitbucket_a1of<4>	bitbucket_a1of4;
typedef	bitbucket_a1of<5>	bitbucket_a1of5;
typedef	bitbucket_a1of<6>	bitbucket_a1of6;
typedef	bitbucket_a1of<7>	bitbucket_a1of7;
typedef	bitbucket_a1of<8>	bitbucket_a1of8;

/***************** BUNDLED ACKNOWLEDGE BITBUCKETS ***************/

template <pint M>
typedef bitbucket_Mxe1of<2,M>	bitbucket_Mxe1of2;

template <pint M>
typedef bitbucket_Mxa1of<2,M>	bitbucket_Mxa1of2;

template <pint M>
typedef bitbucket_Mxe1of<4,M>	bitbucket_Mxe1of4;

template <pint M>
typedef bitbucket_Mxa1of<4,M>	bitbucket_Mxa1of4;


/******************** INACTIVE RESET BITBUCKETS ******************/

/**
	TODO: explain naming convention.  
	Q: what does inactive mean?
	Does it imply 'e' is high on reset? (my guess)
 */
template <pint N>
defproc inactive_reset_bitbucket_e1of(e1of<N> r; bool _Reset)
  {
  bool __re,_re;
  prs{
    [after=EnvDelay] _Reset & (|:i:N: r.d[i] ) -> __re- 
    [after=EnvDelay] ~_Reset | (&:i:N: ~r.d[i] ) -> __re+ 
    [after=EnvDelay] __re -> _re- 
    [after=EnvDelay] ~__re -> _re+
    [after=EnvDelay] _re -> r.e-
    [after=EnvDelay] ~_re -> r.e+ 
    }
  }

typedef	inactive_reset_bitbucket_e1of<1>	inactive_reset_bitbucket_e1of1;
typedef	inactive_reset_bitbucket_e1of<2>	inactive_reset_bitbucket_e1of2;
typedef	inactive_reset_bitbucket_e1of<3>	inactive_reset_bitbucket_e1of3;
typedef	inactive_reset_bitbucket_e1of<4>	inactive_reset_bitbucket_e1of4;
typedef	inactive_reset_bitbucket_e1of<5>	inactive_reset_bitbucket_e1of5;
typedef	inactive_reset_bitbucket_e1of<6>	inactive_reset_bitbucket_e1of6;
typedef	inactive_reset_bitbucket_e1of<7>	inactive_reset_bitbucket_e1of7;
typedef	inactive_reset_bitbucket_e1of<8>	inactive_reset_bitbucket_e1of8;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	TODO: explain naming convention.  
	Does it imply 'a' is low on reset?
 */
template <pint N>
defproc inactive_reset_bitbucket_a1of(a1of<N> r; bool _Reset)
  {
  bool __ra,_ra;
  prs{
    [after=EnvDelay] (|:i:N: r.d[i] ) -> __ra- 
    [after=EnvDelay] (&:i:N: ~r.d[i] ) -> __ra+ 
    [after=EnvDelay] _Reset & __ra -> _ra- 
    [after=EnvDelay] ~_Reset | ~__ra -> _ra+
    [after=EnvDelay] _ra -> r.a-
    [after=EnvDelay] ~_ra -> r.a+ 
    }
  }

typedef	inactive_reset_bitbucket_a1of<1>	inactive_reset_bitbucket_a1of1;
typedef	inactive_reset_bitbucket_a1of<2>	inactive_reset_bitbucket_a1of2;
typedef	inactive_reset_bitbucket_a1of<3>	inactive_reset_bitbucket_a1of3;
typedef	inactive_reset_bitbucket_a1of<4>	inactive_reset_bitbucket_a1of4;
typedef	inactive_reset_bitbucket_a1of<5>	inactive_reset_bitbucket_a1of5;
typedef	inactive_reset_bitbucket_a1of<6>	inactive_reset_bitbucket_a1of6;
typedef	inactive_reset_bitbucket_a1of<7>	inactive_reset_bitbucket_a1of7;
typedef	inactive_reset_bitbucket_a1of<8>	inactive_reset_bitbucket_a1of8;

/****************** MULTI-CHANNEL SOURCES *******************************/
/* Below are the old CAST versions of multi-channel sources
   They are commented out until relaxed templates are ready in HACKT.
define source_Mxe1of4(int M,N; int[N] d)(e1of4[M] r)
  {
  int[N,M] f;
  int[M] pow;
  pow[0]=1; <i:1..M-1: pow[i]=pow[i-1]*4;>
  <i:M: <j:N: f[j,i]=(d[j]/pow[i])%4;> source_e1of4(N,f[0..N-1,i])(r[i]);>
  }

define source_Mxa1of4(int M,N; int[N] d)(a1of4[M] r)
  {
  int[N,M] f;
  int[M] pow;
  pow[0]=1; <i:1..M-1: pow[i]=pow[i-1]*4;>
  <i:M: <j:N: f[j,i]=(d[j]/pow[i])%4;> source_a1of4(N,f[0..N-1,i])(r[i]);>
  }

*/
