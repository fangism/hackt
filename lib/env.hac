import "channel.hac";

pint EnvDelay = 100;

/*** unit cell for N state alternator ***/
template <pbool start>
defproc source_cell(bool l,le,s,se,r,re,_Reset)
  {
  bool x,y;
  s=r;
//  hse {*[[l]; le-; [~l]; le+; [se & re]; s+; [~se & ~re]; s-]}
  prs{
    [after=EnvDelay] _Reset & ~x & ~y & l -> le-
    [after=EnvDelay] _Reset &  ~y & ~le -> x+
    [after=EnvDelay] ~ _Reset | x & ~y & ~l -> le+
    [after=EnvDelay] _Reset & x & le -> y+
    [after=EnvDelay] _Reset & x & y & se & re -> s+
    [after=EnvDelay] ~_Reset | y & s -> x-
    [after=EnvDelay]  ~_Reset | ~x & y & ~se & ~re -> s-
    [after=EnvDelay] ~_Reset | ~x & ~s -> y-
    }
  }

/*** initializes a token in the alternator ***/
defproc start_cell(bool l,le,r,re,_Reset)
  {
  bool x,y;
//  hse {*[[re]; r+; [~re]; r-; [l]; le-; [~l]; le+]}
  prs{
    [after=EnvDelay] _Reset & ~x & ~y & re -> r+
    [after=EnvDelay] _Reset & ~y & r -> x+
    [after=EnvDelay] ~_Reset | x & ~y & ~re -> r-
    [after=EnvDelay] _Reset & x & ~r -> y+
    [after=EnvDelay] _Reset & x & y & l -> le-
    [after=EnvDelay] ~_Reset | y & ~le -> x-
    [after=EnvDelay] ~_Reset | ~x & y & ~l -> le+
    [after=EnvDelay] ~_Reset | ~x & le -> y-
    }
  }

/*** step through N values for an e1of(M) channel ***/
template <pint N, M, d[N]>
defproc source_e(e1of<M> rr; bool _Reset)
  {
  c1of<M> r;
  e1of<N> s;
  s.e=rr.e;
  bool l[N+1],le[N+1];
  source_cell<false> sc[N];
  (;i:0..N-1: sc[i](l[i],le[i],s.d[i],s.e,l[i+1],le[i+1],_Reset);)
  start_cell stc(l[N],le[N],l[0],le[0],_Reset);
  prs{
    (:i:N: [after=EnvDelay] s.d[i] -> r.d[d[i]]+ )
    (:i:M: [after=EnvDelay] (&:j:0..N-1: ~s.d[j] ) -> r.d[i]- ) 
    (:i:M: [after=EnvDelay] r.d[i] -> rr.d[i]+ )
    (:i:M: [after=EnvDelay] ~r.d[i] -> rr.d[i]- )
    }
  }

/*** step through N values for an a1of(M) channel ***/
template <pint N, M, d[N]>
defproc source_a(a1of<M> rr; bool _Reset)
  {
  c1of<M> r;
  e1of<N> s;
  bool l[N+1],le[N+1];
  source_cell<false> sc[N];
  (;i:0..N-1: sc[i](l[i],le[i],s.d[i],s.e,l[i],le[i],_Reset);)
  start_cell stc(l[N],le[N],l[0],le[0],_Reset);
  prs{
    (:i:N: [after=EnvDelay] s.d[i] -> r.d[d[i]]+ )
    (:i:M: [after=EnvDelay] (&:j:0..N-1: ~s.d[j] ) -> r.d[i]- )
    (:i:M: [after=EnvDelay] r.d[i] -> rr.d[i]+ )
    (:i:M: [after=EnvDelay] ~r.d[i] -> rr.d[i]- )
    [after=EnvDelay] rr.a -> s.e-
    [after=EnvDelay] ~rr.a -> s.e+
    }
  }

/*** bitbucket for e1of(N) channel ***/
template <pint N>
defproc bitbucket_e1of(e1of<N> l; bool _Reset)
  {
  bool __le,_le;
  prs{
    [after=EnvDelay] ~_Reset | (|:i:0..N-1: l.d[i]) -> __le-
    [after=EnvDelay] _Reset & (&:i:0..N-1: ~l.d[i]) -> __le+
    [after=EnvDelay] ~__le -> _le+
    [after=EnvDelay] __le -> _le-
    [after=EnvDelay] _le -> l.e-
    [after=EnvDelay] ~_le -> l.e+
    }
  }

/*** bitbucket for a1of(N) channel ***/
template <pint N>
defproc bitbucket_a1of(a1of<N> l; bool _Reset)
  {
  bool __la,_la;
  prs{
    [after=EnvDelay] ~_Reset | (|:i:0..N-1: l.d[i]) -> __la+
    [after=EnvDelay] _Reset & (&:i:0..N-1: ~l.d[i]) -> __la-
    [after=EnvDelay] __la -> _la-
    [after=EnvDelay] ~__la -> _la+
    [after=EnvDelay] ~_la -> l.a+
    [after=EnvDelay] _la -> l.a-
    }
  }

/*** bundled bitbucket for a M x e1of(N) channel ***/
template <pint N, M>
defproc bitbucket_Mxe1of(e1of<N> r[M-1]; bool _Reset)
  {
  e1of<N> s[0..M-1];
  bool se;
  bitbucket_e1of<N> be[M-1];
  (;i:0..M-1: r[i].d=s[i].d; r[i].e=se;)
  (;i:0..M-1: be[i](s[i],_Reset);)
  prs{
    [after=EnvDelay] (&:i:0..M-1: ~s[i].e) -> se-
    [after=EnvDelay] (&:i:0..M-1: s[i].e) -> se+  
    }
  }

/*** bundled bitbucket for a M x a1of(N) channel ***/
template <pint N, M>
defproc bitbucket_Mxa1of(a1of<N> r[M-1]; bool _Reset)
  {
  a1of<N> s[0..M-1];
  bool sa;
  bitbucket_a1of<N> ba[M-1];
  (;i:0..M-1: r[i].d=s[i].d; r[i].a=sa;)
  (;i:0..M-1: ba[i](s[i],_Reset);)
  prs{
    [after=EnvDelay] (&:i:0..M-1: s[i].a) -> sa+
    [after=EnvDelay] (&:i:0..M-1: ~s[i].a) -> sa- 
    }
  }

/***************** WRAPPERS FOR SPECIFIC 1of(N) SOURCES *******************/

template <pint N, d[N]>
defproc source_e1of2(e1of2 l; bool _Reset)
  {
  e1of<2> s;
  s.d=l.d; s.e=l.e;
  source_e<N,2,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of2(a1of2 l; bool _Reset)
  {
  a1of<2> s;
  s.d=l.d; s.a=l.a;
  source_a<N,2,d> sa(s,_Reset);
  }

template <pint N, d[N]>
defproc source_e1of3(e1of3 l; bool _Reset)
  {
  e1of<3> s;
  s.d=l.d; s.e=l.e;
  source_e<N,3,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of3(a1of3 l; bool _Reset)
  {
  a1of<3> s;
  s.d=l.d; s.a=l.a;
  source_a<N,3,d> sa(s,_Reset);
  }

template <pint N, d[N]>
defproc source_e1of4(e1of4 l; bool _Reset)
  {
  e1of<4> s;
  s.d=l.d; s.e=l.e;
  source_e<N,4,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of4(a1of4 l; bool _Reset)
  {
  a1of<4> s;
  s.d=l.d; s.a=l.a;
  source_a<N,4,d> sa(s,_Reset);
  }

template <pint N, d[N]>
defproc source_e1of5(e1of5 l; bool _Reset)
  {
  e1of<5> s;
  s.d=l.d; s.e=l.e;
  source_e<N,5,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of5(a1of5 l; bool _Reset)
  {
  a1of<5> s;
  s.d=l.d; s.a=l.a;
  source_a<N,5,d> sa(s,_Reset);
  }

template <pint N, d[N]>
defproc source_e1of6(e1of6 l; bool _Reset)
  {
  e1of<6> s;
  s.d=l.d; s.e=l.e;
  source_e<N,6,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of6(a1of6 l; bool _Reset)
  {
  a1of<6> s;
  s.d=l.d; s.a=l.a;
  source_a<N,6,d> sa(s,_Reset);
  }

template <pint N, d[N]>
defproc source_e1of7(e1of7 l; bool _Reset)
  {
  e1of<7> s;
  s.d=l.d; s.e=l.e;
  source_e<N,7,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of7(a1of7 l; bool _Reset)
  {
  a1of<7> s;
  s.d=l.d; s.a=l.a;
  source_a<N,7,d> sa(s,_Reset);
  }

template <pint N, d[N]>
defproc source_e1of8(e1of8 l; bool _Reset)
  {
  e1of<8> s;
  s.d=l.d; s.e=l.e;
  source_e<N,8,d> se(s,_Reset);
  }

template <pint N, d[N]>
defproc source_a1of8(a1of8 l; bool _Reset)
  {
  a1of<8> s;
  s.d=l.d; s.a=l.a;
  source_a<N,8,d> sa(s,_Reset);
  }

/***************** WRAPPERS FOR SPECIFIC 1of(N) BITBUCKETS *******************/

defproc bitbucket_e1of1(e1of1 r; bool _Reset)
  {
  e1of<1> s;
  s.d[0]=r.d[0]; s.e=r.e;
  bitbucket_e1of<1> be(s,_Reset);
  }

defproc bitbucket_a1of1(a1of1 r; bool _Reset)
  {
  a1of<1> s;
  s.d[0]=r.d[0]; s.a=r.a;
  bitbucket_a1of<1> ba(s,_Reset);
  }

defproc bitbucket_e1of2(e1of2 r; bool _Reset)
  {
  e1of<2> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<2> be(s,_Reset);
  }

defproc bitbucket_a1of2(a1of2 r; bool _Reset)
  {
  a1of<2> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<2> ba(s,_Reset);
  }

defproc bitbucket_e1of3(e1of3 r; bool _Reset)
  {
  e1of<3> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<3> be(s,_Reset);
  }

defproc bitbucket_a1of3(a1of3 r; bool _Reset)
  {
  a1of<3> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<3> ba(s,_Reset);
  }

defproc bitbucket_e1of4(e1of4 r; bool _Reset)
  {
  e1of<4> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<4> be(s,_Reset);
  }

defproc bitbucket_a1of4(a1of4 r; bool _Reset)
  {
  a1of<4> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<4> ba(s,_Reset);
  }

defproc bitbucket_e1of5(e1of5 r; bool _Reset)
  {
  e1of<5> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<5> be(s,_Reset);
  }

defproc bitbucket_a1of5(a1of5 r; bool _Reset)
  {
  a1of<5> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<5> ba(s,_Reset);
  }

defproc bitbucket_e1of6(e1of6 r; bool _Reset)
  {
  e1of<6> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<6> be(s,_Reset);
  }

defproc bitbucket_a1of6(a1of6 r; bool _Reset)
  {
  a1of<6> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<6> ba(s,_Reset);
  }

defproc bitbucket_e1of7(e1of7 r; bool _Reset)
  {
  e1of<7> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<7> be(s,_Reset);
  }

defproc bitbucket_a1of7(a1of7 r; bool _Reset)
  {
  a1of<7> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<7> ba(s,_Reset);
  }

defproc bitbucket_e1of8(e1of8 r; bool _Reset)
  {
  e1of<8> s;
  s.d=r.d; s.e=r.e;
  bitbucket_e1of<8> be(s,_Reset);
  }

defproc bitbucket_a1of8(a1of8 r; bool _Reset)
  {
  a1of<8> s;
  s.d=r.d; s.a=r.a;
  bitbucket_a1of<8> ba(s,_Reset);
  }

/***************** BUNDLED ACKNOWLEDEG BITBUCKETS ***************/

template <pint M>
defproc bitbucket_Mxe1of2(e1of2 r[M]; bool _Reset)
  {
  e1of<2> s[0..M-1];
  (;i:0..M-1: s[i].d=r[i].d; s[i].e=r[i].e;)
  bitbucket_Mxe1of<2,M> bMxe(s,_Reset);
  }

template <pint M>
defproc bitbucket_Mxa1of2(a1of2 r[M]; bool _Reset)
  {
  a1of<2> s[0..M-1];
  (;i:0..M-1: s[i].d=r[i].d; s[i].a=r[i].a;)
  bitbucket_Mxa1of<2,M> bMxa(s,_Reset);
  }

template <pint M>
defproc bitbucket_Mxe1of4(e1of4 r[M]; bool _Reset)
  {
  e1of<4> s[0..M-1];
  (;i:0..M-1: s[i].d=r[i].d; s[i].e=r[i].e;)
  bitbucket_Mxe1of<4,M> bMxe(s,_Reset);
  }

template <pint M>
defproc bitbucket_Mxa1of4(a1of4 r[M]; bool _Reset)
  {
  a1of<4> s[0..M-1];
  (;i:0..M-1: s[i].d=r[i].d; s[i].a=r[i].a;)
  bitbucket_Mxa1of<4,M> bMxa(s,_Reset);
  }

/******************** INACTIVE RESET BITBUCKETS ******************/

defproc inactive_reset_bitbucket_e1of2(e1of2 r; bool _Reset)
  {
  bool __re,_re;
  prs{
    [after=EnvDelay] _Reset & (r.d[0] | r.d[1]) -> __re- 
    [after=EnvDelay] ~_Reset | ~r.d[0] & ~r.d[1] -> __re+ 
    [after=EnvDelay] __re -> _re- 
    [after=EnvDelay] ~__re -> _re+
    [after=EnvDelay] _re -> r.e-
    [after=EnvDelay] ~_re -> r.e+ 
    }
  }

defproc inactive_reset_bitbucket_e1of3(e1of3 r; bool _Reset)
  {
  bool __re,_re;
  prs{
    [after=EnvDelay] _Reset & (r.d[0] | r.d[1] | r.d[2]) -> __re-
    [after=EnvDelay] ~_Reset | ~r.d[0] & ~r.d[1] & ~r.d[2] -> __re+
    [after=EnvDelay] __re -> _re- 
    [after=EnvDelay] ~__re -> _re+
    [after=EnvDelay] _re -> r.e-
    [after=EnvDelay] ~_re -> r.e+ 
    }
  }

defproc inactive_reset_bitbucket_e1of4(e1of4 r; bool _Reset)
  {
  bool __re,_re;
  prs{
    [after=EnvDelay] _Reset & (r.d[0] | r.d[1] | r.d[2] | r.d[3]) -> __re-
    [after=EnvDelay] ~_Reset | ~r.d[0] & ~r.d[1] & ~r.d[2] & ~r.d[3] -> __re+
    [after=EnvDelay] __re -> _re- 
    [after=EnvDelay] ~__re -> _re+
    [after=EnvDelay] _re -> r.e-
    [after=EnvDelay] ~_re -> r.e+ 
    }
  }

/****************** MULTI-CHANNEL SOURCES *******************************/
/* Below are the old CAST versions of multi-channel sources
   They are commented out until relaxed templates are ready in HACKT.
define source_Mxe1of4(int M,N; int[N] d)(e1of4[M] r)
  {
  int[N,M] f;
  int[M] pow;
  pow[0]=1; <i:1..M-1: pow[i]=pow[i-1]*4;>
  <i:M: <j:N: f[j,i]=(d[j]/pow[i])%4;> source_e1of4(N,f[0..N-1,i])(r[i]);>
  }

define source_Mxa1of4(int M,N; int[N] d)(a1of4[M] r)
  {
  int[N,M] f;
  int[M] pow;
  pow[0]=1; <i:1..M-1: pow[i]=pow[i-1]*4;>
  <i:M: <j:N: f[j,i]=(d[j]/pow[i])%4;> source_a1of4(N,f[0..N-1,i])(r[i]);>
  }

*/
