/**
	\file "alternator.hac"
	vi: ft=cpp
	Library for alternator structures and ring-counted structures.
	Everything defined in here is CMOS-implementable and may be
	used to synthesize netlists of environment sources.  
	2-way alternators use a dual-rail bit as a state variable whereas
	N-way alternators will use some sort of one-hot counter.  
	Splits and merges useful for constructing tree-fifos.  

	TODO: e1ofN alterators.

	$Id: alternator.hac,v 1.10 2006/09/19 04:11:42 fang Exp $
 */

import "channel.hac";
	// for c1of<N>

//=============================================================================
/**
	Single slice of a one-hot incrementer.  
	To use this stage, you have ot take the conjunction of
	two adjacent stages s[i-1] & s[i] to form a one-hot code.  
	This basic cell is written this way to allow for general uses
	of the state bits.  
	\param inc the increment/advance signal, 
		may be considered an active low acknowledge 
		or active high request into the cell.  
	\param _si state-bit from i-2 stage.
	\param sj state-bit from i-1 stage.
	\param _sk this state-bit.
	\param sk this state-bit.
	\param _sl state-bit from i+1 stage.
	\param _Reset reset this state-bit to inactive.
 */
defproc onehot_stage(
		bool inc, 
		_si, sj, _sk, sk, _sl, 
		_Reset) {
	prs {
		// unfortunately need _Reset
		_Reset & inc & sj & _si			-> _sk-
		~_sk					-> sk+
		~inc & ~_sl				-> _sk+	// no ~sj
		_sk					-> sk-
		~_Reset					-> _sk+
	}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Variant of onehot_stage that initializes with the token.  
	Same parameters.  
	\param Reset resets the state-bit to active.  
 */
defproc onehot_stage_init(
		bool inc, 
		_si, sj, _sk, sk, _sl, 
		Reset) {
	prs {
		inc & sj & _si				-> _sk-
		~_sk					-> sk+
		~inc & ~_sl				-> _sk+ // no ~sj
		_sk					-> sk-
		Reset					-> _sk-
	}
}

//-----------------------------------------------------------------------------
/**
	Half of an alternator, symmetric.
	This acts as one side of a toggle counter.  
	This is OBSOLETED by the superior variation, below.  
	\param inc the request to advance or toggle
	\param x, y dual-rail state variables
	\param _o1 local inverted output rail
	\param o output rails
 */
defproc symmetric_alternator_stage(
		bool inc,
		x[2], y[2],
		_o1, o[2],
		_Reset) {
prs {
	~_Reset					-> _o1+
	// set-phase affects y
	inc & x[0]				-> y[0]-
	~y[0] & ~(inc & x[1])			-> y[1]+	// x-coupled
	x[0] & y[1] & _Reset			-> _o1-
	~_o1					-> o[1]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled
	~x[0] & ~y[0]				-> _o1+
	_o1 & x[1]				-> o[1]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Half of an alternator, 2-way symmetric.  
	Faster, smaller, and lower latency than the other version.  
	Latency: inc => o+ (2T)
	\param inc the request to advance or toggle
	\param x, y dual-rail state variables
	\param _o1 local inverted output rail
	\param o output rails
 */
defproc symmetric_alternator_stage_fast(
		bool inc,
		x[2], y[2],
		o[2],
		_Reset) {
bool _o;
prs {
	~_Reset					-> _o+

	// set-phase affects y
	inc & x[0]				-> y[0]-
	inc & x[0] & _Reset			-> _o-
	~y[0] & ~(inc & x[1])			-> y[1]+	// x-coupled
	~_o					-> o[0]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc					-> _o+
	~inc & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled
	_o					-> o[0]-
}
}

//-----------------------------------------------------------------------------
/**
	OBSOLETE.
	Size-2 one-hot counter (special case)
	Reset: outputs data rails low, doesn't care about inc signal, 
		requires inc to be HIGH on reset!
	Test: "alternator-1of2-0{1,2}.{hac,prsimrc}"
	HSE: *[[inc];O.0+;[~inc];O.0-;[inc];O.1+;[~inc];O.1-]
	\param inc active-high increment request (or active-low ack)
	\param o the 1of2 output.
 */
defproc alternator_source_1of2_slow(
		bool inc;
		c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
_c1of2 _o;
symmetric_alternator_stage s[2];
	s[0](inc, x.d, y.d, _o.d[1], o.d, _Reset);
	s[1](inc, {x.d[1], x.d[0]}, {y.d[1], y.d[0]}, _o.d[0],
		{o.d[1], o.d[0]}, _Reset);
prs {
	Reset					-> o.d[0]-
//	Reset					-> o.d[1]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

/**
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// set-phase affects y
	inc & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(inc & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> o.d[1]+

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> o.d[1]-

	// set-phase affects y
	inc & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(inc & x.d[0])		-> y.d[0]+	// x-coupled
	x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> o.d[0]+

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
	~x.d[1] & ~y.d[1]			-> _o.d[0]+
	_o.d[0] & x.d[0]			-> o.d[0]-
**/
}
}

//-----------------------------------------------------------------------------
/**
	Source that alternates between two values.  
	Smaller, faster, lower latency, simply superior.  
	Latency: inc -> o+ (2T), ~inc -> o- (2T)
	Reset: inc may be either high or low on reset, doesn't matter.
	Initial: first rail raised will be o.d[0].
	\param inc the increment input signal.
	\param o the dual-rail output.  
 */
defproc alternator_source_1of2_fast(
		bool inc;
		c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
// _c1of2 _o;
symmetric_alternator_stage_fast s[2];
	s[0](inc, x.d, y.d, o.d, _Reset);
	s[1](inc, {x.d[1], x.d[0]}, {y.d[1], y.d[0]}, 
		{o.d[1], o.d[0]}, _Reset);
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  
/**
	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	inc & x.d[0] & _Reset			-> y.d[0]-
	inc & x.d[0] & _Reset			-> _o.d[0]-
	~_o.d[0]				-> o.d[0]+
	~y.d[0] & ~(inc & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc					-> _o.d[0]+
	_o.d[0]					-> o.d[0]-
	~inc & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	inc & x.d[1] & _Reset			-> _o.d[1]-
	inc & x.d[1] & _Reset			-> y.d[1]-
	~_o.d[1]				-> o.d[1]+
	~y.d[1] & ~(inc & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc					-> _o.d[1]+
	_o.d[1]					-> o.d[1]-
	~inc & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
**/
}
}

// typedef	alternator_source_1of2_slow	alternator_source_1of2;
typedef	alternator_source_1of2_fast	alternator_source_1of2;

//-----------------------------------------------------------------------------
/**
	Half of a symmetric lock implementation.  
	Used in definition of alternator_lock_1of2.
 */
defproc alternator_half_lock_slow(
		bool inc[2], x[2], y[2], _o[2], o[2], _Reset) {
prs {

	~_Reset					-> _o[1]+
	// set-phase affects y
	inc[1] & x[0]				-> y[0]-
	~y[0] & ~(inc[0] & x[1])		-> y[1]+	// x-coupled
	x[0] & y[1] & _Reset			-> _o[1]-
	~_o[1]					-> o[1]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc[1] & ~x[0] & ~(o[0] & y[0])	-> x[1]+	// x-coupled
	~x[0] & ~y[0]				-> _o[0]+
	_o[0] & x[1]				-> o[0]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Half of a symmetric lock implementation.  
	Lower latency version.  
	Latency: inc -> o+ (2T)
	Used in definition of alternator_lock_1of2.
 */
defproc alternator_half_lock_fast(
		bool i[2], x[2], y[2], _o, o[2], _Reset) {
prs {
	// ~_Reset					-> _o+

	// reset-phase affects x
	~x[1] & ~i[1] & ~y[0]			-> _o+		// eww, 3p
	_o & y[1]				-> o[0]-
	o[1] & y[1]				-> x[0]-
	~o[0] & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled

	// set-phase affects y
	i[0] & x[1] & y[1]			-> _o-
	~_o					-> o[0]+
	o[0] & x[1] & _Reset			-> y[1]-
	~y[1] & ~(o[1] & x[0])			-> y[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	Reset: inputs low, this will hold _o high on reset.
	Test: alternator-lock-01.{hac,prsimrc}
	TODO: consider lower latency reshuffling.
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc alternator_lock_1of2_slow(
		bool inc[2];
		_c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];
alternator_half_lock_slow s[2];
	s[0](inc, x.d, y.d, _o, o.d, _Reset);
	s[1]({inc[1], inc[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		{_o[1], _o[0]}, {o.d[1], o.d[0]}, _Reset);
prs {
	~_Reset					-> o.d[1]+
//	Reset					-> o.d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

/***
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[1]+
	~_Reset					-> _o[0]+
	// set-phase affects y
	inc[1] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(inc[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o[1]-
	~_o[1]					-> o.d[1]+

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc[1] & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o[0]+
	_o[0] & x.d[1]				-> o.d[0]-

	// set-phase affects y
	inc[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(inc[1] & x.d[0])		-> y.d[0]+	// x-coupled
	x.d[1] & y.d[0] & _Reset		-> _o[0]-
	~_o[0]					-> o.d[0]+

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc[0] & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
	~x.d[1] & ~y.d[1]			-> _o[1]+
	_o[1] & x.d[0]				-> o.d[1]-
***/
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	This can also be connected as an alternating active (a1of1's) 
		bucket that consumes tokens in round-robin.  
		It actively 'requests' for one input at a time.  
	Reset: inputs low, this will hold _o high on reset.
	Test: alternator-lock-02.{hac,prsimrc}
		Has some potential troubles during reset!!!
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc alternator_lock_1of2_fast(
		bool inc[2];
		_c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];
alternator_half_lock_fast s[2];
	s[0](inc, x.d, y.d, _o[0], o.d, _Reset);
	s[1]({inc[1], inc[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		_o[1], {o.d[1], o.d[0]}, _Reset);
// spec { exclhi(inc) }		// not necessarily true on reset
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	~_Reset					-> o.d[0]+
	~_Reset					-> o.d[1]+

	~_Reset					-> _o[0]+
	Reset					-> _o[1]-
/**
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	// set-phase affects y
	inc[1] & x.d[0] & y.d[0]		-> _o[1]-
	~_o[1]					-> o.d[1]+
	// *here* on reset
	o.d[1] & x.d[0] & _Reset		-> y.d[0]-
	~y.d[0] & ~(o.d[0] & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~x.d[1] & ~inc[1] & ~y.d[0]		-> _o[0]+	// eww, 3p
	_o[0] & y.d[1]				-> o.d[0]-
	o.d[1] & y.d[1]				-> x.d[0]-
	~o.d[0] & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	inc[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o.d[0]+
	o.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(o.d[1] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~x.d[0] & ~inc[0] & ~y.d[1]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[0]				-> o.d[1]-
	o.d[0] & y.d[0]				-> x.d[1]-
	~o.d[1] & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
**/
}
}

typedef	alternator_lock_1of2_fast	alternator_lock_1of2;

//-----------------------------------------------------------------------------
/**
	Symmetric half of a passive alternator bucket.  
	NOTE: _o[1] is only passed to express cross-coupled feedback and is 
	not needed in the physical implementation.  
 */
defproc alternator_bucket_half(
		bool i[2], x[2], y[2], _o[2], o[2], _Reset, Reset) {
prs {
	~_Reset					-> _o[0]+
	Reset					-> o[0]-

	// set-phase affects y
	i[0] & x[1] & y[1]			-> _o[0]-
	~_o[0]					-> o[0]+
	x[1] & o[0]				-> y[1]-
	~y[1] & ~(x[0] & o[1])			-> y[0]+	// x-coupled

	// reset-phase affects x
	~i[0] & ~x[0] & ~y[1]			-> _o[0]+	// eww, 3p
	_o[0] & y[0]				-> o[0]-
	_o[0] & y[0]				-> x[1]-
	~o[0] & ~x[1] & ~(_o[1] & y[1])		-> x[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	This process can look like an alternating passive bucket pair, 
	that acknowledges (consumes) tokens on alternating input channels.  
	This variation does not require inputs to be exclusive high, 
	but guarantees that the input enables (active-low) acknowledges
	are exclusive-low.  
	This starts by consuming the L[0] token first.  
	HSE: *[[L0d];L0e-;[~L0d];L0e+;[L1d];L1e-;[~L1d];[L1e+]]
	Reset: Expects L[0].d low on reset
	Test: alternator-bucket-01.{hac,prsimrc}
	Acknowledge latency; 1T! (single inverter)
	\param L input channels.
 */
defproc alternator_bucket_passive_fast(
		e1of1 L[2];
		bool _Reset, Reset) {
c1of2 x, y;
bool i[2], _o[2], o[2];
i[0] = L[0].d[0];
_o[0] = L[0].e;
i[1] = L[1].d[0];
_o[1] = L[1].e;
alternator_bucket_half b[2];
	b[0](i, x.d, y.d, _o, o, _Reset, Reset);
	b[1]({i[1], i[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		{_o[1], _o[0]}, {o[1], o[0]}, _Reset, Reset);
spec {
	exclhi(o)
	excllo(_o)
}
prs {
	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

/***
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+
	Reset					-> o[0]-
	Reset					-> o[1]-

	// set-phase affects y
	i[1] & x.d[0] & y.d[0]			-> _o[1]-
	~_o[1]					-> o[1]+
	x.d[0] & o[1]				-> y.d[0]-
	~y.d[0] & ~(x.d[1] & o[0])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~i[1] & ~x.d[1] & ~y.d[0]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[1]				-> o[1]-
	_o[1] & y.d[1]				-> x.d[0]-
	~o[1] & ~x.d[0] & ~(_o[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	i[0] & x.d[1] & y.d[1]			-> _o[0]-
	~_o[0]					-> o[0]+
	x.d[1] & o[0]				-> y.d[1]-
	~y.d[1] & ~(x.d[0] & o[1])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~i[0] & ~x.d[0] & ~y.d[1]		-> _o[0]+	// eww, 3p
	_o[0] & y.d[0]				-> o[0]-
	_o[0] & y.d[0]				-> x.d[1]-
	~o[0] & ~x.d[1] & ~(_o[1] & y.d[1])	-> x.d[0]+	// x-coupled
***/
}
}

//-----------------------------------------------------------------------------
/**
	Weak-condition onehot counter, cycles through 1ofN rails.  
	Example of use of onehot_stages to form a counter.  
	reset: inc may be either active or inactive on reset.  
	HSE: *[[inc];O.0+;[~inc];O.0-;[inc];O.1+;[~inc];O.1-;...]
	Tested: test/lib/alternator-onehot_counter-01.
	Tested: test/lib/alternator-onehot_counter-02.
	Metrics: inc to out latency is 4 transitions.  
	\param N the number of values to cycle through (> 0).  
	\param inc is effectively an active-low output acknowledge or 
		active-high input request.  
 */
template <pint N>
defproc	onehot_counter(
		bool inc;		// can be .e of e1ofN channel
		c1of<N> o;		// for exclhi
		bool _Reset, Reset) {
	// bool Reset;	// locally generated
[(N > 2) ->
	bool _s[N], s[N], _o[N];
	onehot_stage_init i0(inc, _s[N-2], s[N-1], _s[0], s[0], _s[1], Reset);
	onehot_stage i[1..N-1];
	(;j:1..N-1:
		i[j](inc, _s[(N+j-2)%N], s[j-1],
			_s[j], s[j], _s[(j+1)%N], _Reset);
	)
[] N == 2 ->
	// special case alternator
	alternator_source_1of2 a(inc, o, _Reset, Reset);
[] N == 1 ->
	bool _r;
]
prs {
[(N > 2) ->
	// ring of AND-gates to generate one-hot signal
	// _Reset				=> Reset-
	(:j:N:
		s[j] & s[(j+1)%N]		=> _o[j]-
		_o[j]				=> o.d[j]-
	)
	// TODO: rewrite as trailing else clause
[] else ->
	[ N == 1 ->
		// extremely fast source
		~_Reset					-> _r+
		~inc					-> _r+
		inc & _Reset				-> _r-
		_r					=> o.d[0]-
	]
]
}
}

typedef	onehot_counter<1>		onehot_counter1;
typedef	alternator_source_1of2		onehot_counter2;
typedef	onehot_counter<3>		onehot_counter3;
typedef	onehot_counter<4>		onehot_counter4;
typedef	onehot_counter<5>		onehot_counter5;
typedef	onehot_counter<6>		onehot_counter6;
typedef	onehot_counter<7>		onehot_counter7;
typedef	onehot_counter<8>		onehot_counter8;

//-----------------------------------------------------------------------------
// TODO: onehot_lock
// passes one value though at a time in round-robin fashion.
// in the fashion of alternator_lock_1of2

//-----------------------------------------------------------------------------
/**
	Buffer that eats every other token.  
	"One for you, one for me..."
	Application: forms frequency divider when cascaded serially.
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Other rehufflings may be possible.

	Reset: L.e is high, R.d[0] is low, don't care about R.e
	Tests: alternator-wchb_eater-0{1,2}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
defproc wchb_alternator_eater_2_slow(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
prs {
	Reset					-> R.d[0]-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0] | r1				-> L.e-

	// reset-phase affects x
	R.d[0] & y.d[0]				-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(r1 & y.d[1])	-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+

	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> r1+

	// reset-phase affects x
	r1 & y.d[1]				-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> r1-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Buffer that eats every other token.  
	"One for you, one for me..."
	Application: forms frequency divider when cascaded serially.
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Other rehufflings may be possible.
	Latency: L -> R (2T), when token is passed through.  
	Reset: expects L.d low, R.e can be either high or low.
	Tests: alternator-wchb_eater-0{5,6}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
defproc wchb_alternator_eater_2_fast(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
spec {
	exclhi(R.d[0], r1)
}
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	Reset					-> R.d[0]-

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	R.e & L.d[0] & x.d[0] & y.d[0]		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0]					-> L.e-
	R.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(r1 & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~L.d[0] & ~y.d[0]		-> _o.d[0]+
	_o.d[0] & y.d[1]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+
	L.e & y.d[1] & _o.d[0]			-> x.d[0]-
	~x.d[0] & ~(L.e & y.d[0] & _o.d[1])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	L.d[0] & x.d[1] & y.d[1]		-> _o.d[1]-	// y.d[1]?
	~_o.d[1]				-> r1+
	r1					-> L.e-
	r1 & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(R.d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~L.d[0] & ~y.d[1]			-> _o.d[1]+
	_o.d[1] & y.d[0]			-> r1-		// y.d[0]?
//	~R.d[0] & ~r1				-> L.e+		// dupl.
	L.e & y.d[0] & _o.d[1]			-> x.d[1]-
	~x.d[1] & ~(L.e & y.d[1])		-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Same as the above, but eats first token b/c reset in different phase.  
	"One for me, one for you..."
	(Can't think of a good reason where one would use this, but it's here.)
	HSE: [[Ld];Le-;[~Ld];Le+;[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+]
	Reset: L.e is high, R.d[0] is low, R.e must be high (inactive)!
	Test: alternator-wchb_eater-03.{hac,prsimrc}
 */
defproc wchb_alternator_eater_2_slow_eatfirst(
		e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
prs {
	Reset					-> R.d[0]-
	Reset					-> r1-

	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-	// d[0]
	~_Reset					-> y.d[0]+	// d[1]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0] | r1				-> L.e-

	// reset-phase affects x
	R.d[0] & y.d[0]				-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(r1 & y.d[1])	-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+

	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> r1+

	// reset-phase affects x
	r1 & y.d[1]				-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> r1-
}
}

//-----------------------------------------------------------------------------
/**
	Serial chain of wchb_alternator_eaters, where each stage
	eats every other token.  
	a.k.a. Frequency-divider.  
	Reset: requires R.e to be high (inactive)
	Test: alternator-wchb_eater-04.{hac,prsimrc}
	\pint N number of divider stages
	\param L input channel
	\param R output channel at 1/2^N frequency
 */
template <pint N>
defproc alternator_eater_chain_slow(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_eater_2_slow e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Serial chain of wchb_alternator_eaters, where each stage
	eats every other token.  
	a.k.a. Frequency-divider.  
	This variation is faster, and lower latency.  
	Reset: doesn't care what R.e is on reset
	Test: alternator-wchb_eater-0{5,6}.{hac,prsimrc}
	\pint N number of divider stages
	\param L input channel
	\param R output channel at 1/2^N frequency
 */
template <pint N>
defproc alternator_eater_chain_fast(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_eater_2_fast e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//=============================================================================
/**
	Buffer that produces two sequential output tokens, per input token.  
	Application: on-chip token burst generation.  
	HSE: [[Re&Ld];Rd+;Le-;[~Re];Rd-;Le+;[Ld];Rd+;[~Re&~Ld];Rd-;Le+]
	Latency: L -> R (2T), when token is passed through.  
	Reset: 
	Tests:
	\param L input channel.
	\param R output channel, used twice per input token.  
 */
defproc wchb_alternator_repeater_2_lazy(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
bool _o;
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	Reset					-> R.d[0]-
	~_Reset					-> L.e+

	~_Reset					-> _o+

	// set-phase affects y
	R.e & L.d[0] & x.d[0] & y.d[0]		-> _o-
	~_o					-> R.d[0]+
	R.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(R.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R.d[0] & y.d[1]				-> L.e-

	// reset-phase affects x (don't wait for ~L.d[0])
	~L.d[0] & ~R.e & ~y.d[0] & ~x.d[1]	-> _o+
	_o & y.d[1]				-> R.d[0]-
	y.d[1] & _o				-> x.d[0]-
	~R.d[0] & ~x.d[0] & ~(L.e & y.d[0] & _o)
						-> x.d[1]+	// x-coupled

	// set-phase affects y
	R.e & x.d[1] & y.d[1] & _Reset		-> _o-
//	~_o					-> R.d[0]+	// dupl.
	R.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(R.d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R.e & ~y.d[1] & ~x.d[0]		-> _o+
	_o & y.d[0] & x.d[1]			-> R.d[0]-
	~R.d[0] & ~y.d[1]			-> L.e+	
	L.e & y.d[0] & _o			-> x.d[1]-
	~R.d[0] & ~x.d[1] & ~(_o & y.d[1])	-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Another token repeater.  
	Derived from wchb_merge_alternator_2xe1of1_fast.
	HSE: [[Re&Ld];Le-;Rd+;[~Re];Le+;Rd-;[Re];Rd+;[~Re];Rd-]
	Reset:
	Latency: L -> R (2T)
	Tests:
 */
defproc wchb_alternator_repeater_2_merge(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
bool _o[2], o[2];
_o[0] = L.e;
spec {
	excllo(_o)
}
prs {
	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+
	Reset					-> o[0]-
	Reset					-> o[1]-

	~_o[0] | ~_o[1]				-> R.d[0]+
	 _o[0] &  _o[1]				-> R.d[0]-

	// set-phase affects y
	R.e & x.d[0] & y.d[0] & _Reset		-> _o[1]-
	~_o[1]					-> o[1]+
	x.d[0] & o[1]				-> y.d[0]-
	~y.d[0] & ~(x.d[1] & o[0])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~x.d[1] & ~y.d[0]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[1]				-> o[1]-
	_o[1] & y.d[1]				-> x.d[0]-
	~o[1] & ~x.d[0] & ~(_o[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	R.e & L.d[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o[0]+
	x.d[1] & o[0]				-> y.d[1]-
	~y.d[1] & ~(x.d[0] & o[1])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R.e & ~L.d[0] & ~x.d[0] & ~y.d[1]	-> _o[0]+	// eww, 4p
	_o[0] & y.d[0]				-> o[0]-
	_o[0] & y.d[0]				-> x.d[1]-
	~o[0] & ~x.d[1] & ~(_o[1] & y.d[1])	-> x.d[0]+	// x-coupled
}
}

/**
	We default to using the merge-based implementation.  
 */
typedef	wchb_alternator_repeater_2_merge	wchb_alternator_repeater_2;

//-----------------------------------------------------------------------------
/**
	Serial chain of wchb_alternator_repeaters, where each stage
	produces two output tokens per input.  
	a.k.a. Frequency-multiplier, token burst generator.  
	Reset: doesn't care what R.e is on reset
	Test: alternator-wchb_repeater-0{5,6}.{hac,prsimrc}
	\pint N number of repeater stages
	\param L input channel
	\param R output channel
 */
template <pint N>
defproc alternator_repeater_chain_lazy(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_repeater_2_lazy e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Serial chain of wchb_alternator_repeaters, where each stage
	produces two output tokens per input.  
	Reset: doesn't care what R.e is on reset
	Test: alternator-wchb_repeater-0{7,8}.{hac,prsimrc}
	\pint N number of repeater stages
	\param L input channel
	\param R output channel
 */
template <pint N>
defproc alternator_repeater_chain_merge(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_repeater_2_merge e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

typedef	alternator_repeater_chain_merge		alternator_repeater_chain;

//=============================================================================
/**
	Splitting alternator.
	This is OBSOLETED by the faster version below.  
	Application: tree-FIFO! round-robin scheduling.  
	HSE: *[[R0e&Ld];R0d+;Le-;[~R0e&~Ld];R0d-;Le+;
		[R1e&Ld];R1d+;Le-;[~R1e&~Ld];R1d-;Le+]
	Reset: R.e's don't matter
	Test: alternator-wchb_split-0{1,2,3,4}.{hac,prsimrc}
	Forward latency: L -> R (4T+/2T-)
	\param L input channel
	\param R output channels (forwarded in alternation, starting R[0])
 */
defproc wchb_alternator_split_2_slow(e1of1 L, R[2]; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
prs {
	Reset					-> R[0].d[0]-
//	Reset					-> R[1].d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R[1].e & x.d[0] & y.d[1] & _Reset	-> _o.d[1]-
	~_o.d[1]				-> R[1].d[0]+
	R[0].d[0] | R[1].d[0]			-> L.e-

	// reset-phase affects x
	R[1].d[0] & y.d[1]			-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R[0].d[0] & y.d[0])
						-> x.d[1]+	// x-coupled
	~R[1].e & ~x.d[0] & ~y.d[0]		-> _o.d[1]+
	_o.d[1] & x.d[1]			-> R[1].d[0]-
	~R[0].d[0] & ~R[1].d[0]			-> L.e+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R[0].e & x.d[1] & y.d[0] & _Reset	-> _o.d[0]-
	~_o.d[0]				-> R[0].d[0]+

	// reset-phase affects x
	R[0].d[0] & y.d[0]			-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(R[1].d[0] & y.d[1])
						-> x.d[0]+	// x-coupled
	~R[0].e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R[0].d[0]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Splitting alternator.
	Application: tree-FIFO! round-robin scheduling.  
	HSE: *[[R0e&Ld];R0d+;Le-;[~R0e&~Ld];R0d-;Le+;
		[R1e&Ld];R1d+;Le-;[~R1e&~Ld];R1d-;Le+]
	Reset: R.e's don't matter, L.d should be low
	Test: alternator-wchb_split-0{7,8}.{hac,prsimrc}
	Forward latency: L -> R (2T)
	\param L input channel
	\param R output channels (forwarded in alternation, starting R[0])
 */
defproc wchb_alternator_split_2_fast(e1of1 L, R[2]; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
prs {
	Reset					-> R[0].d[0]-
	Reset					-> R[1].d[0]-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// NOTE: production rules are symmetric
	// set-phase affects y
	R[1].e & L.d[0] & x.d[0] & y.d[0]	-> _o.d[1]-
	~_o.d[1]				-> R[1].d[0]+
	R[1].d[0]				-> L.e-
	R[1].d[0] & x.d[0]			-> y.d[0]-
	~y.d[0] & ~(R[0].d[0] & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R[1].e & ~L.d[0]			-> _o.d[1]+	// ~y.d[0]?
	_o.d[1] & y.d[1]			-> R[1].d[0]-
	~R[0].d[0] & ~R[1].d[0]			-> L.e+
	_o.d[1] & y.d[1]			-> x.d[0]-
	~R[1].d[0] & ~x.d[0] & ~(_o.d[0] & y.d[0])
						-> x.d[1]+	// x-coupled

	// set-phase affects y
	R[0].e & L.d[0] & x.d[1] & y.d[1]	-> _o.d[0]-
	~_o.d[0]				-> R[0].d[0]+
	R[0].d[0]				-> L.e-
	R[0].d[0] & x.d[1]			-> y.d[1]-
	~y.d[1] & ~(R[1].d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R[0].e & ~L.d[0]			-> _o.d[0]+	// ~y.d[1]?
	_o.d[0] & y.d[0]			-> R[0].d[0]-
//	~R[0].d[0] & ~R[1].d[0]			-> L.e+		// dupl.
	_o.d[0] & y.d[0]			-> x.d[1]-
	~R[0].d[0] & ~x.d[1] & ~(_o.d[1] & y.d[1])
						-> x.d[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	Depth K alternating splitter.  
	Splits to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: R.e's don't matter
	Test: alternator-wchb_split-0{5,6}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_split_2_tree_slow(
		e1of1 L, R[1<<K]; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = L;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_split_2_slow S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k][l], M[k+1][2*l..2*l+1], _Reset, Reset);
)
)
R = M[K];	// connect outputs
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Depth K alternating splitter, low latency version.  
	Splits to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Forward latency: 2T per stage, so 2K
	Reset: R.e's don't matter
	Test: alternator-wchb_split-{09,10}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_split_2_tree_fast(
		e1of1 L, R[1<<K]; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = L;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_split_2_fast S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k][l], M[k+1][2*l..2*l+1], _Reset, Reset);
)
)
R = M[K];	// connect outputs
}

//=============================================================================
/**
	This is OBSOLETE, use the 2xe1of1_fast version instead.  
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	This definition is based on alternator_lock_1of2_slow.
	Reset: expects input data low, ...
	Test: alternator-wchb_merge-0{1,2}.{hac,prsimrc}
	Forward latency: L -> R (6T, sucks)
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc wchb_alternator_merge_2x1of1_slow(
		a1of1 L[2];
		e1of1 R;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];	// are these excl?
bool _r;
prs {
	Reset					-> L[1].a-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[1]+
	~_Reset					-> _o[0]+

	// set-phase affects y
	L[1].d[0] & x.d[0]			-> y.d[0]-
	~y.d[0] & ~(L[0].d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R.e & x.d[0] & y.d[1]			-> _o[1]-
	~_o[1]					-> L[1].a+
	L[0].a & L[1].a				-> _r-
	~_r					-> R.d[0]+

	// reset-phase affects x
	L[1].a & y.d[1]				-> x.d[0]-
	~L[1].d[0] & ~x.d[0] & ~(L[0].a & y.d[0])
						-> x.d[1]+	// x-coupled
	~R.e & ~x.d[0] & ~y.d[0]		-> _o[0]+
	_o[0] & x.d[1]				-> L[0].a-
	~L[0].a | ~L[1].a			-> _r+
	_r					-> R.d[0]-

	// set-phase affects y
	L[0].d[0] & x.d[1]			-> y.d[1]-
	~y.d[1] & ~(L[1].d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0]			-> _o[0]-
	~_o[0]					-> L[0].a+

	// reset-phase affects x
	L[0].a & y.d[0]				-> x.d[1]-
	~L[0].d[0] & ~x.d[1] & ~(L[1].a & y.d[1])
						-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o[1]+
	_o[1] & x.d[0]				-> L[1].a-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	This merges tokens from two input in alternating sequence.  
	Based on alternator_bucket_passive_fast, with trivial modification.
	This starts by passing L[0] through first.  
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	Reset: expect L.d data low on reset, and R.e doesn't matter.
	Test: alternator-wchb_merge-0{4,5}.{hac,prsimrc}
	Forward latency: L -> R (2T)
 */
defproc wchb_alternator_merge_2xe1of1_fast(
		e1of1 L[2];
		e1of1 R;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2], o[2];
bool i[2];
i[0] = L[0].d[0];
i[1] = L[1].d[0];
_o[0] = L[0].e;
_o[1] = L[1].e;
spec {
	excllo(L[0].e, L[1].e)
	excllo(_o)
	exclhi(o)
}
prs {

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+
	Reset					-> o[0]-
	Reset					-> o[1]-

	~_o[0] | ~_o[1]				-> R.d[0]+
	 _o[0] &  _o[1]				-> R.d[0]-

	// set-phase affects y
	R.e & i[1] & x.d[0] & y.d[0]		-> _o[1]-
	~_o[1]					-> o[1]+
	x.d[0] & o[1]				-> y.d[0]-
	~y.d[0] & ~(x.d[1] & o[0])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~i[1] & ~x.d[1] & ~y.d[0]	-> _o[1]+	// eww, 3p
	_o[1] & y.d[1]				-> o[1]-
	_o[1] & y.d[1]				-> x.d[0]-
	~o[1] & ~x.d[0] & ~(_o[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	R.e & i[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o[0]+
	x.d[1] & o[0]				-> y.d[1]-
	~y.d[1] & ~(x.d[0] & o[1])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R.e & ~i[0] & ~x.d[0] & ~y.d[1]	-> _o[0]+	// eww, 3p
	_o[0] & y.d[0]				-> o[0]-
	_o[0] & y.d[0]				-> x.d[1]-
	~o[0] & ~x.d[1] & ~(_o[1] & y.d[1])	-> x.d[0]+	// x-coupled

}
}

//-----------------------------------------------------------------------------
/**
	Wrapper to use e1of1 interfaces.  
 */
defproc wchb_alternator_merge_2xe1of1_slow(
		e1of1 L[2], R;
		bool _Reset, Reset) {
a1of1 ll[2];
(;i:2:	L[i].d = ll[i].d;	)
wchb_alternator_merge_2x1of1_slow M(ll, R, _Reset, Reset);
prs {
(:i:2:
	ll[i].a					=> L[i].e-
)
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Wrapper to use a1of1 interfaces.  
 */
defproc wchb_alternator_merge_2xa1of1_slow(
		a1of1 L[2], R;
		bool _Reset, Reset) {
e1of1 rr;
R.d = rr.d;
wchb_alternator_merge_2x1of1_slow M(L, rr, _Reset, Reset);
prs {
	R.a					=> rr.e-
}
}

//-----------------------------------------------------------------------------
/**
	Depth K alternating merger.  
	Merges to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: R.e needs to be high (inactive)
	Test: alternator-wchb_merge-03.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_merge_2_tree_slow(
		e1of1 L[1<<K], R; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = R;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_merge_2xe1of1_slow S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k+1][2*l..2*l+1], M[k][l], _Reset, Reset);
)
)
L = M[K];	// connect inputs
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Depth K alternating merger.  
	Merges to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: expects L.d data low,  R.e can be any.
	Test: alternator-wchb_merge-0{6,7}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_merge_2_tree_fast(
		e1of1 L[1<<K], R; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = R;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_merge_2xe1of1_fast S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k+1][2*l..2*l+1], M[k][l], _Reset, Reset);
)
)
L = M[K];	// connect inputs
}

//-----------------------------------------------------------------------------
/**
	This is here for amusement, turning a split-alternator
	into a merge-alternator in a messed-up way.  
	Don't use this for anything.  
	\param inc active-high increment request (or active-low ack)
	\param o the 1of2 output.
defproc wchb_alternator_merge_2(a1of1 L[2], R;
		bool _Reset, Reset) {
e1of1 SL, SR[2];
SL.e = R.d[0];
SL.d[0] = R.a;
L[0].d[0] = SR[0].e;
L[0].a = SR[0].d[0];
L[1].d[0] = SR[1].e;
L[1].a = SR[1].d[0];
wchb_alternator_split_2_slow S(SL, SR, _Reset, Reset);
}
 */

//-----------------------------------------------------------------------------
/**
	Tree FIFO.  
	OBSOLETE.  
	Really slow-ass forward latency.  
	Functional, but don't use this.  
	Test: alternator-wchb_tree_fifo-01.{hac,prsimrc}
 */
template <pint K>
defproc wchb_tree_fifo_e1of1_slow(e1of1 L, R; bool _Reset, Reset) {
e1of1 I[1<<K];
wchb_alternator_split_2_tree_slow<K> S(L, I, _Reset, Reset);
wchb_alternator_merge_2_tree_slow<K> M(I, R, _Reset, Reset);
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Tree FIFO.  
	Reset: expect L.d data low, R.e can be any
	Cycle time: 14 T with slow non-CMOS source, 
		10 T with fast CMOS sources.  
	Forward latency: L -> R (2K split + 2K merge = 4K T) (fast!)
	Test: alternator-wchb_tree_fifo-0{2,3,4}.{hac,prsimrc}
 */
template <pint K>
defproc wchb_tree_fifo_e1of1_fast(e1of1 L, R; bool _Reset, Reset) {
e1of1 I[1<<K];
wchb_alternator_split_2_tree_fast<K> S(L, I, _Reset, Reset);
wchb_alternator_merge_2_tree_fast<K> M(I, R, _Reset, Reset);
}

//-----------------------------------------------------------------------------

