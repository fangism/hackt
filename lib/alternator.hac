/**
	\file "alternator.hac"
	vi: ft=cpp
	Library for alternator structures and ring-counted structures.
	Everything defined in here is CMOS-implementable and may be
	used to synthesize netlists of environment sources.  
	2-way alternators use a dual-rail bit as a state variable whereas
	N-way alternators will use some sort of one-hot counter.  
	Splits and merges useful for constructing tree-fifos.  
	$Id: alternator.hac,v 1.7 2006/09/15 10:30:26 fang Exp $
 */

import "channel.hac";
	// for c1of<N>

//=============================================================================
/**
	Single slice of a one-hot incrementer.  
	To use this stage, you have ot take the conjunction of
	two adjacent stages s[i-1] & s[i] to form a one-hot code.  
	This basic cell is written this way to allow for general uses
	of the state bits.  
	\param inc the increment/advance signal, 
		may be considered an active low acknowledge 
		or active high request into the cell.  
	\param _si state-bit from i-2 stage.
	\param sj state-bit from i-1 stage.
	\param _sk this state-bit.
	\param sk this state-bit.
	\param _sl state-bit from i+1 stage.
	\param _Reset reset this state-bit to inactive.
 */
defproc onehot_stage(
		bool inc, 
		_si, sj, _sk, sk, _sl, 
		_Reset) {
	prs {
		// unfortunately need _Reset
		_Reset & inc & sj & _si			-> _sk-
		~_sk					-> sk+
		~inc & ~_sl				-> _sk+	// no ~sj
		_sk					-> sk-
		~_Reset					-> _sk+
	}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Variant of onehot_stage that initializes with the token.  
	Same parameters.  
	\param Reset resets the state-bit to active.  
 */
defproc onehot_stage_init(
		bool inc, 
		_si, sj, _sk, sk, _sl, 
		Reset) {
	prs {
		inc & sj & _si				-> _sk-
		~_sk					-> sk+
		~inc & ~_sl				-> _sk+ // no ~sj
		_sk					-> sk-
		Reset					-> _sk-
	}
}

//-----------------------------------------------------------------------------
/**
	Half of an alternator, symmetric.
	This acts as one side of a toggle counter.  
	This is OBSOLETED by the superior variation, below.  
	\param inc the request to advance or toggle
	\param x, y dual-rail state variables
	\param _o1 local inverted output rail
	\param o output rails
 */
defproc symmetric_alternator_stage(
		bool inc,
		x[2], y[2],
		_o1, o[2],
		_Reset) {
prs {
	~_Reset					-> _o1+
	// set-phase affects y
	inc & x[0]				-> y[0]-
	~y[0] & ~(inc & x[1])			-> y[1]+	// x-coupled
	x[0] & y[1] & _Reset			-> _o1-
	~_o1					-> o[1]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled
	~x[0] & ~y[0]				-> _o1+
	_o1 & x[1]				-> o[1]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Half of an alternator, 2-way symmetric.  
	Faster, smaller, and lower latency than the other version.  
	Latency: inc => o+ (2T)
	\param inc the request to advance or toggle
	\param x, y dual-rail state variables
	\param _o1 local inverted output rail
	\param o output rails
 */
defproc symmetric_alternator_stage_fast(
		bool inc,
		x[2], y[2],
		o[2],
		_Reset) {
bool _o;
prs {
	~_Reset					-> _o+

	// set-phase affects y
	inc & x[0]				-> y[0]-
	inc & x[0] & _Reset			-> _o-
	~y[0] & ~(inc & x[1])			-> y[1]+	// x-coupled
	~_o					-> o[0]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc					-> _o+
	~inc & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled
	_o					-> o[0]-
}
}

//-----------------------------------------------------------------------------
/**
	Size-2 one-hot counter (special case)
	Reset: outputs data rails low, doesn't care about inc signal.
	Test: "alternator-1of2-0{1,2}.{hac,prsimrc}"
	HSE: *[[inc];O.0+;[~inc];O.0-;[inc];O.1+;[~inc];O.1-]
	\param inc active-high increment request (or active-low ack)
	\param o the 1of2 output.
 */
defproc alternator_source_1of2_slow(
		bool inc;
		c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
_c1of2 _o;
symmetric_alternator_stage s[2];
	s[0](inc, x.d, y.d, _o.d[1], o.d, _Reset);
	s[1](inc, {x.d[1], x.d[0]}, {y.d[1], y.d[0]}, _o.d[0],
		{o.d[1], o.d[0]}, _Reset);
prs {
	Reset					-> o.d[0]-
//	Reset					-> o.d[1]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

/**
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// set-phase affects y
	inc & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(inc & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> o.d[1]+

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> o.d[1]-

	// set-phase affects y
	inc & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(inc & x.d[0])		-> y.d[0]+	// x-coupled
	x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> o.d[0]+

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
	~x.d[1] & ~y.d[1]			-> _o.d[0]+
	_o.d[0] & x.d[0]			-> o.d[0]-
**/
}
}

//-----------------------------------------------------------------------------
/**
	Source that alternates between two values.  
	Smaller, faster, lower latency, simply superior.  
	Latency: inc -> o+ (2T), ~inc -> o- (2T)
	Reset: inc may be either high or low on reset, doesn't matter.
	Initial: first rail raised will be o.d[0].
	\param inc the increment input signal.
	\param o the dual-rail output.  
 */
defproc alternator_source_1of2_fast(
		bool inc;
		c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
// _c1of2 _o;
symmetric_alternator_stage_fast s[2];
	s[0](inc, x.d, y.d, o.d, _Reset);
	s[1](inc, {x.d[1], x.d[0]}, {y.d[1], y.d[0]}, 
		{o.d[1], o.d[0]}, _Reset);
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  
/**
	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	inc & x.d[0] & _Reset			-> y.d[0]-
	inc & x.d[0] & _Reset			-> _o.d[0]-
	~_o.d[0]				-> o.d[0]+
	~y.d[0] & ~(inc & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc					-> _o.d[0]+
	_o.d[0]					-> o.d[0]-
	~inc & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	inc & x.d[1] & _Reset			-> _o.d[1]-
	inc & x.d[1] & _Reset			-> y.d[1]-
	~_o.d[1]				-> o.d[1]+
	~y.d[1] & ~(inc & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc					-> _o.d[1]+
	_o.d[1]					-> o.d[1]-
	~inc & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
**/
}
}

// typedef	alternator_source_1of2_slow	alternator_source_1of2;
typedef	alternator_source_1of2_fast	alternator_source_1of2;

//-----------------------------------------------------------------------------
/**
	Half of a symmetric lock implementation.  
	Used in definition of alternator_lock_1of2.
 */
defproc alternator_half_lock_slow(
		bool inc[2], x[2], y[2], _o[2], o[2], _Reset) {
prs {

	~_Reset					-> _o[1]+
	// set-phase affects y
	inc[1] & x[0]				-> y[0]-
	~y[0] & ~(inc[0] & x[1])		-> y[1]+	// x-coupled
	x[0] & y[1] & _Reset			-> _o[1]-
	~_o[1]					-> o[1]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc[1] & ~x[0] & ~(o[0] & y[0])	-> x[1]+	// x-coupled
	~x[0] & ~y[0]				-> _o[0]+
	_o[0] & x[1]				-> o[0]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Half of a symmetric lock implementation.  
	Lower latency version.  
	Latency: inc -> o+ (2T)
	Used in definition of alternator_lock_1of2.
 */
defproc alternator_half_lock_fast(
		bool i[2], x[2], y[2], o[2], _Reset) {
bool _o;
prs {
	~_Reset					-> _o+

	// reset-phase affects x
	~x[1] & ~i[1] & ~y[0]			-> _o+		// eww, 3p
	_o & y[1]				-> o[0]-
	o[1] & y[1]				-> x[0]-
	~o[0] & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled

	// set-phase affects y
	i[0] & x[1] & y[1]			-> _o-
	~_o					-> o[0]+
	o[0] & x[1]				-> y[1]-
	~y[1] & ~(o[1] & x[0])			-> y[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	Reset: inputs low, this will hold _o high on reset.
	Test: alternator-lock-01.{hac,prsimrc}
	TODO: consider lower latency reshuffling.
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc alternator_lock_1of2_slow(
		bool inc[2];
		_c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];
alternator_half_lock_slow s[2];
	s[0](inc, x.d, y.d, _o, o.d, _Reset);
	s[1]({inc[1], inc[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		{_o[1], _o[0]}, {o.d[1], o.d[0]}, _Reset);
prs {
	~_Reset					-> o.d[1]+
//	Reset					-> o.d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

/***
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[1]+
	~_Reset					-> _o[0]+
	// set-phase affects y
	inc[1] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(inc[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o[1]-
	~_o[1]					-> o.d[1]+

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc[1] & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o[0]+
	_o[0] & x.d[1]				-> o.d[0]-

	// set-phase affects y
	inc[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(inc[1] & x.d[0])		-> y.d[0]+	// x-coupled
	x.d[1] & y.d[0] & _Reset		-> _o[0]-
	~_o[0]					-> o.d[0]+

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc[0] & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
	~x.d[1] & ~y.d[1]			-> _o[1]+
	_o[1] & x.d[0]				-> o.d[1]-
***/
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	Reset: inputs low, this will hold _o high on reset.
	Test: alternator-lock-02.{hac,prsimrc}
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc alternator_lock_1of2_fast(
		bool inc[2];
		_c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
// bool _o[2];
alternator_half_lock_fast s[2];
	s[0](inc, x.d, y.d, o.d, _Reset);
	s[1]({inc[1], inc[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		{o.d[1], o.d[0]}, _Reset);
spec {
	exclhi(inc)
}
prs {

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+
	Reset					-> o.d[0]-
	~_Reset					-> o.d[1]+
/**
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+

	// set-phase affects y
	inc[1] & x.d[0] & y.d[0]		-> _o[1]-
	~_o[1]					-> o.d[1]+
	o.d[1] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(o.d[0] & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~x.d[1] & ~inc[1] & ~y.d[0]		-> _o[0]+	// eww, 3p
	_o[0] & y.d[1]				-> o.d[0]-
	o.d[1] & y.d[1]				-> x.d[0]-
	~o.d[0] & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	inc[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o.d[0]+
	o.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(o.d[1] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~x.d[0] & ~inc[0] & ~y.d[1]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[0]				-> o.d[1]-
	o.d[0] & y.d[0]				-> x.d[1]-
	~o.d[1] & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
**/
}
}

typedef	alternator_lock_1of2_fast	alternator_lock_1of2;

//-----------------------------------------------------------------------------
/**
	Weak-condition onehot counter, cycles through 1ofN rails.  
	Example of use of onehot_stages to form a counter.  
	reset: inc may be either active or inactive on reset.  
	HSE: *[[inc];O.0+;[~inc];O.0-;[inc];O.1+;[~inc];O.1-;...]
	Tested: test/lib/alternator-onehot_counter-01.
	Tested: test/lib/alternator-onehot_counter-02.
	Metrics: inc to out latency is 4 transitions.  
	\param N the number of values to cycle through (> 0).  
	\param inc is effectively an active-low output acknowledge or 
		active-high input request.  
 */
template <pint N>
defproc	onehot_counter(
		bool inc;		// can be .e of e1ofN channel
		c1of<N> o;		// for exclhi
		bool _Reset, Reset) {
	// bool Reset;	// locally generated
[(N > 2) ->
	bool _s[N], s[N], _o[N];
	onehot_stage_init i0(inc, _s[N-2], s[N-1], _s[0], s[0], _s[1], Reset);
	onehot_stage i[1..N-1];
	(;j:1..N-1:
		i[j](inc, _s[(N+j-2)%N], s[j-1],
			_s[j], s[j], _s[(j+1)%N], _Reset);
	)
[] N == 2 ->
	// special case alternator
	alternator_source_1of2 a(inc, o, _Reset, Reset);
[] N == 1 ->
	bool _r;
]
prs {
[(N > 2) ->
	// ring of AND-gates to generate one-hot signal
	// _Reset				=> Reset-
	(:j:N:
		s[j] & s[(j+1)%N]		=> _o[j]-
		_o[j]				=> o.d[j]-
	)
	// TODO: rewrite as trailing else clause
[] else ->
	[ N == 1 ->
		// extremely fast source
		~_Reset					-> _r+
		~inc					-> _r+
		inc & _Reset				-> _r-
		_r					=> o.d[0]-
	]
]
}
}

typedef	onehot_counter<1>		onehot_counter1;
typedef	alternator_source_1of2		onehot_counter2;
typedef	onehot_counter<3>		onehot_counter3;
typedef	onehot_counter<4>		onehot_counter4;
typedef	onehot_counter<5>		onehot_counter5;
typedef	onehot_counter<6>		onehot_counter6;
typedef	onehot_counter<7>		onehot_counter7;
typedef	onehot_counter<8>		onehot_counter8;

//-----------------------------------------------------------------------------
// TODO: onehot_lock
// passes one value though at a time in round-robin fashion.
// in the fashion of alternator_lock_1of2

//-----------------------------------------------------------------------------
/**
	Buffer that eats every other token.  
	"One for you, one for me..."
	Application: forms frequency divider when cascaded serially.
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Other rehufflings may be possible.

	Reset: L.e is high, R.d[0] is low, don't care about R.e
	Tests: alternator-wchb_eater-0{1,2}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
defproc wchb_alternator_eater_2_slow(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
prs {
	Reset					-> R.d[0]-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0] | r1				-> L.e-

	// reset-phase affects x
	R.d[0] & y.d[0]				-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(r1 & y.d[1])	-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+

	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> r1+

	// reset-phase affects x
	r1 & y.d[1]				-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> r1-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Buffer that eats every other token.  
	"One for you, one for me..."
	Application: forms frequency divider when cascaded serially.
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Other rehufflings may be possible.
	Latency: 
	Reset: 
	Tests: alternator-wchb_eater-0{1,2}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
defproc wchb_alternator_eater_2_fast(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
spec {
	exclhi(R.d[0], r1)
}
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	Reset					-> R.d[0]-

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	R.e & L.d[0] & x.d[0] & y.d[0]		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0]					-> L.e-
	R.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(r1 & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~L.d[0] & ~y.d[0]		-> _o.d[0]+
	_o.d[0] & y.d[1]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+
	L.e & y.d[1] & _o.d[0]			-> x.d[0]-
	~x.d[0] & ~(L.e & y.d[0] & _o.d[1])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	L.d[0] & x.d[1] & y.d[1]		-> _o.d[1]-	// y.d[1]?
	~_o.d[1]				-> r1+
	r1					-> L.e-
	r1 & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(R.d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~L.d[0] & ~y.d[1]			-> _o.d[1]+
	_o.d[1] & y.d[0]			-> r1-		// y.d[0]?
//	~R.d[0] & ~r1				-> L.e+		// dupl.
	L.e & y.d[0] & _o.d[1]			-> x.d[1]-
	~x.d[1] & ~(L.e & y.d[1])		-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Same as the above, but eats first token b/c reset in different phase.  
	"One for me, one for you..."
	(Can't think of a good reason where one would use this, but it's here.)
	HSE: [[Ld];Le-;[~Ld];Le+;[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+]
	Reset: L.e is high, R.d[0] is low, R.e must be high (inactive)!
	Test: alternator-wchb_eater-03.{hac,prsimrc}
 */
defproc wchb_alternator_eater_2_slow_eatfirst(
		e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
prs {
	Reset					-> R.d[0]-
	Reset					-> r1-

	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-	// d[0]
	~_Reset					-> y.d[0]+	// d[1]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0] | r1				-> L.e-

	// reset-phase affects x
	R.d[0] & y.d[0]				-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(r1 & y.d[1])	-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+

	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> r1+

	// reset-phase affects x
	r1 & y.d[1]				-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> r1-
}
}

//-----------------------------------------------------------------------------
/**
	Serial chain of wchb_alternator_eaters, where each stage
	eats every other token.  
	a.k.a. Frequency-divider.  
	Reset: requires R.e to be high (inactive)
	Test: alternator-wchb_eater-04.{hac,prsimrc}
	\pint N number of divider stages
	\param L input channel
	\param R output channel at 1/2^N frequency
 */
template <pint N>
defproc alternator_eater_chain_slow(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_eater_2_slow e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Serial chain of wchb_alternator_eaters, where each stage
	eats every other token.  
	a.k.a. Frequency-divider.  
	This variation is faster, and lower latency.  
	Reset: doesn't care what R.e is on reset
	Test: alternator-wchb_eater-0{5,6}.{hac,prsimrc}
	\pint N number of divider stages
	\param L input channel
	\param R output channel at 1/2^N frequency
 */
template <pint N>
defproc alternator_eater_chain_fast(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_eater_2_fast e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//=============================================================================
/**
	Splitting alternator.
	Application: tree-FIFO! round-robin scheduling.  
	HSE: *[[R0e&Ld];R0d+;Le-;[~R0e&~Ld];R0d-;Le+;
		[R1e&Ld];R1d+;Le-;[~R1e&~Ld];R1d-;Le+]
	Reset: R.e's don't matter
	Test: alternator-wchb_split-0{1,2,3,4}.{hac,prsimrc}
	TODO: possible lower latency reshufflings?, move L.d check later.
	\param L input channel
	\param R output channels (forwarded in alternation, starting R[0])
 */
defproc wchb_alternator_split_2(e1of1 L, R[2]; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
prs {
	Reset					-> R[0].d[0]-
//	Reset					-> R[1].d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R[1].e & x.d[0] & y.d[1] & _Reset	-> _o.d[1]-
	~_o.d[1]				-> R[1].d[0]+
	R[0].d[0] | R[1].d[0]			-> L.e-

	// reset-phase affects x
	R[1].d[0] & y.d[1]			-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R[0].d[0] & y.d[0])
						-> x.d[1]+	// x-coupled
	~R[1].e & ~x.d[0] & ~y.d[0]		-> _o.d[1]+
	_o.d[1] & x.d[1]			-> R[1].d[0]-
	~R[0].d[0] & ~R[1].d[0]			-> L.e+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R[0].e & x.d[1] & y.d[0] & _Reset	-> _o.d[0]-
	~_o.d[0]				-> R[0].d[0]+

	// reset-phase affects x
	R[0].d[0] & y.d[0]			-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(R[1].d[0] & y.d[1])
						-> x.d[0]+	// x-coupled
	~R[0].e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R[0].d[0]-
}
}

//-----------------------------------------------------------------------------
/**
	Depth K alternating splitter.  
	Splits to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: R.e's don't matter
	Test: alternator-wchb_split-0{5,6}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_split_2_tree(e1of1 L, R[1<<K]; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = L;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_split_2 S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k][l], M[k+1][2*l..2*l+1], _Reset, Reset);
)
)
R = M[K];	// connect outputs
}

//=============================================================================
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can psss through consecutive times.  
	Reset: inputs low
	Test: alternator-wchb_merge-0{1,2}.{hac,prsimrc}
	TODO: lower latency version, this one sucks: 6T
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc wchb_alternator_merge_2x1of1(
		a1of1 L[2];
		e1of1 R;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];	// are these excl?
bool _r;
prs {
	~_Reset					-> L[1].a+
//	Reset					-> o.d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[1]+
	~_Reset					-> _o[0]+

	// set-phase affects y
	L[1].d[0] & x.d[0]			-> y.d[0]-
	~y.d[0] & ~(L[0].d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R.e & x.d[0] & y.d[1] & _Reset		-> _o[1]-
	~_o[1]					-> L[1].a+
	L[0].a & L[1].a				-> _r-
	~_r					-> R.d[0]+

	// reset-phase affects x
	L[1].a & y.d[1]				-> x.d[0]-
	~L[1].d[0] & ~x.d[0] & ~(L[0].a & y.d[0])
						-> x.d[1]+	// x-coupled
	~R.e & ~x.d[0] & ~y.d[0]		-> _o[0]+
	_o[0] & x.d[1]				-> L[0].a-
	~L[0].a | ~L[1].a			-> _r+
	_r					-> R.d[0]-

	// set-phase affects y
	L[0].d[0] & x.d[1]			-> y.d[1]-
	~y.d[1] & ~(L[1].d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o[0]-
	~_o[0]					-> L[0].a+

	// reset-phase affects x
	L[0].a & y.d[0]				-> x.d[1]-
	~L[0].d[0] & ~x.d[1] & ~(L[1].a & y.d[1])
						-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o[1]+
	_o[1] & x.d[0]				-> L[1].a-

}
}

//-----------------------------------------------------------------------------
/**
	Wrapper to use e1of1 interfaces.  
 */
defproc wchb_alternator_merge_2xe1of1(
		e1of1 L[2], R;
		bool _Reset, Reset) {
a1of1 ll[2];
(;i:2:	L[i].d = ll[i].d;	)
wchb_alternator_merge_2x1of1 M(ll, R, _Reset, Reset);
prs {
(:i:2:
	ll[i].a					=> L[i].e-
)
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Wrapper to use a1of1 interfaces.  
 */
defproc wchb_alternator_merge_2xa1of1(
		a1of1 L[2], R;
		bool _Reset, Reset) {
e1of1 rr;
R.d = rr.d;
wchb_alternator_merge_2x1of1 M(L, rr, _Reset, Reset);
prs {
	R.a					=> rr.e-
}
}

//-----------------------------------------------------------------------------
/**
	Depth K alternating merger.  
	Merges to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: R.e needs to be high (inactive)
	Test: alternator-wchb_merge-0{...}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_merge_2_tree(e1of1 L[1<<K], R; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = R;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_merge_2xe1of1 S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k+1][2*l..2*l+1], M[k][l], _Reset, Reset);
)
)
L = M[K];	// connect outputs
}

//-----------------------------------------------------------------------------
/**
	This is here for amusement, turning a split-alternator
	into a merge-alternator in a messed-up way.  
	Don't use this for anything.  
	\param inc active-high increment request (or active-low ack)
	\param o the 1of2 output.
defproc wchb_alternator_merge_2(a1of1 L[2], R;
		bool _Reset, Reset) {
e1of1 SL, SR[2];
SL.e = R.d[0];
SL.d[0] = R.a;
L[0].d[0] = SR[0].e;
L[0].a = SR[0].d[0];
L[1].d[0] = SR[1].e;
L[1].a = SR[1].d[0];
wchb_alternator_split_2 S(SL, SR, _Reset, Reset);
}
 */

//-----------------------------------------------------------------------------
/**
	Tree FIFO.  
	Test: untested
 */
template <pint K>
defproc wchb_tree_fifo_e1of1(e1of1 L, R; bool _Reset, Reset) {
e1of1 I[1<<K];
wchb_alternator_split_2_tree<K> S(L, I, _Reset, Reset);
wchb_alternator_merge_2_tree<K> M(I, R, _Reset, Reset);
}

//-----------------------------------------------------------------------------

