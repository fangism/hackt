/**
	\file "alternator.hac"
	Library for alternator structures and ring-counted structures.
	Everything defined in here is CMOS-implementable and may be
	used to synthesize netlists of environment sources.  
	2-way alternators use a dual-rail bit as a state variable whereas
	N-way alternators will use some sort of one-hot counter.  
	Splits and merges useful for constructing tree-fifos.  

	TODO: e1ofN alterators.
	TODO: annotate ports with directions

	$Id: alternator.hac,v 1.19 2011/02/25 23:19:25 fang Exp $
 */

import "channel.hac";
	// for c1of<N>

//=============================================================================
/**
	Single slice of a one-hot incrementer.  
	To use this stage, you have ot take the conjunction of
	two adjacent stages s[i-1] & s[i] to form a one-hot code.  
	This basic cell is written this way to allow for general uses
	of the state bits.  
	\param incs the increment/advance signal, 
		may be considered an active low acknowledge 
		or active high request into the cell.  
	\param incr is for resetting this element.
	\param _si state-bit from i-2 stage.
	\param sj state-bit from i-1 stage.
	\param _sk this state-bit.
	\param sk this state-bit.
	\param _sl state-bit from i+1 stage.
	\param _Reset reset this state-bit to inactive.
 */
defproc onehot_stage(
		bool inc,
		_si, sj, _sk, sk, _sl, 
		_Reset) {
	prs {
		// unfortunately need _Reset
		_Reset & inc & sj & _si			-> _sk-
		~_sk					-> sk+
		~inc & ~_sl				-> _sk+	// no ~sj
		_sk					-> sk-
		~_Reset					-> _sk+
	}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Variant of onehot_stage that initializes with the token.  
	Same parameters.  
	\param Reset resets the state-bit to active.  
 */
defproc onehot_stage_init(
		bool inc,
		_si, sj, _sk, sk, _sl, 
		Reset) {
	prs {
		inc & sj & _si				-> _sk-
		~_sk					-> sk+
		~inc & ~_sl				-> _sk+ // no ~sj
		_sk					-> sk-
		Reset					-> _sk-
	}
}

//-----------------------------------------------------------------------------
/**
	Same parameters as onehot_stage, with the additional:
	\param incr separate reset neg-ack.
	\param incsp additional guard to wait for previous 
		element to be completely finished before proceeding.  
 */
defproc onehot_seq_element(
		bool incs, incsp, incr,
		_si, sj, _sk, sk, _sl, 
		_Reset) {
	prs {
		// unfortunately need _Reset
		_Reset & incs & incsp & sj & _si	-> _sk-
		~_sk					-> sk+
		~incr & ~_sl				-> _sk+	// no ~sj
		_sk					-> sk-
		~_Reset					-> _sk+
	}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Variant of onehot_stage that initializes with the token.  
	Same parameters.  
	\param Reset resets the state-bit to active.  
 */
defproc onehot_seq_element_init(
		bool incs, incsp, incr,
		_si, sj, _sk, sk, _sl, 
		Reset) {
	prs {
		incsp & incs & sj & _si			-> _sk-
		~_sk					-> sk+
		~incr & ~_sl				-> _sk+ // no ~sj
		_sk					-> sk-
		Reset					-> _sk-
	}
}

//-----------------------------------------------------------------------------
/**
	Half of an alternator, symmetric.
	This acts as one side of a toggle counter.  
	This is OBSOLETED by the superior variation, below.  
	\param inc the request to advance or toggle
	\param x, y dual-rail state variables
	\param _o1 local inverted output rail
	\param o output rails
 */
defproc symmetric_alternator_stage(
		bool inc,
		x[2], y[2],
		_o1, o[2],
		_Reset) {
prs {
	~_Reset					-> _o1+
	// set-phase affects y
	inc & x[0]				-> y[0]-
	~y[0] & ~(inc & x[1])			-> y[1]+	// x-coupled
	x[0] & y[1] & _Reset			-> _o1-
	~_o1					-> o[1]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled
	~x[0] & ~y[0]				-> _o1+
	_o1 & x[1]				-> o[1]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Half of an alternator, 2-way symmetric.  
	Faster, smaller, and lower latency than the other version.  
	Latency: inc => o+ (2T)
	\param inc the request to advance or toggle
	\param x dual-rail state variable
	\param _o inverted output rails
	\param o output rails
 */
defproc symmetric_alternator_stage_fast(
		bool inc,
		x[2], _o[2], o[2],
		_Reset) {
prs {
	~_Reset					-> _o[0]+

	// using cross-locking mutual exclusion
	inc & x[0] & _o[1] & _Reset		-> _o[0]-
	~_o[0]					-> o[0]+
	// flip x to set up for next iteration
	o[0]					-> x[0]-
	~x[0] & ~(o[1])				-> x[1]+	// x-coupled

	// reset phase is decoupled from everything else
	// would like to guard _o- with x[1], but would be non-CMOS...
	~inc 					-> _o[0]+
	_o[0] & x[1]				-> o[0]-
}
}

//-----------------------------------------------------------------------------
/**
	OBSOLETE.
	Size-2 one-hot counter (special case)
	Reset: outputs data rails low, doesn't care about inc signal, 
		requires inc to be HIGH on reset!
	Test: "alternator-1of2-0{1,2}.{hac,prsimrc}"
	HSE: *[[inc];O.0+;[~inc];O.0-;[inc];O.1+;[~inc];O.1-]
	\param inc active-high increment request (or active-low ack)
	\param o the 1of2 output.
 */
defproc alternator_source_1of2_slow(
		bool inc;
		c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
_c1of2 _o;
symmetric_alternator_stage s[2];
	s[0](inc, x.d, y.d, _o.d[1], o.d, _Reset);
	s[1](inc, {x.d[1], x.d[0]}, {y.d[1], y.d[0]}, _o.d[0],
		{o.d[1], o.d[0]}, _Reset);
prs {
	Reset					-> o.d[0]-
//	Reset					-> o.d[1]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

/**
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// set-phase affects y
	inc & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(inc & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> o.d[1]+

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> o.d[1]-

	// set-phase affects y
	inc & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(inc & x.d[0])		-> y.d[0]+	// x-coupled
	x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> o.d[0]+

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
	~x.d[1] & ~y.d[1]			-> _o.d[0]+
	_o.d[0] & x.d[0]			-> o.d[0]-
**/
}
}

//-----------------------------------------------------------------------------
/**
	Source that alternates between two values.  
	Smaller, faster, lower latency, simply superior.  
	Latency: inc -> o+ (2T), ~inc -> o- (2T)
	Reset: inc may be either high or low on reset, doesn't matter.
	Initial: first rail raised will be o.d[0].
	\param inc the increment input signal.
	\param o the dual-rail output.  
 */
defproc alternator_source_1of2_fast(
		bool inc;
		c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
_c1of2 _o;
symmetric_alternator_stage_fast s[2];
	s[0](inc, x.d, _o.d, o.d, _Reset);
	s[1](inc, {x.d[1], x.d[0]}, 
		{_o.d[1], _o.d[0]}, {o.d[1], o.d[0]}, _Reset);
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset

	// All the following production rules have been folded into:
	// symmetric_alterator_stage_fast, above.
	// The full expansion is left here for clarity.  
	Reset					-> o.d[0]-
	Reset					-> o.d[1]-

/**
	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// x must be stable before responding with o-

	// using cross-locking mutual exclusion
	inc & x.d[0] & _o.d[1] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> o.d[0]+
	// flip x to set up for next iteration
	o.d[0]					-> x.d[0]-
	~x.d[0] & ~(o.d[1])			-> x.d[1]+	// x-coupled

	// reset phase is decoupled from everything else
	~inc 					-> _o.d[0]+
	_o.d[0] & x.d[1]			-> o.d[0]-

	// symmetric counterpart
	inc & x.d[1] & _o.d[0] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> o.d[1]+
	// flip x to set up for next iteration
	o.d[1]					-> x.d[1]-
	~x.d[1] & ~(o.d[0])			-> x.d[0]+	// x-coupled

	// reset phase is decoupled from everything else
	~inc					-> _o.d[1]+
	_o.d[1] & x.d[0]			-> o.d[1]-
**/
}
}

// typedef	alternator_source_1of2_slow	alternator_source_1of2;
typedef	alternator_source_1of2_fast	alternator_source_1of2;

//-----------------------------------------------------------------------------
/**
	Half of a symmetric lock implementation.  
	Used in definition of alternator_lock_1of2.
 */
defproc alternator_half_lock_slow(
		bool inc[2], x[2], y[2], _o[2], o[2], _Reset) {
prs {

	~_Reset					-> _o[1]+
	// set-phase affects y
	inc[1] & x[0]				-> y[0]-
	~y[0] & ~(inc[0] & x[1])		-> y[1]+	// x-coupled
	x[0] & y[1] & _Reset			-> _o[1]-
	~_o[1]					-> o[1]+

	// reset-phase affects x
	o[1] & y[1]				-> x[0]-
	~inc[1] & ~x[0] & ~(o[0] & y[0])	-> x[1]+	// x-coupled
	~x[0] & ~y[0]				-> _o[0]+
	_o[0] & x[1]				-> o[0]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Half of a symmetric lock implementation.  
	Lower latency version.  
	Latency: inc -> o+ (2T)
	Used in definition of alternator_lock_1of2.
 */
defproc alternator_half_lock_fast(
		bool i[2], x[2], y[2], _o, o[2], _Reset) {
prs {
	// ~_Reset					-> _o+

	// reset-phase affects x
	~x[1] & ~i[1] & ~y[0]			-> _o+		// eww, 3p
	_o & y[1]				-> o[0]-
	o[1] & y[1]				-> x[0]-
	~o[0] & ~x[0] & ~(o[0] & y[0])		-> x[1]+	// x-coupled

	// set-phase affects y
	i[0] & x[1] & y[1]			-> _o-
	~_o					-> o[0]+
	o[0] & x[1] & _Reset			-> y[1]-
	~y[1] & ~(o[1] & x[0])			-> y[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	Reset: inputs low, this will hold _o high on reset.
	Test: alternator-lock-01.{hac,prsimrc}
	TODO: consider lower latency reshuffling.
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc alternator_lock_1of2_slow(
		bool inc[2];
		_c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];
alternator_half_lock_slow s[2];
	s[0](inc, x.d, y.d, _o, o.d, _Reset);
	s[1]({inc[1], inc[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		{_o[1], _o[0]}, {o.d[1], o.d[0]}, _Reset);
prs {
	~_Reset					-> o.d[1]+
//	Reset					-> o.d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

/***
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[1]+
	~_Reset					-> _o[0]+
	// set-phase affects y
	inc[1] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(inc[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o[1]-
	~_o[1]					-> o.d[1]+

	// reset-phase affects x
	o.d[1] & y.d[1]				-> x.d[0]-
	~inc[1] & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o[0]+
	_o[0] & x.d[1]				-> o.d[0]-

	// set-phase affects y
	inc[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(inc[1] & x.d[0])		-> y.d[0]+	// x-coupled
	x.d[1] & y.d[0] & _Reset		-> _o[0]-
	~_o[0]					-> o.d[0]+

	// reset-phase affects x
	o.d[0] & y.d[0]				-> x.d[1]-
	~inc[0] & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
	~x.d[1] & ~y.d[1]			-> _o[1]+
	_o[1] & x.d[0]				-> o.d[1]-
***/
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	This can also be connected as an alternating active (a1of1's) 
		bucket that consumes tokens in round-robin.  
		It actively 'requests' for one input at a time.  
	Reset: inputs low, this will hold _o high on reset.
	Test: alternator-lock-02.{hac,prsimrc}
		Has some potential troubles during reset!!!
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc alternator_lock_1of2_fast(
		bool inc[2];
		_c1of2 o;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];
alternator_half_lock_fast s[2];
	s[0](inc, x.d, y.d, _o[0], o.d, _Reset);
	s[1]({inc[1], inc[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		_o[1], {o.d[1], o.d[0]}, _Reset);
// spec { exclhi(inc) }		// not necessarily true on reset
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	~_Reset					-> o.d[0]+
	~_Reset					-> o.d[1]+

	~_Reset					-> _o[0]+
	Reset					-> _o[1]-
/**
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	// set-phase affects y
	inc[1] & x.d[0] & y.d[0]		-> _o[1]-
	~_o[1]					-> o.d[1]+
	// *here* on reset
	o.d[1] & x.d[0] & _Reset		-> y.d[0]-
	~y.d[0] & ~(o.d[0] & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~x.d[1] & ~inc[1] & ~y.d[0]		-> _o[0]+	// eww, 3p
	_o[0] & y.d[1]				-> o.d[0]-
	o.d[1] & y.d[1]				-> x.d[0]-
	~o.d[0] & ~x.d[0] & ~(o.d[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	inc[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o.d[0]+
	o.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(o.d[1] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~x.d[0] & ~inc[0] & ~y.d[1]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[0]				-> o.d[1]-
	o.d[0] & y.d[0]				-> x.d[1]-
	~o.d[1] & ~x.d[1] & ~(o.d[1] & y.d[1])	-> x.d[0]+	// x-coupled
**/
}
}

typedef	alternator_lock_1of2_fast	alternator_lock_1of2;

//-----------------------------------------------------------------------------
/**
	Symmetric half of a passive alternator bucket.  
	NOTE: _o[1] is only passed to express cross-coupled feedback and is 
	not needed in the physical implementation.  
 */
defproc alternator_bucket_half(
		bool i[2], x[2], y[2], _o[2], o[2], _Reset, Reset) {
prs {
	~_Reset					-> _o[0]+
	Reset					-> o[0]-

	// set-phase affects y
	i[0] & x[1] & y[1]			-> _o[0]-
	~_o[0]					-> o[0]+
	x[1] & o[0]				-> y[1]-
	~y[1] & ~(x[0] & o[1])			-> y[0]+	// x-coupled

	// reset-phase affects x
	~i[0] & ~x[0] & ~y[1]			-> _o[0]+	// eww, 3p
	_o[0] & y[0]				-> o[0]-
	_o[0] & y[0]				-> x[1]-
	~o[0] & ~x[1] & ~(_o[1] & y[1])		-> x[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	This process can look like an alternating passive bucket pair, 
	that acknowledges (consumes) tokens on alternating input channels.  
	This variation does not require inputs to be exclusive high, 
	but guarantees that the input enables (active-low) acknowledges
	are exclusive-low.  
	This starts by consuming the L[0] token first.  
	HSE: *[[L0d];L0e-;[~L0d];L0e+;[L1d];L1e-;[~L1d];[L1e+]]
	Reset: Expects L[0].d low on reset
	Test: alternator-bucket-01.{hac,prsimrc}
	Acknowledge latency; 1T! (single inverter)
	\param L input channels.
 */
defproc alternator_bucket_passive_fast(
		e1of1 L[2];
		bool _Reset, Reset) {
c1of2 x, y;
bool i[2], _o[2], o[2];
i[0] = L[0].d[0];
i[1] = L[1].d[0];
// _o[0] = L[0].e;	// horrible implementation: dynamic logic driving ack.
// _o[1] = L[1].e;	// horrible implementation: dynamic logic driving ack.
bool _le[2];
alternator_bucket_half b[2];
	b[0](i, x.d, y.d, _o, o, _Reset, Reset);
	b[1]({i[1], i[0]}, {x.d[1], x.d[0]}, {y.d[1], y.d[0]},
		{_o[1], _o[0]}, {o[1], o[0]}, _Reset, Reset);
spec {
	exclhi(o)
	excllo(_o)
}
prs {
	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

(:j:2:
	_o[j]					=> _le[j]-
	_le[j]					=> L[j].e-
)

/***
	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+
	Reset					-> o[0]-
	Reset					-> o[1]-

	// set-phase affects y
	i[1] & x.d[0] & y.d[0]			-> _o[1]-
	~_o[1]					-> o[1]+
	x.d[0] & o[1]				-> y.d[0]-
	~y.d[0] & ~(x.d[1] & o[0])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~i[1] & ~x.d[1] & ~y.d[0]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[1]				-> o[1]-
	_o[1] & y.d[1]				-> x.d[0]-
	~o[1] & ~x.d[0] & ~(_o[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	i[0] & x.d[1] & y.d[1]			-> _o[0]-
	~_o[0]					-> o[0]+
	x.d[1] & o[0]				-> y.d[1]-
	~y.d[1] & ~(x.d[0] & o[1])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~i[0] & ~x.d[0] & ~y.d[1]		-> _o[0]+	// eww, 3p
	_o[0] & y.d[0]				-> o[0]-
	_o[0] & y.d[0]				-> x.d[1]-
	~o[0] & ~x.d[1] & ~(_o[1] & y.d[1])	-> x.d[0]+	// x-coupled
***/
}
}

//-----------------------------------------------------------------------------
/**
	NOTE: this is just a plain onehot-stage with 
	an additional inverter!
	\param B if additional guard is neded on _sk+ (for N >= 3)
 */
template <pbool B>
defproc alternator_bucket_passive_e1of1_element(
		e1of1 L;
		bool _si, sj, _sk, sk, _sl;
		bool _Reset) {
prs {
	~_Reset					-> _sk+

	L.d[0] & sj & _si			-> _sk-
	~_sk					-> sk+
	sk					-> L.e-
[B ->
	~L.d[0] & ~_sl & ~sj			-> _sk+	
[] else ->
	~L.d[0] & ~_sl				-> _sk+	
]
	_sk					-> sk-
	~sk					-> L.e+
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	NOTE: this is just a plain onehot-stage with 
	an additional inverter!
	\param B if additional guard is neded on _sk+ (for N >= 3)
 */
template <pbool B>
defproc alternator_bucket_passive_e1of1_element_init(
		e1of1 L;
		bool _si, sj, _sk, sk, _sl;
		bool Reset) {
prs {
	Reset					-> _sk-

	L.d[0] & sj & _si			-> _sk-
	~_sk					-> sk+
	sk					-> L.e-
[B ->
	~L.d[0] & ~_sl & ~sj			-> _sk+	
[] else ->
	~L.d[0] & ~_sl				-> _sk+	
]
	_sk					-> sk-
	~sk					-> L.e+
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	This process consumes tokens from several inputs in successive order
	by acknowledging one input at a time.
	NOTE: channels are acknowledge in order, but the acknowledges 
	themselves may overlap momentarily!  Holy concurrency, Batman!
	This starts by consuming the L[0] token first.  
	HSE: *[[L0d];L0e-;[~L0d];L0e+;[L1d];L1e-;[~L1d];[L1e+];...]
	Reset: Expects L[].d low on reset
	Test: alternator-bucket-0{2,3}.{hac,prsimrc}
	TODO: wrapper definition to generalize for all N < 0.
	Acknowledge latency: 3T
	\param N > 2, number of input channels.
	\param L input channels.
 */
template <pint N>
defproc alternator_bucket_passive_e1of1(e1of1 L[N]; bool _Reset, Reset) {
	bool _s[N], s[N];
	alternator_bucket_passive_e1of1_element_init<(N>3)>
		i0(L[N-1], _s[N-2], s[N-1], _s[0], s[0], _s[1], Reset);
	alternator_bucket_passive_e1of1_element<(N>3)> i[1..N-1];
	(;j:1..N-1:
		i[j](L[j-1], _s[(N+j-2)%N], s[j-1],
			_s[j], s[j], _s[(j+1)%N], _Reset);
	)
}

//-----------------------------------------------------------------------------
/**
	Exposes the one-hot, two-hot array, s.
 */
template <pint N>
defproc onehot_bare_ring(bool inc; bool s[N]; bool _Reset, Reset) {
spec { assert< N>=3 >() }
(;i:N:
spec {	exclhi(s[i], s[(i+2)%N]) }
)
bool _s[N];
// note: element j is set by j-1, but reset by j
onehot_stage_init i0(inc,
	_s[N-2], s[N-1], _s[0], s[0], _s[1], Reset);
onehot_stage i[1..N-1];
(;j:1..N-1:
	i[j](inc, _s[(N+j-2)%N], s[j-1],
		_s[j], s[j], _s[(j+1)%N], _Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Weak-condition onehot counter, cycles through 1ofN rails.  
	Example of use of onehot_stages to form a counter.  
	reset: inc may be either active or inactive on reset.  
	HSE: *[[inc];O.0+;[~inc];O.0-;[inc];O.1+;[~inc];O.1-;...]
	Tested: test/lib/alternator-onehot_counter-01.
	Tested: test/lib/alternator-onehot_counter-02.
	Metrics: inc to out latency is 4 transitions.  
	\param N the number of values to cycle through (> 0).  
	\param inc is effectively an active-low output acknowledge or 
		active-high input request.  
 */
template <pint N>
defproc	onehot_counter(
		bool inc;		// can be .e of e1ofN channel
		c1of<N> o;		// for exclhi
		bool _Reset, Reset) {
[(N > 2) ->
	bool s[N], _o[N];
	onehot_bare_ring<N> r(inc, s, _Reset, Reset);
[] N == 2 ->
	// special case alternator
	alternator_source_1of2 a(inc, o, _Reset, Reset);
[] N == 1 ->
	bool _r;
]
prs {
[(N > 2) ->
	// ring of AND-gates to generate one-hot signal
	// _Reset				=> Reset-
	(:j:N:
		s[j] & s[(j+1)%N]		=> _o[j]-
		_o[j]				=> o.d[j]-
	)
	// TODO: rewrite as trailing else clause
[] else ->
	[ N == 1 ->
		// extremely fast source
		~_Reset					-> _r+
		~inc					-> _r+
		inc & _Reset				-> _r-
		_r					=> o.d[0]-
	]
]
}
}

typedef	onehot_counter<1>		onehot_counter1;
typedef	alternator_source_1of2		onehot_counter2;
typedef	onehot_counter<3>		onehot_counter3;
typedef	onehot_counter<4>		onehot_counter4;
typedef	onehot_counter<5>		onehot_counter5;
typedef	onehot_counter<6>		onehot_counter6;
typedef	onehot_counter<7>		onehot_counter7;
typedef	onehot_counter<8>		onehot_counter8;

//-----------------------------------------------------------------------------
/**
	Exposes the one-hot, two-hot array, s.
 */
template <pint N>
defproc onehot_seq_bare_ring(bool inc[N]; bool s[N]; bool _Reset, Reset) {
spec { assert< N>=3 >() }
(;i:N:
spec {	exclhi(s[i], s[(i+2)%N]) }
)
bool _s[N];
// note: element j is set by j-1, but reset by j
onehot_seq_element_init i0(inc[N-1], inc[N-2], inc[0], 
	_s[N-2], s[N-1], _s[0], s[0], _s[1], Reset);
onehot_seq_element i[1..N-1];
(;j:1..N-1:
	i[j](inc[(j+N-1)%N], inc[(j+N-2)%N], inc[j], 
		_s[(N+j-2)%N], s[j-1],
		_s[j], s[j], _s[(j+1)%N], _Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Instead of a single output channel, a sequence of 
	synchronization channels.
	Each channel waits for the previous to complete its reset
	before starting, so the control channels remain mutually exclusive.
	Q: is there a simpler way to do this without one-hot elements?
 */
template <pint N>
defproc onehot_sequencer(e1of1 O[N]; bool _Reset, Reset) {
spec { assert< N>=3 >() }
bool _o[N], s[N];
bool inca[N], od[N];
(;j:N:
	inca[j] = O[j].e;
	od[j] = O[j].d[0];
)
spec {
	excllo(inca)
	exclhi(od)
}
onehot_seq_bare_ring<N> r(inca, s, _Reset, Reset);
// AND the s state elements to produce one-hot output
prs {
	(:j:N:
		s[j] & s[(j+1)%N]		=> _o[j]-
		_o[j]				=> O[j].d[0]-
	)
}
}

//-----------------------------------------------------------------------------
// TODO: onehot_lock
// passes one value though at a time in round-robin fashion.
// in the fashion of alternator_lock_1of2

//-----------------------------------------------------------------------------
/**
	Buffer that eats every other token.  
	"One for you, one for me..."
	Application: forms frequency divider when cascaded serially.
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Other rehufflings may be possible.

	Reset: L.e is high, R.d[0] is low, don't care about R.e
	Tests: alternator-wchb_eater-0{1,2}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
defproc wchb_alternator_eater_2_slow(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
prs {
	Reset					-> R.d[0]-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0] | r1				-> L.e-

	// reset-phase affects x
	R.d[0] & y.d[0]				-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(r1 & y.d[1])	-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+

	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> r1+

	// reset-phase affects x
	r1 & y.d[1]				-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> r1-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Buffer that eats every other token.  
	"One for you, one for me..."
	Application: forms frequency divider when cascaded serially.
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Other rehufflings may be possible.
	Latency: L -> R (2T), when token is passed through.  
	Reset: expects L.d low, R.e can be either high or low.
	Tests: alternator-wchb_eater-0{5,6}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
defproc wchb_alternator_eater_2_fast(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
spec {
	exclhi(R.d[0], r1)
}
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	Reset					-> R.d[0]-

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	R.e & L.d[0] & x.d[0] & y.d[0]		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0]					-> L.e-
	R.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(r1 & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~L.d[0] & ~y.d[0]		-> _o.d[0]+
	_o.d[0] & y.d[1]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+
	L.e & y.d[1] & _o.d[0]			-> x.d[0]-
	~x.d[0] & ~(L.e & y.d[0] & _o.d[1])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	L.d[0] & x.d[1] & y.d[1]		-> _o.d[1]-	// y.d[1]?
	~_o.d[1]				-> r1+
	r1					-> L.e-
	r1 & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(R.d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~L.d[0] & ~y.d[1]			-> _o.d[1]+
	_o.d[1] & y.d[0]			-> r1-		// y.d[0]?
//	~R.d[0] & ~r1				-> L.e+		// dupl.
	L.e & y.d[0] & _o.d[1]			-> x.d[1]-
	~x.d[1] & ~(L.e & y.d[1] & _o.d[0])	-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	2-way alternation, eating every other token on e1ofN channel.  
	HSE: [[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+;[Ld];Le-;[~Ld];Le+]
	Latency: L -> R (2T), when token is passed through.  
	Reset: expects L.d low, R.e can be either high or low.
	Tests: alternator-wchb_eater-0{7,8}.{hac,prsimrc}
	\param L input channel.
	\param R output channel, every other token.  
 */
template <pint N>
defproc wchb_alternator_eater_2_e1of(e1of<N> L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of<N+1> _o;
bool rv;
bool rN;
spec {
	exclhi(rv, rN)		// kinda creates another redundant ring
}
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

(:i:N:
	Reset					-> R.d[i]-
	~_Reset					-> _o.d[i]+
)
	~_Reset					-> _o.d[N]+
	Reset					-> rv-

	// set-phase affects y
(:i:N:
	R.e & L.d[i] & x.d[0] & y.d[0]		-> _o.d[i]-
	~_o.d[i]				-> R.d[i]+
)
	(|:i:N: ~_o.d[i] )			-> rv+
	rv					-> L.e-
	rv & x.d[0]				-> y.d[0]-
	~L.e & ~y.d[0] & ~(R.e & rN & x.d[1])	-> y.d[1]+	// x-coupled

	// reset-phase affects x
(:i:N:
	~R.e & ~L.d[i] & ~y.d[0]		-> _o.d[i]+
	_o.d[i] & y.d[1]			-> R.d[i]-
)
	(&:i:N: _o.d[i] ) & y.d[1]		-> rv-
	~rv & ~rN				-> L.e+
	L.e & y.d[1]				-> x.d[0]-
	~x.d[0] & ~(L.e & y.d[0])		-> x.d[1]+	// x-coupled

	// set-phase affects y
	(|:i:N: L.d[i] ) & x.d[1] & y.d[1]	-> _o.d[N]-
	~_o.d[N]				-> rN+
	rN					-> L.e-
	R.e & rN & x.d[1]			-> y.d[1]-	// need R.e
	~L.e & ~y.d[1] & ~(rv & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	(&:i:N: ~L.d[i] ) & ~y.d[1]		-> _o.d[N]+	// UGH!
	_o.d[N] & y.d[0]			-> rN-
//	~R.d[0] & ~rN				-> L.e+		// dupl.
	L.e & y.d[0]				-> x.d[1]-
	~x.d[1] & ~(L.e & y.d[1])		-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Same as the above, but eats first token b/c reset in different phase.  
	"One for me, one for you..."
	(Can't think of a good reason where one would use this, but it's here.)
	HSE: [[Ld];Le-;[~Ld];Le+;[Re&Ld];Rd+;Le-;[~Re&~Ld];Rd-;Le+]
	Reset: L.e is high, R.d[0] is low, R.e must be high (inactive)!
	Test: alternator-wchb_eater-03.{hac,prsimrc}
 */
defproc wchb_alternator_eater_2_slow_eatfirst(
		e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
bool r1;
prs {
	Reset					-> R.d[0]-
	Reset					-> r1-

	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-	// d[0]
	~_Reset					-> y.d[0]+	// d[1]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0] & _Reset		-> _o.d[0]-
	~_o.d[0]				-> R.d[0]+
	R.d[0] | r1				-> L.e-

	// reset-phase affects x
	R.d[0] & y.d[0]				-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(r1 & y.d[1])	-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R.d[0]-
	~R.d[0] & ~r1				-> L.e+

	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	x.d[0] & y.d[1] & _Reset		-> _o.d[1]-
	~_o.d[1]				-> r1+

	// reset-phase affects x
	r1 & y.d[1]				-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R.d[0] & y.d[0])	-> x.d[1]+	// x-coupled
	~x.d[0] & ~y.d[0]			-> _o.d[1]+
	_o.d[1] & x.d[1]			-> r1-
}
}

//-----------------------------------------------------------------------------
/**
	Serial chain of wchb_alternator_eaters, where each stage
	eats every other token.  
	a.k.a. Frequency-divider.  
	Each stage is WCHB-style.  
	Reset: expects Ld low, sends Le high,
		requires R.e to be high (inactive)
	Test: alternator-wchb_eater-04.{hac,prsimrc}
	\pint N number of divider stages
	\param L input channel
	\param R output channel at 1/2^N frequency
 */
template <pint N>
defproc alternator_eater_chain_slow(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_eater_2_slow e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Serial chain of wchb_alternator_eaters, where each stage
	eats every other token.  
	a.k.a. Frequency-divider.  
	Each stage is WCHB-style.  
	This variation is faster, and lower latency.  
	Reset: expects Ld low, sends Le high,
		doesn't care what R.e is on reset
	Test: alternator-wchb_eater-{09,10}.{hac,prsimrc}
	\param N number of divider stages
	\param L input channel
	\param R output channel at 1/2^N frequency
 */
template <pint N>
defproc alternator_eater_chain_fast(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_eater_2_fast e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Generalized token eater chain for e1ofN.  
	Each stage is WCHB-style.  
	Reset: expects Ld low, sends Le high,
		doesn't care what R.e is on reset
	Test: alternator-wchb_eater-{11,12}.{hac,prsimrc}
	\param N number of rails in channel
	\param S number of stages
 */
template <pint N, S>
defproc alternator_eater_chain_e1of(e1of<N> L, R; bool _Reset, Reset) {
e1of<N> M[S+1];
M[0] = L;
M[S] = R;
wchb_alternator_eater_2_e1of<N> e[S];
(;i:S:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//=============================================================================
/**
	Buffer that produces two sequential output tokens, per input token.  
	Application: on-chip token burst generation.  
	HSE: [[Re&Ld];Rd+;Le-;[~Re];Rd-;[Ld];Rd+;[~Re&~Ld];Rd-;Le+]
	Latency: L -> R (2T), when token is passed through.  
	Reset: 
	Tests:
	\param L input channel.
	\param R output channel, used twice per input token.  
 */
defproc wchb_alternator_repeater_2_lazy(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
bool _o;
prs {
	Reset					-> x.d[1]-
	~_Reset					-> x.d[0]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[1]-
	~_Reset					-> y.d[0]+

	Reset					-> R.d[0]-
	~_Reset					-> L.e+

	~_Reset					-> _o+

	// set-phase affects y
	R.e & L.d[0] & x.d[0] & y.d[0]		-> _o-
	~_o					-> R.d[0]+
	R.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(R.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R.d[0] & y.d[1]				-> L.e-

	// reset-phase affects x (don't wait for ~L.d[0])
	~L.d[0] & ~R.e & ~y.d[0] & ~x.d[1]	-> _o+
	_o & y.d[1]				-> R.d[0]-
	y.d[1] & _o				-> x.d[0]-
	~R.d[0] & ~x.d[0] & ~(L.e & y.d[0] & _o)
						-> x.d[1]+	// x-coupled

	// set-phase affects y
	R.e & x.d[1] & y.d[1] & _Reset		-> _o-
//	~_o					-> R.d[0]+	// dupl.
	R.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(R.d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R.e & ~y.d[1] & ~x.d[0]		-> _o+
	_o & y.d[0] & x.d[1]			-> R.d[0]-
	~R.d[0] & ~y.d[1]			-> L.e+	
	L.e & y.d[0] & _o			-> x.d[1]-
	~R.d[0] & ~x.d[1] & ~(_o & y.d[1])	-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Another token repeater.  
	Derived from wchb_merge_alternator_2xe1of1_fast.
	HSE: [[Re&Ld];Le-;Rd+;[~Re];Le+;Rd-;[Re];Rd+;[~Re];Rd-]
	Reset: expects input data low, gives L.e high, R.e can be any
	Latency: L -> R (2T)
	Tests: alternator-wchb_repeater-{03,04}.{hac,prsimrc}
 */
defproc wchb_alternator_repeater_2_merge(e1of1 L, R; bool _Reset, Reset) {
c1of2 x, y;
bool _o[2], o[2];
bool _le;
// this is horrible in practice: driving enable with weak dynamic logic
// _o[0] = L.e;	
spec {
	excllo(_o)
}
prs {
	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+
	Reset					-> o[0]-
	Reset					-> o[1]-

	_o[0]					=> _le-
	_le					=> L.e-

	~_o[0] | ~_o[1]				-> R.d[0]+
	 _o[0] &  _o[1]				-> R.d[0]-

	// set-phase affects y
	R.e & x.d[0] & y.d[0] & _Reset		-> _o[1]-
	~_o[1]					-> o[1]+
	x.d[0] & o[1]				-> y.d[0]-
	~y.d[0] & ~(x.d[1] & o[0])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~x.d[1] & ~y.d[0]		-> _o[1]+	// eww, 3p
	_o[1] & y.d[1]				-> o[1]-
	_o[1] & y.d[1]				-> x.d[0]-
	~o[1] & ~x.d[0] & ~(_o[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	R.e & L.d[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o[0]+
	x.d[1] & o[0]				-> y.d[1]-
	~y.d[1] & ~(x.d[0] & o[1])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R.e & ~L.d[0] & ~x.d[0] & ~y.d[1]	-> _o[0]+	// eww, 4p
	_o[0] & y.d[0]				-> o[0]-
	_o[0] & y.d[0]				-> x.d[1]-
	~o[0] & ~x.d[1] & ~(_o[1] & y.d[1])	-> x.d[0]+	// x-coupled
}
}

/**
	We default to using the merge-based implementation.  
 */
typedef	wchb_alternator_repeater_2_merge	wchb_alternator_repeater_2;

//-----------------------------------------------------------------------------
/**
	Serial chain of wchb_alternator_repeaters, where each stage
	produces two output tokens per input.  
	a.k.a. Frequency-multiplier, token burst generator.  
	Reset: doesn't care what R.e is on reset
	Test: alternator-wchb_repeater-0{5,6}.{hac,prsimrc}
	\pint N number of repeater stages
	\param L input channel
	\param R output channel
 */
template <pint N>
defproc alternator_repeater_chain_lazy(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_repeater_2_lazy e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Serial chain of wchb_alternator_repeaters, where each stage
	produces two output tokens per input.  
	Reset: doesn't care what R.e is on reset
	Test: alternator-wchb_repeater-0{7,8}.{hac,prsimrc}
	\pint N number of repeater stages
	\param L input channel
	\param R output channel
 */
template <pint N>
defproc alternator_repeater_chain_merge(e1of1 L, R; bool _Reset, Reset) {
e1of1 M[N+1];
M[0] = L;
M[N] = R;
wchb_alternator_repeater_2_merge e[N];
(;i:N:
	e[i](M[i], M[i+1], _Reset, Reset);
)
}

typedef	alternator_repeater_chain_merge		alternator_repeater_chain;

//=============================================================================
/**
	Splitting alternator.
	This is OBSOLETED by the faster version below.  
	Application: tree-FIFO! round-robin scheduling.  
	HSE: *[[R0e&Ld];R0d+;Le-;[~R0e&~Ld];R0d-;Le+;
		[R1e&Ld];R1d+;Le-;[~R1e&~Ld];R1d-;Le+]
	Reset: R.e's don't matter
	Test: alternator-wchb_split-0{1,2,3,4}.{hac,prsimrc}
	Forward latency: L -> R (4T+/2T-)
	\param L input channel
	\param R output channels (forwarded in alternation, starting R[0])
 */
defproc wchb_alternator_split_2_slow(e1of1 L, R[2]; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
prs {
	Reset					-> R[0].d[0]-
//	Reset					-> R[1].d[0]-	// not needed

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+
	// set-phase affects y
	L.d[0] & x.d[0]				-> y.d[0]-
	~y.d[0] & ~(L.d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R[1].e & x.d[0] & y.d[1] & _Reset	-> _o.d[1]-
	~_o.d[1]				-> R[1].d[0]+
	R[0].d[0] | R[1].d[0]			-> L.e-

	// reset-phase affects x
	R[1].d[0] & y.d[1]			-> x.d[0]-
	~L.d[0] & ~x.d[0] & ~(R[0].d[0] & y.d[0])
						-> x.d[1]+	// x-coupled
	~R[1].e & ~x.d[0] & ~y.d[0]		-> _o.d[1]+
	_o.d[1] & x.d[1]			-> R[1].d[0]-
	~R[0].d[0] & ~R[1].d[0]			-> L.e+

	// set-phase affects y
	L.d[0] & x.d[1]				-> y.d[1]-
	~y.d[1] & ~(L.d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R[0].e & x.d[1] & y.d[0] & _Reset	-> _o.d[0]-
	~_o.d[0]				-> R[0].d[0]+

	// reset-phase affects x
	R[0].d[0] & y.d[0]			-> x.d[1]-
	~L.d[0] & ~x.d[1] & ~(R[1].d[0] & y.d[1])
						-> x.d[0]+	// x-coupled
	~R[0].e & ~x.d[1] & ~y.d[1]		-> _o.d[0]+
	_o.d[0] & x.d[0]			-> R[0].d[0]-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Splitting alternator.
	Application: tree-FIFO! round-robin scheduling.  
	HSE: *[[R0e&Ld];R0d+;Le-;[~R0e&~Ld];R0d-;Le+;
		[R1e&Ld];R1d+;Le-;[~R1e&~Ld];R1d-;Le+]
	Reset: R.e's don't matter, L.d should be low
	Test: alternator-wchb_split-0{7,8}.{hac,prsimrc}
	Forward latency: L -> R (2T)
	\param L input channel
	\param R output channels (forwarded in alternation, starting R[0])
 */
defproc wchb_alternator_split_2_fast(e1of1 L, R[2]; bool _Reset, Reset) {
c1of2 x, y;
_c1of2 _o;
prs {
	Reset					-> R[0].d[0]-
	Reset					-> R[1].d[0]-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	~_Reset					-> _o.d[1]+
	~_Reset					-> _o.d[0]+

	// NOTE: production rules are symmetric, except for generation of L.e
	// set-phase affects y
	R[1].e & L.d[0] & x.d[0] & y.d[0]	-> _o.d[1]-
	~_o.d[1]				-> R[1].d[0]+
	R[1].d[0]				-> L.e-
	R[1].d[0] & x.d[0]			-> y.d[0]-
	~y.d[0] & ~(R[0].d[0] & x.d[1])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R[1].e & ~L.d[0]			-> _o.d[1]+	// ~y.d[0]?
	_o.d[1] & y.d[1]			-> R[1].d[0]-
	~R[0].d[0] & ~R[1].d[0]			-> L.e+
	_o.d[1] & y.d[1]			-> x.d[0]-
	~R[1].d[0] & ~x.d[0] & ~(_o.d[0] & y.d[0])
						-> x.d[1]+	// x-coupled

	// set-phase affects y
	R[0].e & L.d[0] & x.d[1] & y.d[1]	-> _o.d[0]-
	~_o.d[0]				-> R[0].d[0]+
	R[0].d[0]				-> L.e-
	R[0].d[0] & x.d[1]			-> y.d[1]-
	~y.d[1] & ~(R[1].d[0] & x.d[0])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R[0].e & ~L.d[0]			-> _o.d[0]+	// ~y.d[1]?
	_o.d[0] & y.d[0]			-> R[0].d[0]-
//	~R[0].d[0] & ~R[1].d[0]			-> L.e+		// dupl.
	_o.d[0] & y.d[0]			-> x.d[1]-
	~R[0].d[0] & ~x.d[1] & ~(_o.d[1] & y.d[1])
						-> x.d[0]+	// x-coupled
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Generalization splitting alternator for e1ofN channels.  
	Definition based on "wchb_alternator_split_2_fast".  
	Reset: expects input data low, sends L.e+, R.e doesn't matter
	Test: alternator-wchb_split-{11,12}.{hac,prsimrc}
	HSE: (same as the e1of1 version)
	\param N the number of channel rails.  
 */
template <pint N>
defproc wchb_alternator_split_2xe1of(e1of<N> L, R[2]; bool _Reset, Reset) {
c1of2 x, y;
_c1of<N> _o[2];
c1of2 rv;
prs {
(:j:2:
(:n:N:
	Reset					-> R[j].d[n]-
	~_Reset					-> _o[n].d[j]+
)
)

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-	// d[1]
	~_Reset					-> y.d[1]+	// d[0]

	// data rail completions
(:j:2:
	Reset					-> rv.d[j]-
	// need to strengthen with y.d[j] before responding to environment!
	(&:n:N: _o[j].d[n] ) & y.d[j]		-> rv.d[j]-
	(|:n:N: ~_o[j].d[n] )			-> rv.d[j]+
)
	(|:j:2: rv.d[j] )			=> L.e-

	// NOTE: production rules are symmetric
	// set-phase affects y
(:n:N:
	R[1].e & L.d[n] & x.d[0] & y.d[0]	-> _o[1].d[n]-
	~_o[1].d[n]				-> R[1].d[n]+
)
	R[0].e & rv.d[1] & x.d[0]		-> y.d[0]-	// R.e to check R.d-
	~L.e & ~y.d[0] & ~(rv.d[0] & x.d[1] & R[1].e)
						-> y.d[1]+	// x-coupled

	// reset-phase affects x
(:n:N:
	~R[1].e & ~L.d[n]			-> _o[1].d[n]+	// ~y.d[0]?
	_o[1].d[n] & y.d[1]			-> R[1].d[n]-	// unchecked
)
	L.e & y.d[1]				-> x.d[0]-
	~rv.d[1] & ~x.d[0] & ~(L.e & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
(:n:N:
	R[0].e & L.d[n] & x.d[1] & y.d[1]	-> _o[0].d[n]-
	~_o[0].d[n]				-> R[0].d[n]+
)
	R[1].e & rv.d[0] & x.d[1]		-> y.d[1]-	// R.e to check R.d-
	~L.e & ~y.d[1] & ~(rv.d[1] & x.d[0] & R[0].e)
						-> y.d[0]+	// x-coupled

	// reset-phase affects x
(:n:N:
	~R[0].e & ~L.d[n]			-> _o[0].d[n]+
	_o[0].d[n] & y.d[0]			-> R[0].d[n]-
)
	L.e & y.d[0]				-> x.d[1]-
	~rv.d[0] & ~x.d[1] & ~(L.e & y.d[1])	-> x.d[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	Depth K alternating splitter.  
	Splits to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: R.e's don't matter
	Test: alternator-wchb_split-0{5,6}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_split_2_tree_slow(
		e1of1 L, R[1<<K]; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = L;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_split_2_slow S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k][l], M[k+1][2*l..2*l+1], _Reset, Reset);
)
)
R = M[K];	// connect outputs
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Depth K alternating splitter, low latency version.  
	Splits to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Forward latency: 2T per stage, so 2K
	Reset: R.e's don't matter
	Test: alternator-wchb_split-{09,10}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_split_2_tree_fast(
		e1of1 L, R[1<<K]; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = L;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_split_2_fast S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k][l], M[k+1][2*l..2*l+1], _Reset, Reset);
)
)
R = M[K];	// connect outputs
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Depth K alternating e1ofN splitter, low latency version.  
	Splits to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Forward latency: 2T per stage, so 2K
	Reset: R.e's don't matter
	Test: alternator-wchb_split-{13,14}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint N, K>
defproc wchb_alternator_split_2_tree_e1of(
		e1of<N> L, R[1<<K]; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of<N> M[1][1];
M[0][0] = L;
(;k:K:
	e1of<N> M[k+1..k+1][1<<(k+1)];
	wchb_alternator_split_2xe1of<N> S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k][l], M[k+1][2*l..2*l+1], _Reset, Reset);
)
)
R = M[K];	// connect outputs
}

//=============================================================================
/**
	This is OBSOLETE, use the 2xe1of1_fast version instead.  
	Passes one value through at a time betwen two rails in alternation.  
	No single side can pass through consecutive times.  
	This definition is based on alternator_lock_1of2_slow.
	Reset: expects input data low, ...
	Test: alternator-wchb_merge-0{1,2}.{hac,prsimrc}
	Forward latency: L -> R (6T, sucks)
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	\param inc active-high inputs (or active-low ack)
	\param o the 1of2 output, like a pair of active-high acknowledges.
 */
defproc wchb_alternator_merge_2x1of1_slow(
		a1of1 L[2];
		e1of1 R;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2];	// are these excl?
bool _r;
prs {
	Reset					-> L[1].a-

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	// the following two resets only needed for active-acknowledge on reset
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	// All the following production rules have been folded into:
	// symmetric_alterator_stage, above.
	// The full expansion is left here for clarity.  

	~_Reset					-> _o[1]+
	~_Reset					-> _o[0]+

	// set-phase affects y
	L[1].d[0] & x.d[0]			-> y.d[0]-
	~y.d[0] & ~(L[0].d[0] & x.d[1])		-> y.d[1]+	// x-coupled
	R.e & x.d[0] & y.d[1]			-> _o[1]-
	~_o[1]					-> L[1].a+
	L[0].a & L[1].a				-> _r-
	~_r					-> R.d[0]+

	// reset-phase affects x
	L[1].a & y.d[1]				-> x.d[0]-
	~L[1].d[0] & ~x.d[0] & ~(L[0].a & y.d[0])
						-> x.d[1]+	// x-coupled
	~R.e & ~x.d[0] & ~y.d[0]		-> _o[0]+
	_o[0] & x.d[1]				-> L[0].a-
	~L[0].a | ~L[1].a			-> _r+
	_r					-> R.d[0]-

	// set-phase affects y
	L[0].d[0] & x.d[1]			-> y.d[1]-
	~y.d[1] & ~(L[1].d[0] & x.d[0])		-> y.d[0]+	// x-coupled
	R.e & x.d[1] & y.d[0]			-> _o[0]-
	~_o[0]					-> L[0].a+

	// reset-phase affects x
	L[0].a & y.d[0]				-> x.d[1]-
	~L[0].d[0] & ~x.d[1] & ~(L[1].a & y.d[1])
						-> x.d[0]+	// x-coupled
	~R.e & ~x.d[1] & ~y.d[1]		-> _o[1]+
	_o[1] & x.d[0]				-> L[1].a-
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	This merges tokens from two input in alternating sequence.  
	Based on alternator_bucket_passive_fast, with trivial modification.
	This starts by passing L[0] through first.  
	HSE: *[[inc0];O.0+;[~inc0];O.0-;[inc1];O.1+;[~inc1];O.1-]
	Reset: expect L.d data low on reset, and R.e doesn't matter.
	Test: alternator-wchb_merge-0{4,5}.{hac,prsimrc}
	Forward latency: L -> R (2T)
 */
defproc wchb_alternator_merge_2xe1of1_fast(
		e1of1 L[2];
		e1of1 R;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
bool _o[2], o[2];
bool i[2];
i[0] = L[0].d[0];
i[1] = L[1].d[0];
// _o[0] = L[0].e;		// horrible implementation
// _o[1] = L[1].e;		// horrible implementation
bool _le[2];
spec {
	excllo(_o)
	exclhi(o)
}
prs {

	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

	~_Reset					-> _o[0]+
	~_Reset					-> _o[1]+
	Reset					-> o[0]-
	Reset					-> o[1]-

(:j:2:
	_o[j]					=> _le[j]-
	_le[j]					=> L[j].e-
)

	~_o[0] | ~_o[1]				-> R.d[0]+
	 _o[0] &  _o[1]				-> R.d[0]-

	// set-phase affects y
	R.e & i[1] & x.d[0] & y.d[0]		-> _o[1]-
	~_o[1]					-> o[1]+
	x.d[0] & o[1]				-> y.d[0]-
	~y.d[0] & ~(x.d[1] & o[0])		-> y.d[1]+	// x-coupled

	// reset-phase affects x
	~R.e & ~i[1] & ~x.d[1] & ~y.d[0]	-> _o[1]+	// eww, 4p
	_o[1] & y.d[1]				-> o[1]-
	_o[1] & y.d[1]				-> x.d[0]-
	~o[1] & ~x.d[0] & ~(_o[0] & y.d[0])	-> x.d[1]+	// x-coupled

	// set-phase affects y
	R.e & i[0] & x.d[1] & y.d[1]		-> _o[0]-
	~_o[0]					-> o[0]+
	x.d[1] & o[0]				-> y.d[1]-
	~y.d[1] & ~(x.d[0] & o[1])		-> y.d[0]+	// x-coupled

	// reset-phase affects x
	~R.e & ~i[0] & ~x.d[0] & ~y.d[1]	-> _o[0]+	// eww, 4p
	_o[0] & y.d[0]				-> o[0]-
	_o[0] & y.d[0]				-> x.d[1]-
	~o[0] & ~x.d[1] & ~(_o[1] & y.d[1])	-> x.d[0]+	// x-coupled

}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	This merges tokens from two e1ofN input in alternating sequence.  
	Based on wchb_alternator_merge_2_fast, with trivial modification.
	This starts by passing L[0] through first.  
	HSE: same
	Reset: expect L.d data low on reset, and R.e doesn't matter.
	Test: alternator-wchb_merge-0{8,9}.{hac,prsimrc}
	Forward latency: L -> R (2T)
 */
template <pint N>
defproc wchb_alternator_merge_2xe1of(
		e1of<N> L[2];
		e1of<N> R;
		bool _Reset, Reset) {
c1of2 x;	// exclhi dual-rail state-variable
c1of2 y;	// exclhi dual-rail state-variable
_c1of<N> _o[2];
bool ov[2];
bool i[2][N];
i[0] = L[0].d;
i[1] = L[1].d;
// _o[0] = L[0].e;
// _o[1] = L[1].e;
spec {
	excllo(L[0].e, L[1].e)
	exclhi(ov)
}
prs {
	Reset					-> x.d[0]-
	~_Reset					-> x.d[1]+
	Reset					-> y.d[0]-
	~_Reset					-> y.d[1]+

(:j:2:
(:n:N:
	~_Reset					-> _o[j].d[n]+
)
	Reset					-> ov[j]-
)

(:n:N:
	~_o[0].d[n] | ~_o[1].d[n]		-> R.d[n]+
	 _o[0].d[n] &  _o[1].d[n]		-> R.d[n]-
)
(:j:2:
	 ov[j]					=> L[j].e-
)

	// set-phase affects y
(:n:N:
	R.e & i[1][n] & x.d[0] & y.d[0]		-> _o[1].d[n]-
)
	(|:n:N: ~_o[1].d[n] )			-> ov[1]+
	x.d[0] & ov[1]				-> y.d[0]-
	~L[1].e & ~y.d[0] & ~(x.d[1] & ov[0])	-> y.d[1]+	// x-coupled

	// reset-phase affects x
(:n:N:
	~R.e & ~i[1][n] & ~x.d[1] & ~y.d[0]	-> _o[1].d[n]+	// eww, 4p
)
	(&:n:N: _o[1].d[n] ) & y.d[1]		-> ov[1]-
	L[1].e & y.d[1]				-> x.d[0]-
	~ov[1] & ~x.d[0] & ~(L[0].e & y.d[0])	-> x.d[1]+	// x-coupled
	// need ~ov?

	// set-phase affects y
(:n:N:
	R.e & i[0][n] & x.d[1] & y.d[1]		-> _o[0].d[n]-
)
	(|:n:N: ~_o[0].d[n] )			-> ov[0]+
	x.d[1] & ov[0]				-> y.d[1]-
	~L[0].e & ~y.d[1] & ~(x.d[0] & ov[1])	-> y.d[0]+	// x-coupled

	// reset-phase affects x
(:n:N:
	~R.e & ~i[0][n] & ~x.d[0] & ~y.d[1]	-> _o[0].d[n]+	// eww, 4p
)
	(&:n:N: _o[0].d[n] ) & y.d[0]		-> ov[0]-
	L[0].e & y.d[0]				-> x.d[1]-
	~ov[0] & ~x.d[1] & ~(L[1].e & y.d[1])	-> x.d[0]+	// x-coupled
}
}

//-----------------------------------------------------------------------------
/**
	Wrapper to use e1of1 interfaces.  
 */
defproc wchb_alternator_merge_2xe1of1_slow(
		e1of1 L[2], R;
		bool _Reset, Reset) {
a1of1 ll[2];
(;i:2:	L[i].d = ll[i].d;	)
wchb_alternator_merge_2x1of1_slow M(ll, R, _Reset, Reset);
prs {
(:i:2:
	ll[i].a					=> L[i].e-
)
}
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Wrapper to use a1of1 interfaces.  
 */
defproc wchb_alternator_merge_2xa1of1_slow(
		a1of1 L[2], R;
		bool _Reset, Reset) {
e1of1 rr;
R.d = rr.d;
wchb_alternator_merge_2x1of1_slow M(L, rr, _Reset, Reset);
prs {
	R.a					=> rr.e-
}
}

//-----------------------------------------------------------------------------
/**
	Depth K alternating merger.  
	Merges to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: R.e needs to be high (inactive)
	Test: alternator-wchb_merge-03.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_merge_2_tree_slow(
		e1of1 L[1<<K], R; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = R;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_merge_2xe1of1_slow S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k+1][2*l..2*l+1], M[k][l], _Reset, Reset);
)
)
L = M[K];	// connect inputs
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Depth K alternating merger.  
	Merges to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: expects L.d data low, provides L.e+, R.e can be any.
	Test: alternator-wchb_merge-0{6,7}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint K>
defproc wchb_alternator_merge_2_tree_fast(
		e1of1 L[1<<K], R; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of1 M[1][1];
M[0][0] = R;
(;k:K:
	// build the tree one level at a time
	e1of1 M[k+1..k+1][1<<(k+1)];
	wchb_alternator_merge_2xe1of1_fast S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k+1][2*l..2*l+1], M[k][l], _Reset, Reset);
)
)
L = M[K];	// connect inputs
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Depth K alternating merger for e1ofN channels.  
	Merges to 2^K channels in alternation.  
	Order is funky though.  
	TODO: experiment with self-recursive definition.  
	Reset: expects L.d data low, provides L.e+, R.e can be any.
	Test: alternator-wchb_merge-{10,11}.{hac,prsimrc}
	\param K depth of splitter tree.  K >= 1.
 */
template <pint N, K>
defproc wchb_alternator_merge_2_tree_e1of(
		e1of<N> L[1<<K], R; bool _Reset, Reset) {
// this requires a sparse instantiation to construct a tree
e1of<N> M[1][1];
M[0][0] = R;
(;k:K:
	// build the tree one level at a time
	e1of<N> M[k+1..k+1][1<<(k+1)];
	wchb_alternator_merge_2xe1of<N> S[k..k][1<<k];
(;l:1<<k:
	S[k][l](M[k+1][2*l..2*l+1], M[k][l], _Reset, Reset);
)
)
L = M[K];	// connect inputs
}

//-----------------------------------------------------------------------------
/**
	This is here for amusement, turning a split-alternator
	into a merge-alternator in a messed-up way.  
	Don't use this for anything.  
	\param inc active-high increment request (or active-low ack)
	\param o the 1of2 output.
defproc wchb_alternator_merge_2(a1of1 L[2], R;
		bool _Reset, Reset) {
e1of1 SL, SR[2];
SL.e = R.d[0];
SL.d[0] = R.a;
L[0].d[0] = SR[0].e;
L[0].a = SR[0].d[0];
L[1].d[0] = SR[1].e;
L[1].a = SR[1].d[0];
wchb_alternator_split_2_slow S(SL, SR, _Reset, Reset);
}
 */

//-----------------------------------------------------------------------------
/**
	Tree FIFO.  
	OBSOLETE.  
	Really slow-ass forward latency.  
	Functional, but don't use this.  
	Test: alternator-wchb_tree_fifo-01.{hac,prsimrc}
 */
template <pint K>
defproc wchb_tree_fifo_e1of1_slow(e1of1 L, R; bool _Reset, Reset) {
e1of1 I[1<<K];
wchb_alternator_split_2_tree_slow<K> S(L, I, _Reset, Reset);
wchb_alternator_merge_2_tree_slow<K> M(I, R, _Reset, Reset);
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Tree FIFO.  
	Reset: expect L.d data low, R.e can be any
	Cycle time: 14 T with slow non-CMOS source, 
		10 T with fast CMOS sources (internal handshake limit).  
	Forward latency: L -> R (2K split + 2K merge = 4K T) (fast!)
	Test: alternator-wchb_tree_fifo-0{2,3,4}.{hac,prsimrc}
 */
template <pint K>
defproc wchb_tree_fifo_e1of1_fast(e1of1 L, R; bool _Reset, Reset) {
e1of1 I[1<<K];
wchb_alternator_split_2_tree_fast<K> S(L, I, _Reset, Reset);
wchb_alternator_merge_2_tree_fast<K> M(I, R, _Reset, Reset);
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Tree FIFO of e1ofN channels.  
	Reset: expect L.d data low, R.e can be any
	Cycle time: 14 T with slow CMOS source, 
		10 T with fast CMOS sources (internal handshake limit).  
	Forward latency: L -> R (2K split + 2K merge = 4K T) (fast!)
	Test: alternator-wchb_tree_fifo-0{5,6,7}.{hac,prsimrc}
 */
template <pint N, K>
defproc wchb_tree_fifo_e1of(e1of<N> L, R; bool _Reset, Reset) {
e1of<N> I[1<<K];
wchb_alternator_split_2_tree_e1of<N,K> S(L, I, _Reset, Reset);
wchb_alternator_merge_2_tree_e1of<N,K> M(I, R, _Reset, Reset);
}

//-----------------------------------------------------------------------------

