% "cast2hac/cflat.tex"
%	$Id: cflat.tex,v 1.1 2006/08/14 20:31:53 fang Exp $

\section{Tools}
\label{sec:tools}

The old \CAST\ tools all started with a source processor called
\ttt{cflat} which translated top-level instances into a text stream of the 
flattened representation to be fed into subsequent tools in the toolchain.  
In this section, we describe how to migrate away from some of the tools or 
use the \hac\ front-end as a backward-compatible replacement for \ttt{cflat}.  

The replacement, \ttt{hackt cflat}, features options
similar to those of the original \ttt{cflat}.  
Instead of running \ttt{cflat -<mode> <castfile>}
to produce flattened output, one now can now run
\ttt{hackt cflat <mode> <objfile>}, where \tit{objfile} is a 
compiled \hac\ object file.  

Running \ttt{hackt cflat} with no arguments will produce a list of the various
present modes and format flags available as command-line options.  
All the formats used by the legacy tools come as named presets.  
Further fine-tuning of the output format can be controlled by individual
\ttt{-f <flag>} command-line options.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{PRS Simulation}
\label{sec:tools:prsim}

To produce production rules suitable for simulation with the old 
\ttt{prsim} simulator, simply invoke:
\ttt{hackt cflat prsim <objfile>}, where \tit{objfile} contains compiled
top-level instances and definitions.  
If the object file is not already unrolled and allocated, 
the flattener will automatically do so (possibly catching and 
reporting errors from the later compile phases) before producing
the flattened output.  
The flattener produces a list of all instantiated production rules
and connections in human-readable text, which can be redirected to a file
or piped straight into the old \ttt{prsim}.  

There is also a completely rewritten production rule simulator named
(you guessed it) \ttt{hackt prsim}.  
It emulates the behavior of the old \ttt{prsim} and provides new features.
There (is, will be) a separate document for the new version, 
coming to a documentation directory near you.  
Very little documentation is required because there is a help system
built into the program.  
A list of all commands with one-line descriptions can be browsed
by running \ttt{hackt prsim -h} with no other arguments.  
In the interpreter, help for any command or category can be viewed
by typing \ttt{help <command>} at the prompt.  


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{LVS}
\label{sec:tools:lvs}

There was once a wrapper script named \ttt{cast2lvs} which 
flattened a single instance of a given type in the top-level, 
ignoring all other top-level instances.  
This is particularly useful for being able to LVS definitions and cells
hierchically from the leaf-cells up, facilitating efficient 
layout verification.  
The new mechanism to emulate \ttt{cast2lvs} is to use:
\ttt{hackt cflat lvs -t <type> <objfile>}, 
where \tit{type} is the name of the complete type
(with template arguments, if applicable), and \tit{file} is the object file
containing the compiled definition to unroll.  
The object file need not contain any top-level instances, 
which means it does not need to be unrolled.  
Top-level instances are simple ignored with the \ttt{-t type} option is used.  
Recommendation: redirect the resulting output to a \ttt{.lvsprs} file
or pipe it straight into the old \ttt{lvs} program.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
