% "cast2hac/PRS.tex"
%	$Id: PRS.tex,v 1.3 2006/06/27 02:33:10 fang Exp $

\section{PRS}
\label{sec:prs}

The syntax for normal production rules in the PRS language 
is the same as in \CAST\ and \hac.
See the PRS chapter of the Language Reference \ttt{hac.pdf}.

(Look at examples in \ttt{test/parser/prs}!)

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loop Rules}
\label{sec:prs:looprules}

In \CAST, loops of rules could be written like:

\begin{verbatim}
<i:N:
  ~x[i] | ~z -> y[i]+
>
\end{verbatim}

The enclosing loop syntax is slightly different in \hac.
The above example would be re-written as:

\begin{verbatim}
(:i:N:
  ~x[i] | ~z -> y[i]+
)
\end{verbatim}

Again, rule loops may be nested arbitrarily deep.  
The notation \ttt{:N:} is also equivalent to \ttt{:0..N-1:}.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Conditional Rules}
\label{sec:prs:conditional}

Status: not sure whether or not I completed the implementation...

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loop Expressions}
\label{sec:prs:loopexpr}

In \CAST, one could generalize an operator expression 
in the following manner:

\begin{verbatim}
<&i:N: x[i] >  -> y-
\end{verbatim}

The LHS expression is the conjunction (AND) of nodes 
\ttt{x[0]} through \ttt{x[N-1]}.  
\hac\ also provides an equivalent construct:

\begin{verbatim}
(&i:N: x[i] )  -> y-
\end{verbatim}

The other operator which may be used in a loop expression is \prsor\ (OR).

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Rule Macros}
\label{sec:prs:macros}

Please read this section carefully.  

Macros in PRS may be shorthand for other expanded rules or 
they may mean something different that isn't expressible in
the PRS base language.  
\CAST\ provided some built-in macros into its PRS language, 
which have been relocated into \hac's
\ttt{spec} language (Section~\ref{sec:spec}).  
For example, given \ttt{exclhi(x,y)} in \CAST-PRS 
(not to be confused with \CAST-spec's \ttt{exclhi}), 
the result of \ttt{cflat} would direct \ttt{prsim} to 
force nodes {x,y} to be exclusive high at all times.  
Namely the \ttt{exclhi}, \ttt{excllo} PRS macros have been
renamed as \ttt{mk\_exclhi} and \ttt{mk\_excllo} \emph{spec} directives.  
Q: were there any other PRS macros in \CAST?

\hac\ has added support for emulating unidirectional pass-gates:
\ttt{passn} and \ttt{passp}.
The interpretation of these macros is tool-dependent.  

Developers may define their own PRS macros by following the examples
in the source code.  
Generalized macros also support a syntax for taking parameter values
as arguments in addition to instance references.  
(We refrain from getting into that for this document.)

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Rule Attributes}
\label{sec:prs:ruleattrib}

(I don't know the grammar for rule attributes in \CAST.)
In \hac-PRS, production rules may be tagged with an
arbitrary number of attributes.  

The most common example is the \ttt{after} delay attribute, which
was written in \CAST:

\begin{verbatim}
after 100  p -> q+
\end{verbatim}

which would now be written in \hac:

\begin{verbatim}
[after=100]  p -> q+
\end{verbatim}

Attributes appear as a semicolon-delimited, bracket-enclosed list 
of key-value pairs prefixing the rule.  
An example of multiple attributes:

\begin{verbatim}
[after=100;weak=1]  p -> q+
\end{verbatim}

Attributes that appear before a loop-enclosed rule will apply to
all iterations of the looped rule.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Sized literals}
\label{sec:prs:size}

Status: have yet to add.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Miscellaneous}
\label{sec:prs:misc}

The \hac\ language no longer supports the \ttt{env} sub-language.  

