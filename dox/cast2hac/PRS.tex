% "cast2hac/PRS.tex"
%	$Id: PRS.tex,v 1.4 2006/08/15 20:05:05 fang Exp $

\section{PRS}
\label{sec:prs}

The syntax for normal production rules in the PRS language 
is the same as in \CAST\ and \hac.
See the PRS chapter of the Language Reference \ttt{hac.pdf}.

(Look at examples in \ttt{test/parser/prs}!)

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loop Rules}
\label{sec:prs:looprules}

In \CAST, loops of rules could be written like:

\begin{verbatim}
<i:N:
  ~x[i] | ~z -> y[i]+
>
\end{verbatim}

The enclosing loop syntax is slightly different in \hac.
The above example would be re-written as:

\begin{verbatim}
(:i:N:
  ~x[i] | ~z -> y[i]+
)
\end{verbatim}

Again, rule loops may be nested arbitrarily deep.  
The notation \ttt{:N:} is also equivalent to \ttt{:0..N-1:}.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Conditional Rules}
\label{sec:prs:conditional}

In \CAST, conditional production rules could be written inside
PRS bodies as follows:

\begin{verbatim}
prs {
[pred ->
  x -> y-
]
}
\end{verbatim}

If the predicate \tit{pred} evaluates true during the unroll compile phase, 
then the body is processed, otherwise it is skipped.  
In \hac, the syntax remains unchanged apart from the syntax of
PRS expressions in the predicate.  
\hac\ also allows an optional else clause in the conditional body:

\begin{verbatim}
[pred ->
  x -> y-
[] else ->
  z -> y-
]
\end{verbatim}

\noindent
where in \CAST, one had to explicitly write the predicates complement
in a separate conditional to achieve else-semantics.  

In \CAST, conditional PRS bodies could appear inside instance-level 
conditionals and loops, such as:

\begin{verbatim}
[pred ->
  prs {
    ...
  }
]
\end{verbatim}

\noindent
however, in \hac, language bodies including PRS are forbidden
inside loops and conditionals.  
Use the loop and conditional constructs native to the PRS sub-language.  
Conditional bodies and loops in the PRS may be nested inside each other.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loop Expressions}
\label{sec:prs:loopexpr}

In \CAST, one could generalize an operator expression 
in the following manner:

\begin{verbatim}
<&i:N: x[i] >  -> y-
\end{verbatim}

The LHS expression is the conjunction (AND) of nodes 
\ttt{x[0]} through \ttt{x[N-1]}.  
\hac\ also provides an equivalent construct:

\begin{verbatim}
(&:i:N: x[i] )  -> y-
\end{verbatim}

The other operator which may be used in a loop expression is \prsor\ (OR).

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Rule Macros}
\label{sec:prs:macros}

Please read this section carefully.  

Macros in PRS may be shorthand for other expanded rules or 
they may mean something different that isn't expressible in
the PRS base language.  
\CAST\ provided some built-in macros into its PRS language, 
which have been relocated into \hac's
\ttt{spec} language (Section~\ref{sec:spec}).  
For example, given \ttt{exclhi(x,y)} in \CAST-PRS 
(not to be confused with \CAST-spec's \ttt{exclhi}), 
the result of \ttt{cflat} would direct \ttt{prsim} to 
force nodes {x,y} to be exclusive high at all times.  
Namely the \ttt{exclhi}, \ttt{excllo} PRS macros have been
renamed as \ttt{mk\_exclhi} and \ttt{mk\_excllo} \emph{spec} directives.  
Q: were there any other PRS macros in \CAST?

\hac\ has added support for emulating unidirectional pass-gates:
\ttt{passn} and \ttt{passp}.
The interpretation of these macros is tool-dependent.  

Developers may define their own PRS macros by following the examples
in the source code.  
Generalized macros also support a syntax for taking parameter values
as arguments in addition to instance references.  
(We refrain from getting into that for this document.)

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Rule Attributes}
\label{sec:prs:ruleattrib}

(I don't know the grammar for rule attributes in \CAST.)
In \hac-PRS, production rules may be tagged with an
arbitrary number of attributes.  

The most common example is the \ttt{after} delay attribute, which
was written in \CAST:

\begin{verbatim}
after 100  p -> q+
\end{verbatim}

which would now be written in \hac:

\begin{verbatim}
[after=100]  p -> q+
\end{verbatim}

Attributes appear as a semicolon-delimited, square-bracket-enclosed list 
of key-value pairs prefixing the rule.  
An example of multiple attributes:

\begin{verbatim}
[after=100;weak=1]  p -> q+
\end{verbatim}

Attributes that appear before a loop-enclosed rule will apply to
all iterations of the looped rule.  
The expressions in attributes may be parameter-dependent or 
induction-variable dependent, resulting in different values per iteration.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Sized literals}
\label{sec:prs:size}

Status: supported in syntax, but not used in any back-ends yet.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Miscellaneous}
\label{sec:prs:misc}

The \hac\ language no longer supports the \ttt{env} sub-language.  

