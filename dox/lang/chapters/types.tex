% "chapters/types.tex"

%	$Id: types.tex,v 1.7.54.1 2005/12/13 03:58:24 fang Exp $

\chapter{Types}
\label{sec:types}

In \hac, there are four classes of types to use:
parameters, datatypes, channels, and processes.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parameters}
\label{sec:parameters}

Parameters differ from the others in that they don't correspond
to any physical instances; they are merely user-manipulated values.  
Currently, there are only two (built-in) parameter types: 
\pint, which is an integer value,
and \pbool, which is a boolean value.  

Parameters may be set no more than once, and they must be 
initialized before they are used.  
Using uninitialized parameters is an error.  


We cover templates more in-depth in Chapter~\ref{sec:templates}.  
\hac\ supports parametric types, or templates, much like C++. 
Terminology: a template definition (or just template)
is a parameterized definition.  
User-defined datatypes, channels, and processes may be parameterized.  
Currently the only types that may appear in template signatures
are parameters and arrays thereof.  
Later we may add support for template template arguments, muahahaha.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Definitions}
\label{sec:types:definition}

random notes, please pardon the lack of order...
we really need to re-organize this document, I know.

Consider introducing templates up front...

Describe definition and type-system, bottom-up, from instantiations?

TODO: make the following distinctions:
A physical definition corresponds to the complete description of
a particular implementation.  
Physical definition has its own 
\emph{concrete layout map} 
\index{concrete layout map} 
that translates name (possibly with index) to offset.  
(Users never directly deal with concrete layout maps.)  
Non-template definitions have only one trivially-generated 
concrete layout map.  
Template definitions, however, may have multiple \emph{layout map templates}, 
among which one is selected to generate a concrete layout map for
each instantiation.  
Layout templates are just value- and type-parameterized layout descriptions.  
(Multiple layout templates arise from partial and full specializations; 
a generic template definition contributes one layout template.)


A \emph{type} can either be a reference to a non-template definition
(which may be built-in) or a reference to a template definition
with a set of parameters.  

\textbf{STALE:}
Two (non-template) types are equivalent if and only if 
they refer to the same non-template definition.  
In Chapter~\ref{sec:templates} we extend the notion of type-equivalence
to cover types with templates.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Physical Layout}
\label{sec:types:definition:layout}

Definitions of physical entities invariably contain some table mapping
a logical member or port name to the location of the desired member.  
Such is the typical implementation of data structures in traditional
programming languages.  
Non-template definitions have only one table.  

Chapter~\ref{sec:templates} discusses how templates affects this 
view of structures' layout tables.  
Template definitions introduce \emph{table-templates}
(necessary when members' types and sizes depend on template parameters).  
Each complete template definition (all arguments supplied) 
uses follows one table-template to generate a final layout table.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Names}
\label{sec:types:definition:name}

The \emph{name} of a plain non-template definition refers to the
one definition only.  (OK, that made no sense whatsoever.)
The name of a template definition, however, refers to a \emph{family}
of definitions.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Completeness and Usability}
\label{sec:types:completeness}

In \hac, there are three levels of completeness for definitions.  

\begin{enumerate}
\item A definition is \emph{declared}
	if its template signature (which may be empty) has been defined.  
	Forward declarations of a type only specify the name
	and template parameters, and no other information.  
\item A definition is \emph{signed} if it is declared 
	and its public ports interface (which may be empty) has been defined.  
\item A definition is \emph{defined} if it is signed
	and its body has been defined.  
\end{enumerate}

NOTE: what about definition bindings?

Since type information only refers to template parameters, 
a type may refer to any declared definition.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Instantiation}
\label{sec:types:completeness:instantiation}

An instantiation is the creation of definition into a physical object.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Connection}
\label{sec:types:completeness:connection}

See Chapter~\ref{sec:connections}.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Typedefs}
\label{sec:types:completeness:typedefs}

See Chapter~\ref{sec:typedefs}.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future extensions}
\label{sec:types:future}

Support \ttt{typeof()} operator and \ttt{sizeof()} operator.  


