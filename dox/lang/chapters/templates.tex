% "chapters/templates.tex"

%	$Id: templates.tex,v 1.12 2005/12/13 04:14:42 fang Exp $

\chapter{Templates}
\label{sec:templates}

\begin{flushright}
{\itshape Your quote here.

\bigskip
-- Bjarne Stroustrup
}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terminology}
\label{sec:templates:terms}

\emph{arity} of a template signature is the number of parameters, 
or degrees of freedom.  
Non-template definitions are said to have arity zero.  
Later we will also refer to the arity of template specializations.  
We will use $|A|$ to denote the arity of a template (including specialization).  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Forward declarations}
\label{sec:templates:forward}

Not yet supported.  
The idea is to declare only the template signature of an identifier, 
without declaring its ports.  
Much like the following in C++:

\begin{verbatim}
template <template <int, class> class>
class my_template_class;
\end{verbatim}

\noindent
\verb|my_template_class| is a class that takes a 
class that takes an integer and a class as a template argument 
as a template argument.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Template signature equivalence}
\label{sec:templates:forward:equiv}

The formal parameters of a forward signature are allowed to have identifiers, 
which facilitates latter parameters depending on former parameters.  
Forward declarations are equivalent if the prototype name matches (in the
same namespace) and their template signatures are equivalent.  
The following forward declarations are equivalent (in C++):

\begin{verbatim}
template <int> class foo;
template <int P> class foo;
template <int Q> class foo;
\end{verbatim}

However, only the identifiers used in template class \emph{definitions}
may be referenced from within the definition.  

\begin{verbatim}
template <int R>
class foo {
  /* R may be referenced as the first parameter */
};
\end{verbatim}

Note that nowhere outside of the definition, 
can template parameters be referenced (just as in C++).  
In \hac, one may declare an instance of a declared but undefined type, 
which may not necessarily contain any named parameters.  

\begin{verbatim}
foo<7> bar;
int N = bar.R; // ERROR: no public member named R
\end{verbatim}

Here is an example of equivalent template signatures:

\begin{verbatim}
template <int N, int [N]> ...
template <int N, int A[N]> ...
template <int N, int B[N]> ...
template <int M, int A[M]> ...
template <int M, int B[M]> ...
\end{verbatim}

In all cases, the first parameter must be named because the second
parmeter depends on the first.  
Since nothing else depends on the second parameter, its name is optional.  
Again, only the parameter names used in the definition 
may be referenced from within the definition.  

The same rules in this section (ripped off of C++) pertain to
process, channel, and datatype template definitions in \hac.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Default values}
\label{sec:templates:default}

In C++, default values can only appear as a suffix formal parameter list.  
In \hac, we allow default values in any position of the formal 
parameter list.  
However, each defaulting argument position in a type reference
must be given a placeholder (a blank space between commas), 
even if it is at the end of the argument list.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type-equivalence}
\label{sec:templates:equivalence}

\textbf{NEW:}
In \hac, there are two subclasses of template parameters:
\emph{strict parameters} are required to be equivalent for type-matching,
whereas \emph{relaxed parameters} are ignored when type matching.  
We refer to the \emph{strict type} of an entity as the 
underlying template type with fully-specified strict parameters, 
disregarding its relaxed parameters.  
The rationale for making this distinction is that frequently, 
one wishes to declare sparse or dense collections of the same 
logical type while allowing some internal variation.  
For example, ROM cells hard-wired to $0$ or $1$ are permitted
in the same collection, and would be templated with one relaxed 
parameter for the cell's value\footnote{
The motivation for this comes from the fact that in CAST, 
environment sources could not be arrayed if they differed in values.}.
The user has the freedom to decide what parameters considered relaxed.  

The proposed syntax for distinguishing the two types of parameters is:

\medskip
\noindent
\tit{template-signature}:
\begin{itemize}
\item \ttt{template} \ttt{<} \tit{strict-parameter-list} \ttt{>}
\item \ttt{template} \ttt{<} \tit{strict-parameter-list}$_{opt}$ \ttt{>}
	\ttt{<} \tit{relaxed-parameter-list} \ttt{>}
\end{itemize}
Both parameter lists are syntactically identical.  
When there are no relaxed parameters, the second set of angle-brackets
may be omitted.  
If there are only relaxed paramters, the first set of angle-brackets
are still required but empty.  


There are two levels of type equivalence.  
Two entities are \emph{collection-equivalent} or \emph{collectible}
if their underlying template type is the same and their 
strict parameters are equivalent, 
but not necessarily their relaxed parameters.  
Two entities are \emph{connection-equivalent} or \emph{connectible}
if they are collectible, their relaxed parameters are equivalent, 
and their public interface (port-for-port) is connectible, i.e., 
the dimensions, sizes, and strict types of the ports are themselves, 
connection-equivalent.  
(Note the recursive definition.)
Connectibility implies collectibility, but not vice versa.  

TODO: denotational semantics

\begin{comment}
\textbf{OUTDATED:}
Two templated types are equivalence if and only if:
\begin{itemize}
\item They are of the same type class (channel, process,... ), obviously
\item They refer to the same base definition.  
\item The port types and dimensions are type-equivalent.  
\item Their template arguments are equal.  
\end{itemize}

The third and fourth criteria are not necessary equivalent.  
The ports of a template definition need not depend on template
parameters themselves, as is the case with defining 
cyclic source sequences for a channel.  
\end{comment}

\textbf{DEBATE:} (Resolved, see above: NEW)
Should the fourth criterion be required for type-equivalence, 
or can we allow non-equivalent template parameters as long as the
ports interface is equivalent?  

Implementation issues:
It is not always possible to deduce at compile-time whether
two expressions are equal, thus a compiler may be conservative
and allow non-equivalent types to pass.  
However, at unroll-time, all parameters must be resolved
and type-equivalence can be precisely determined.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Examples}
\label{sec:templates:equivalence:examples}

The following example illustrates how one might describe a ROM array
using relaxed template arguments.

\begin{verbatim}
template <> <pbool VAL>
defproc ROMcell(...) { ... }

template <pint X, Y> <pbool V[X][Y]>
defproc ROMarray(...) {
  ROMcell<> x[X][Y];  // <> is optional
  // can't reference x[i][j].member yet 
  // because instance types are incomplete
  (i:X:
    (j:Y: x[i][j] <V[i][j]> (...); )
  )
  // from here, may reference x[i][j].member
}

ROMarray <2,3>
    <{{false}#{true}#{false}}#
    {{true}#{false}#{true}}>
  a;
\end{verbatim}

This following example shows how one would declare an array of sources
(like for a test environment):

\begin{verbatim}
template <pint N>
defchan e1of (...) {...}

template <pint N> <pint M; pint V[M]>
defproc source_e1of (e1of<N> c) {...}

e1of<4> C[10];
source_e1of<4> CS[10];  // instances' types are incomplete
CS[0] <1, {2}> (C[0]);  // can complete types and connect
CS[1] <3, {2}#{0}#{1}> (C[1]);
CS[2] <2, {1}#{0}> (C[2]);
...
\end{verbatim}

We could have also declared the array of sources with sparse instantiation, 
as long as the strict template arguments match:
\begin{verbatim}
source_e1of<4> <1, {2}> CS[0..0](C[0]);
  // this determines the entire collection's strict parameters
  // but sets the relaxed parameters for only the indexed range
source_e1of<4> <3, {2}#{0}#{1}> CS[1..1](C[1]);
source_e1of<4> <2, {1}#{0}> CS[2..2](C[2]);
...
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type Parameters}
\label{sec:templates:typeparam}

\textbf{NOTE:} This section is in consideration for future extension.  

Up to this point, the template parameters covered are 
\emph{valued} parameters.  
We now introduce \emph{type} parameters.  

Some examples:

\begin{itemize}
\item \ttt{template <datatype D> defproc ...}
\item \ttt{template <chan C> defproc ...}
\item \ttt{template <proc P> defproc ...}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Template Template Parameters}
\label{sec:templates:ttp}

Punt, I mean it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Template Specialization}
\label{sec:templates:spec}

Semantic contraint:
The forward declaration of a general template must precede any declaration
of any specialization with the same family (same name).  

Also partial specializations.  

See Section~\ref{sec:templates:bind} for the complicated issues regarding
template specialization.  

\textbf{RESOLVE:}
Should we impose any restrictions on whether or not template definitions
may be specialized, and if so, where?  

For example: forcing all forward declarations of specializations for 
a particular definition family would solve the problem of 
specialization coherence, but would make such a family of definitions
unextendable for future specializations -- not all specializations
can be declared up-front!  
Implementation consideration:
For definition families consisting of only specializations (genericless),
this can introduce a lot of overhead in having to process specializations
irrelevant to a particular compilation unit.  

Impose constraints on definitions, perhaps some invariant constraints and
relations between generic and specialized definitions?  (e.g. contains same
named instances)  But this would unnecessarily restrict variations in
implementation of certain definitions.  

Forward declarations of specializations.  

\textbf{RESOLVE:}
Do ports of specialized definitions have to match that of the 
generic template definition?  Members certainly need not.  
What are the implications on argument type-checking?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Partial Ordering of Specializations}
\label{sec:templates:partialorder}

Partial and full specializations for a given template definition
may be defined on a partial order.  
Specializations $A$ and $B$ are ordered $A < B$ if and only if
all template parameters that satisfy $A$ also satisfy $B$ and $|A| < |B|$.  
(In English, ...)
If $|A| = |B|$, and $A \neq B$, then $A$ and $B$ are not comparable.  
Examples, please.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Template Argument Deduction}
\label{sec:templates:deduction}

Not having to specify every (or any) template arguments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Definition Bindings}
\label{sec:templates:bind}

Specialization introduces a whole new aspect of complication to the language.  
When a definition is used to instantiate an object, should it be 
instantiated with the best-fit definition seen?  
In C++, the notion of \emph{point-of-instantiation} is used to 
select the definition.  [cite]
Roughly, it says that only definitions that are available (complete)
before the point in the translation unit are considered for instantiation.  
This introduces potential headaches when different translation units
see different available definitions at different points of instantiation, 
i.e. C++ has no mechanism for enforcing consistent use of specializations
across translation units.  
The benefit of compile-time binding of definitions is that type-checking
of template definitions and uses may be done entirely at compile-time
per translation unit.  

\hac\ uses the unroll-phase as the point-of-instantiation for all 
instances, when all instances are bound to their proper definitions.  
The consequence of such a choice is that compile-time type checking
is \emph{very} limited with respect to template definitions.  
[Discuss implementation issues.]

\textbf{RESOLVE:}
Should the following example be accepted or rejected (as a compilation unit)?

\begin{verbatim}
template <pbool B>
defproc foo() { }

foo<true> bar;
bool b = bar.x;
\end{verbatim}

What if another compilation unit provides a specialization for 
\ttt{foo<true>} with a \ttt{bool} member \ttt{x}?

Likewise, consider the following similar example:

\begin{verbatim}
template <pbool B>
defproc foo(bool b) { }

foo<true> bar;
bool b = bar.x;
\end{verbatim}

It is conceivable for a specialization to be defined later without
$b$ as a bool port.  
Should the last connection statement be accepted at compile-time?
If so, does that constrain the specializations that may be introduced later?


\textbf{PROPOSAL:}
A separate bind-phase to allow full type-checking of a compilation unit
(perhaps with references to available definition families).  

\textbf{IDEA:}
Allow introduction of new template specializations that
\emph{do not interfere} with pre-determined bindings.  
Rationale: many full-specializations are introduced for one-time use and
do not interfere with other instantiations' bindings.  

\emph{Binding} an instantiation to a definition is recursive: i.e.
all members and sub-instances of a bound instantiation must already be bound.  
Implementation issue: bind-if-possible to automatically bind dependent
instantiations.  

Implementation option: eager or early binding to force 
definition binding and thus allow type-checking of a 
compilation unit that uses template definitions.  

\textbf{IMPLEMENTATION:}
Is there a need to track the instantiation statements that \emph{used}
particular specializations?  Need to somehow catch inconsistent views
of specializations...

\textbf{BOTTOM LINE:}
Type-references to template definitions MUST have a consistent
view of definitions at instantiation (unroll) time.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future}
\label{sec:templates:future}

Compile-time checking of templates, directives.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
