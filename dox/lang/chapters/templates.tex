% "chapters/templates.tex"

\chapter{Templates}
\label{sec:templates}

\begin{flushright}
{\itshape Your quote here.

\bigskip
-- Bjarne Stroustrup
}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Forward declarations}
\label{sec:templates:forward}

Not yet supported.  
The idea is to declare only the template signature of an identifier, 
without declaring its ports.  
Much like the following in C++:

\begin{verbatim}
template <template <int, class> class>
class my_template_class;
\end{verbatim}

\noindent
\texttt{my\_template\_class} is a class that takes a 
class that takes an integer and a class as a template argument 
as a template argument.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Default values}
\label{sec:templates:default}

In C++, default values can only appear as a suffix formal parameter list.  
In \artxx\ we allow default values in any position of the formal 
parameter list.  
However, each defaulting argument position in a type reference
must be given a placeholder, even if it is at the end of the argument list.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type-equivalence}
\label{sec:templates:equivalence}

Two templated types are equivalence if and only if:
\begin{itemize}
\item They are of the same type class (channel, process,... ), obviously
\item They refer to the same base definition.  
\item The port types and dimensions are type-equivalent.  
\item Their template arguments are equal.  
\end{itemize}

The third and fourth criteria are not necessary equivalent.  
The ports of a template definition need not depend on template
parameters themselves, as is the case with defining 
cyclic source sequences for a channel.  

\textbf{DEBATE:} should the fourth criterion be required for type-equivalence, 
or can we allow non-equivalent template parameters as long as the
ports interface is equivalent?  

Implementation issues:
It is not always possible to deduce at compile-time whether
two expressions are equal, thus a compiler may be conservative
and allow non-equivalent types to pass.  
However, at unroll-time, all parameters must be resolved
and type-equivalence can be precisely determined.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future}
\label{sec:templates:future}

Template template arguments?  (*shudder*)

Template specialization?

Compile-time checking of templates, directives.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
