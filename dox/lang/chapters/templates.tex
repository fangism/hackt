% "chapters/templates.tex"

%	$Id: templates.tex,v 1.5.18.1 2005/01/31 19:37:25 fang Exp $

\chapter{Templates}
\label{sec:templates}

\begin{flushright}
{\itshape Your quote here.

\bigskip
-- Bjarne Stroustrup
}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Forward declarations}
\label{sec:templates:forward}

Not yet supported.  
The idea is to declare only the template signature of an identifier, 
without declaring its ports.  
Much like the following in C++:

\begin{verbatim}
template <template <int, class> class>
class my_template_class;
\end{verbatim}

\noindent
\verb|my_template_class| is a class that takes a 
class that takes an integer and a class as a template argument 
as a template argument.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Template signature equivalence}
\label{sec:templates:forward:equiv}

The formal parameters of a forward signature are allowed to have identifiers, 
which facilitates latter parameters depending on former parameters.  
Forward declarations are equivalent if the prototype name matches (in the
same namespace) and their template signatures are equivalent.  
The following forward declarations are equivalent (in C++):

\begin{verbatim}
template <int> class foo;
template <int P> class foo;
template <int Q> class foo;
\end{verbatim}

However, only the identifiers used in template class \emph{definitions}
may be referenced from within the definition.  

\begin{verbatim}
template <int R>
class foo {
  /* R may be referenced as the first parameter */
};
\end{verbatim}

Note that nowhere outside of the definition, 
can template parameters be referenced (just as in C++).  
In \artxx, one may declare an instance of a declared but undefined type, 
which may not necessarily contain any named parameters.  

\begin{verbatim}
foo<7> bar;
int N = bar.R; // ERROR: no public member named R
\end{verbatim}

Here is an example of equivalent template signatures:

\begin{verbatim}
template <int N, int [N]> ...
template <int N, int A[N]> ...
template <int N, int B[N]> ...
template <int M, int A[M]> ...
template <int M, int B[M]> ...
\end{verbatim}

In all cases, the first parameter must be named because the second
parmeter depends on the first.  
Since nothing else depends on the second parameter, its name is optional.  
Again, only the parameter names used in the definition 
may be referenced from within the definition.  

The same rules in this section (ripped off of C++) pertain to
process, channel, and datatype template definitions in \artxx.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Default values}
\label{sec:templates:default}

In C++, default values can only appear as a suffix formal parameter list.  
In \artxx\ we allow default values in any position of the formal 
parameter list.  
However, each defaulting argument position in a type reference
must be given a placeholder (a blank space between commas), 
even if it is at the end of the argument list.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type-equivalence}
\label{sec:templates:equivalence}

\textbf{NEW:}
In \artxx, there are two subclasses of template parameters:
\emph{strict parameters} are required to be equivalent for type-matching,
whereas \emph{relaxed parameters} are ignored when type matching.  
We refer to the \emph{strict type} of an entity as the 
underlying template type with fully-specified strict parameters, 
disregarding its relaxed parameters.  
The rationale for making this distinction is that frequently, 
one wishes to declare sparse or dense collections of the same 
logical type while allowing some internal variation.  
For example, ROM cells hard-wired to $0$ or $1$ are permitted
in the same collection, and would be templated with one relaxed 
parameter for the cell's value.  
The user has the freedom to decide what parameters may be ignored.  

The proposed syntax for distinguishing the two types of parameters is:

\medskip
\noindent
\tit{template-signature}:
\begin{itemize}
\item \ttt{template} \ttt{<} \tit{strict-parameter-list}$_{opt}$ \ttt{>}
\item \ttt{template} \ttt{<} \tit{strict-parameter-list}$_{opt}$ \ttt{>}
	\ttt{<} \tit{relaxed-parameter-list} \ttt{>}
\end{itemize}
Both parameter lists are syntactically identical.  
When there are no relaxed parameters, the second set of angle-brackets
may be omitted.  
If there are only relaxed paramters, the first set of angle-brackets
are still required but empty.  


There are two levels of type equivalence.  
Two entities are \emph{collection-equivalent} or \emph{collectible}
if their underlying template type is the same and their 
strict parameters are equivalent.  
Two entities are \emph{connection-equivalent} or \emph{connectible}
if they are collectible and their public interface 
(port-for-port) is connectible, i.e., 
the dimensions, sizes, and strict types of the ports are themselves, 
connection-equivalent.  
(Note the recursive definition.)
Connectibility implies collectibility, but not vice versa.  


\textbf{OUTDATED:}
Two templated types are equivalence if and only if:
\begin{itemize}
\item They are of the same type class (channel, process,... ), obviously
\item They refer to the same base definition.  
\item The port types and dimensions are type-equivalent.  
\item Their template arguments are equal.  
\end{itemize}

The third and fourth criteria are not necessary equivalent.  
The ports of a template definition need not depend on template
parameters themselves, as is the case with defining 
cyclic source sequences for a channel.  

\textbf{DEBATE:} (Resolved, see above: NEW)
Should the fourth criterion be required for type-equivalence, 
or can we allow non-equivalent template parameters as long as the
ports interface is equivalent?  

Implementation issues:
It is not always possible to deduce at compile-time whether
two expressions are equal, thus a compiler may be conservative
and allow non-equivalent types to pass.  
However, at unroll-time, all parameters must be resolved
and type-equivalence can be precisely determined.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future}
\label{sec:templates:future}

Template template arguments?  (*shudder*)

Template specialization?

Compile-time checking of templates, directives.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
