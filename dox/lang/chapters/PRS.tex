% "chapters/PRS.tex"

%	$Id: PRS.tex,v 1.6 2006/10/06 03:30:10 fang Exp $

\chapter{Production Rule Set (PRS)}
\label{sec:prs}

This chapter describes the Production Rule Set (PRS) sub-language.  
PRS operates strictly in the meta-language domain of \hac, 
meaning that all involved instance references and connections are resolved
at compile-time, upon instantiation of each complete definition.  
Production rules, like connections, may be programmed to depend
on meta-language parameters.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basics}
\label{sec:prs:basics}

Basic production rules are written as follows:

\begin{itemize}
\item \tit{rule} : \tit{PRS-expr} \prsrarrow\ \tit{node} \tit{dir}
\end{itemize}

(Reference to lines of grammar...)
(Denotational semantics, type-inference later...)

The \tit{dir} is either \prsup\ (pull-up) or \prsdn\ (pull-down).  
A \tit{literal} is an occurence of a (\bool) \tit{node} on the
left-hand-side of a production rule.  
A PRS \tit{literal} and the right-hand-side node
must be a refer to a single (scalar) \bool\ instance.  
A \tit{PRS-expr} may be any boolean expression using the 
operators \prsnot, \prsand, \prsor, and literals.  
(The unary \prsnot\ operator has the highest precedence, 
and the \prsand\ operator has higher precedence than the \prsor\ operator.)

Since production rules are an abstract description of logic, 
the rules themselves need not be CMOS-implementable.  
Enforcement of CMOS-implementability can be introduced by later tools
or compiler phases where desired.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Sizing}
\label{sec:prs:basics:sizing}

We provide a way of specifying transistor widths for every literal.  
Each literal on the LHS may be followed by an optional size argument:

\begin{itemize}
\item \tit{literal} :
	\tit{node-reference} \{ \ttt{<} \tit{float} \ttt{>} \}$_{opt}$
\end{itemize}

Ideas: Specify a width/strength on the RHS and automatically infer
the sizes of the literals on the LHS (only for this rule).  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Attributes}
\label{sec:prs:attrib}

We need a clean way to tag nodes and rules with attributes
for various tools.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Node attributes}
\label{sec:prs:attrib:node}

What happens when we connect nodes with conflicting attributes?

Attributes from super-cells or sub-cells?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Rule attributes}
\label{sec:prs:attrib:rule}

We propose the following syntax for per-rule attributes:
\begin{itemize}
\item	\tit{rule-attrib-list} : \ttt{[} \tit{rule-attrib} \ttt{;} ... \ttt{]}
\item	\tit{rule-attrib} : \tit{identifier} \ttt{=} \tit{expr-list}
\end{itemize}

\tit{Rule-attribs} are generalized as key-value(s) pairs, which permits
the programmer to add arbitrary attributes to the language without
adding more keywords to the language.  
\tit{Rule-attrib-list}s are just semicolon-delimited lists of one or more
rule-attributes.  
In the case of repeated attributes, the latter pair will override the former.  
Rule-attribute-lists are optional prefixes to PRS-rules.  

For now, the purpose of these attributes is to emit
attribute lines suitable for consumption by another text-based tool, 
such as old versions of \ttt{prsim}.  

Q:
What happens when we OR-combine rules with different attributes?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Literal attributes}
\label{sec:prs:attrib:literal}

The literals of the rule expressions may have attributes.  

Mostly tool-specific use.

Most common use: transistor sizing.  
Also: for LVS.  

Instance-specific attributes?
Procedural layout?

Automatic sizing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Loops}
\label{sec:prs:loops}

Loop syntax, unrolling, etc...

Loops can appear in expressions and in rules in the PRS language.  
A \tit{rule-loop} can be written as:

\begin{itemize}
\item \ttt{(:} \tit{loop-var} \ttt{:} \tit{range} \ttt{:}
	\tit{rules} \ttt{)}
\end{itemize}

The \tit{loop-var} is declared with a identifier, and may be referenced
in the body rules.  
The rule-loop is repeatedly expanded using the values spanned
by the \tit{range}.  
(The range may be written implicitly or explicitly.)
If the range evaluates empty, then the body is skipped during unrolling.  
Rule-loops may be nested, i.e., they may contain other loops.  

An expression-loop is written as:
\begin{itemize}
\item \ttt{(} \tit{op} \ttt{:} \tit{loop-var} \ttt{:} \tit{range} \ttt{:}
	\tit{PRS-expr} \ttt{)}
\end{itemize}
The \tit{loop-var} and \tit{range} have the same meanings as when used
in rule-loops.  
\tit{op} may be \prsand\ or \prsor.  
The body expression is repeatedly expanded with the \tit{op} operator.  
Expression-loops may be nested, i.e., they may contain other expression-loops.  
If the range evaluates empty, ...
\tbf{we need to specify these semantics}!

Interpret the following:
\begin{itemize}
\item \ttt{(\prsand:i:0: x[i]) \prsrarrow y-}
\item \ttt{(\prsor:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsand (\prsand:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsand (\prsor:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsor (\prsand:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsor (\prsor:i:0: x[i]) \prsrarrow y-}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions}
\label{sec:prs:ext}

This section describes some of the recent extensions to the PRS language.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Macros}
\label{sec:prs:macros}

As an alternative to a PRS-rule, one may write a macro to represent
some custom topology of a netlist or as shorthand for an expansion.  

We propose the following syntax for macros:

\begin{itemize}
\item \tit{PRS-macro} : \tit{identifier} \ttt{<} \tit{expr-list} \ttt{>} \ttt{(} \tit{PRS-literal-list} \ttt{)}
\item \tit{PRS-macro} : \tit{identifier} \ttt{(} \tit{PRS-literal-list} \ttt{)}
\end{itemize}

We do not hard-code any built-in macros into the language with keywords, 
rather we allow the programmer to define the meaning of each macro.  
Macros can also take parameters inside angle-brackets, 
where the \tit{expr-list} is a list of comma-separated expressions.  
The number of arguments for a macro may also be variable, 
and is defined by the macro's implementation.  
The macro mechanism can potentially be used to attach attributes
to nodes and other subnets.  
As the list of macros grows, they should be documented here.  

Examples of macros one may wish to define:
\begin{itemize}
\item \ttt{passn} --- \tit{<W,L>(g,s,d)} $W$ is an optional transistor width, 
	$L$ is an optional length.  If only one parameter is passed, 
	it is interpreted as the width.  $g$, $s$, $d$ are the
	gate, source, and drain, respectively.  
	The pseudo production rule generated (\ttt{cflat prsim}) 
	is \emph{uni-directional}, i.e. the drain is driven as the output.  
\item \ttt{passp} --- analogous to \ttt{passn}
\item \ttt{pass} --- full symmetric pass-gate
\item \ttt{assert}
\item \ttt{stat}
\item \ttt{comb-fb}
\end{itemize}

The remaining sections discuss other extensions that have been proposed
at other times.  
See which ones could be folded into a general macro!

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Pass-gates}
\label{sec:prs:ext:passgates}

True pass-gate logic was missing from the original CAST-PRS implementation.  
A pass-gate could be emulated as a latch if the `direction' of operation was
known at compile time.  
Not having to support pass-gates greatly simplified other pieces of the 
tool-chain, such as LVS and PRSIM.  

We propose the following syntax for pass-gates:

\begin{enumerate}
\item $node_1$ \ttt{<-} $node_2$ \ttt{->} $node_3$\\
	denotes an NFET connecting $node_1$ and $node_3$ gated by $node_2$
\item $node_1$ \ttt{<+} $node_2$ \ttt{+>} $node_3$\\
	denotes a PFET connecting $node_1$ and $node_3$ gated by $node_2$
% \item $node_1$ \ttt{<=} $node_2$ \ttt{=>} $node_3$\\
%	denotes an NFET connecting $node_1$ and $node_3$ gated by $node_2$
%	with a PFET gated by $\overline{node_2}$
\end{enumerate}

% In all cases, $node_2$ may be a literal node or its complement, 
% prefixed with a tilde.
$node_{1...3}$ are production rule literals.  
In case 1, when $node_2$ is logic-1, the nodes on either side are connected.
In case 2, when $node_2$ is logic-0, the other terminals are connected.  
$node_2$ may be given an optional size to specify the 
width of the transmission-gate.  
In all cases, 
if nodes on opposite sides are both driving in opposite directions, 
then it is considered a short-circuit (error).  
If neither side is driving, and the nodes' states are in opposition, 
then both nodes will become unknown (X). 
Otherwise, the one side that is being driven will flip the other side.  

$node_2$ may be given an optional \ttt{<size>} argument for specifying
gate width.  

Technically, one may use pass-gate to construct arbitrary transistor
topologies.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Options}
\label{sec:prs:options}

Compiler warnings:

CMOS-implementability (exceptions allowed for attribute).  

Staticizers?

