% "chapters/PRS.tex"

%	$Id: PRS.tex,v 1.2.30.1 2005/10/25 04:18:56 fang Exp $

\chapter{Production Rule Set (PRS)}
\label{sec:prs}

This chapter describes the Production Rule Set (PRS) sub-language.  
PRS operates strictly in the meta-language domain of \artxx, 
meaning that all involved instance references and connections are resolved
at compile-time, upon instantiation of each complete definition.  
Production rules, like connections, may be programmed to depend
on meta-language parameters.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basics}
\label{sec:prs:basics}

Basic production rules are written as follows:

\begin{itemize}
\item \tit{rule} : \tit{PRS-expr} \prsrarrow\ \tit{node} \tit{dir}
\end{itemize}

(Reference to lines of grammar...)
(Denotational semantics, type-inference later...)

The \tit{dir} is either \prsup\ (pull-up) or \prsdn\ (pull-down).  
A \tit{literal} is an occurence of a (\bool) \tit{node} on the
left-hand-side of a production rule.  
A PRS \tit{literal} and the right-hand-side node
must be a refer to a single (scalar) \bool\ instance.  
A \tit{PRS-expr} may be any boolean expression using the 
operators \prsnot, \prsand, \prsor, and literals.  
(The unary \prsnot\ operator has the highest precedence, 
and the \prsand\ operator has higher precedence than the \prsor\ operator.)

Since production rules are an abstract description of logic, 
the rules themselves need not be CMOS-implementable.  
Enforcement of CMOS-implementability can be introduced by later tools
or compiler phases where desired.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Sizing}
\label{sec:prs:basics:sizing}

We provide a way of specifying transistor widths for every literal.  
Each literal on the LHS may be followed by an optional size argument:

\begin{itemize}
\item \tit{literal} :
	\tit{node-reference} \{ \ttt{<} \tit{float} \ttt{>} \}$_{opt}$
\end{itemize}

Ideas: Specify a width/strength on the RHS and automatically infer
the sizes of the literals on the LHS (only for this rule).  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Attributes}
\label{sec:prs:attrib}

We need a clean way to tag nodes and rules with attributes
for various tools.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Node attributes}
\label{sec:prs:attrib:node}

What happens when we connect nodes with conflicting attributes?

Attributes from super-cells or sub-cells?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Rule attributes}
\label{sec:prs:attrib:rule}

What happens when we OR-combine rules with different attributes?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Literal attributes}
\label{sec:prs:attrib:literal}

The literals of the rule expressions may have attributes.  

Mostly tool-specific use.

Most common use: transistor sizing.  
Also: for LVS.  

Instance-specific attributes?
Procedural layout?

Automatic sizing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Loops}
\label{sec:prs:loops}

Loop syntax, unrolling, etc...

Loops can appear in expressions and in rules in the PRS language.  
A \tit{rule-loop} can be written as:

\begin{itemize}
\item \ttt{(:} \tit{loop-var} \ttt{:} \tit{range} \ttt{:}
	\tit{rules} \ttt{)}
\end{itemize}

The \tit{loop-var} is declared with a identifier, and may be referenced
in the body rules.  
The rule-loop is repeatedly expanded using the values spanned
by the \tit{range}.  
(The range may be written implicitly or explicitly.)
If the range evaluates empty, then the body is skipped during unrolling.  
Rule-loops may be nested, i.e., they may contain other loops.  

An expression-loop is written as:
\begin{itemize}
\item \ttt{(} \tit{op} \ttt{:} \tit{loop-var} \ttt{:} \tit{range} \ttt{:}
	\tit{PRS-expr} \ttt{)}
\end{itemize}
The \tit{loop-var} and \tit{range} have the same meanings as when used
in rule-loops.  
\tit{op} may be \prsand\ or \prsor.  
The body expression is repeatedly expanded with the \tit{op} operator.  
Expression-loops may be nested, i.e., they may contain other expression-loops.  
If the range evaluates empty, ...
\tbf{we need to specify these semantics}!

Interpret the following:
\begin{itemize}
\item \ttt{(\prsand:i:0: x[i]) \prsrarrow y-}
\item \ttt{(\prsor:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsand (\prsand:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsand (\prsor:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsor (\prsand:i:0: x[i]) \prsrarrow y-}
\item \ttt{z \prsor (\prsor:i:0: x[i]) \prsrarrow y-}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions}
\label{sec:prs:ext}

This section describes some of the recent extensions to the PRS language.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Pass-gates}
\label{sec:prs:ext:passgates}

True pass-gate logic was missing from the original CAST-PRS implementation.  
A pass-gate could be emulated as a latch if the `direction' of operation was
known at compile time.  
Not having to support pass-gates greatly simplified other pieces of the 
tool-chain, such as LVS and PRSIM.  

We propose the following syntax for pass-gates:

\begin{enumerate}
\item $node_1$ \ttt{<-} $node_2$ \ttt{->} $node_3$\\
	denotes an NFET connecting $node_1$ and $node_3$ gated by $node_2$
\item $node_1$ \ttt{<+} $node_2$ \ttt{+>} $node_3$\\
	denotes a PFET connecting $node_1$ and $node_3$ gated by $node_2$
% \item $node_1$ \ttt{<=} $node_2$ \ttt{=>} $node_3$\\
%	denotes an NFET connecting $node_1$ and $node_3$ gated by $node_2$
%	with a PFET gated by $\overline{node_2}$
\end{enumerate}

% In all cases, $node_2$ may be a literal node or its complement, 
% prefixed with a tilde.
$node_{1...3}$ are production rule literals.  
In case 1, when $node_2$ is logic-1, the nodes on either side are connected.
In case 2, when $node_2$ is logic-0, the other terminals are connected.  
$node_2$ may be given an optional size to specify the 
width of the transmission-gate.  
In all cases, 
if nodes on opposite sides are both driving in opposite directions, 
then it is considered a short-circuit (error).  
If neither side is driving, and the nodes' states are in opposition, 
then both nodes will become unknown (X). 
Otherwise, the one side that is being driven will flip the other side.  

$node_2$ may be given an optional \ttt{<size>} argument for specifying
gate width.  

Technically, one may use pass-gate to construct arbitrary transistor
topologies.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Options}
\label{sec:prs:options}

Compiler warnings:

CMOS-implementability (exceptions allowed for attribute).  

Staticizers?

