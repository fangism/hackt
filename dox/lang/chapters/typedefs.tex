% "chapters/typedefs.tex"

\chapter{Typedefs}
\label{sec:typedefs}

When and where are typedefs useful?  
Where may typedefs appear?
Can be in namespace, or local to a definition.  

Two kinds of typedefs, with three syntaces.  

\begin{enumerate}
\item \ttt{typedef} \tit{existing-definition} \tit{identifier}\ttt{;}
\item \ttt{typedef} \tit{existing-definition} 
	\ttt{<} \tit{template argument list} \ttt{>} \tit{identifier}\ttt{;}
\item \ttt{template} \ttt{<} \tit{template-signature} \ttt{>}\\
	\ttt{typedef} \tit{existing-definition} 
	\ttt{<} \tit{template-argument-list} \ttt{>} \tit{identifier}\ttt{;}
\end{enumerate}

In all three forms the \tit{identifier} is the name of the new
typedef.  
The only prerequisite for the existing definition is that it has already 
been declared.  

The first form is a pseudo-typedef, a pure \emph{definition} name alias, 
as if one had written 
\ttt{\#define} \tit{identifier} \tit{existing-definition} in C-preprocessing, 
with the existing defininition being a simple identifier.  
The potential confusion with the first typedef is that 
\tit{existing-definition} identifier may be mistaken for a templated type
with all parameter arguments with defaults 
(the only condition in which template arguments 
may be omitted from a templated definition).  

The second form of typedef substitutes a fully-specified template type
(one with all template parameters supplied) with an identifier.  
This is convenient for reusing a templated type repeatedly without
having to copy the arguments.  

The third form of typedef is a template typedef (not yet supported in C++)
which wraps a partially-specified template type with a new definition, 
usually (not always) with fewer arguments.  
This is particularly useful for binding template arguments
to make simple template types.  
If a definition doesn't already have default arguments, 
this is one way of supplying additional default values 
for an existing templated definition.  

Typedefs can be defined in terms of other typedefs.  
There is currently no restriction on the number of indirections
of typedef-ing.  

By construction, the graph of typedef definitions must form a tree,
and thus, cannot have cycles.  
Ultimately, every typedef must be defined in terms of a 
unique non-typedef \emph{canonical definition}\index{canonical definition}.  
The \emph{canonical parameters} are the values of the 
parameters that are eventually passed to the canonical definition, 
and are evaluated by the transformations defined by each typedef indirection.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type-equivalence}
\label{sec:typedefs:equivalence}

\index{type-equivalence|(}

We extend the notion of \emph{type-equivalence} to include typedefs as follows:

Two instances of typedefs are type-equivalent if and only if
they refer to the same canonical definition, and their canonical 
parameters are equal.  

Some implementation hints.
Given two typedef instances or references.  
Find greatest common ancestor.  
Common ancestor may simplify equivalence deduction.  

\index{type-equivalence|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Questions}
\label{sec:typedefs:questions}

\textbf{Forward declarations.}
Can typedefs have forward declarations?  Should we allow this?  Rather not.
``I'm declaring this typedef's name, but it's definition will be bound
later...''
Beware of typedef cycles!

Can typedefs have external linkage?  Can cycles form?
But what class of type is it: channel, process?
e.g. \ttt{extern typedef foo;}

\ttt{extern template <...> typedef foo;}

\ttt{extern typedef old new;}

\medskip
\textbf{Linkage.}  See Chapter~\ref{sec:linkage}.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

