% "chapters/CHP.tex"

%	$Id: CHP.tex,v 1.5 2007/01/21 05:58:05 fang Exp $

\chapter{Communicating Hardware Processes}
\label{sec:chp}

This chapter describes the CHP sub-language, which is based on
Hoare's CSP~\cite{ref:csp}.  
CHP operates in the non-meta language domain of \hac, 
meaning that the instances and values referenced may be
resolved at compile-time, even after instantiation.  
In fact, most values and references are only resolved at run-time.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions}
\label{sec:chp:expr}

This section describes the kinds of expressions that CHP supports.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Value References}
\label{sec:chp:expr:values}

CHP describes the computation and communication of data variables
over channels.  
Since CHP describes the run-time behavior of programs, 
the values referenced are only resolved at run-time, 
just like in a traditional C program.  
The data-types referenced may \bool, \int, enums, or user-defined (structs)
(Chapter~\ref{sec:datatypes}).  

The indices used to address values may themselves be run-time variables.  
For example, in \ttt{x[i]}, \ttt{i} may be an \int\ received over a channel.  
Operationally, this means we need run-time array bounds checks on indices, 
and existence checks in the case of sparse arrays.  

In CHP, \pint s are considered \int\ttt{<32>} values and
\pbool s are considered \bool values as far as type-checking is concerned.  
(Proposal: support for wildcard (automatic) widths when interpreting
\pint\ as \int.)  

Note: the current implementation does not \emph{yet} support ranged
references (\ttt{x[i..j]}). 
We don't expect this to be difficult, but implementation will be deferred
until this feature is warranted.  

UPDATE: nonmeta languages, including CHP, no longer support 
aggregate instance or value references.  
This means meta-valued ranges cannot appear in any nonmeta language.  
Nor can implicit non-scalar collection references appear in nonmeta language.  
Simply put, all references in nonmeta languages must be scalar
(0-dimensional).  

Arbitrarily complex indexed and member references
are supported in the nonmeta languages, such as CHP.
However, it is up to the downstream toolchain to interpret or 
impose further restrictions on the references. 
For example, a reference such as \ttt{x[pi][j].y[k]}, where
\ttt{pi} is a meta-valued index and \ttt{j} and \ttt{k} are nonmeta
valued integers could lead to a very difficult synthesis or analysis.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Operators}
\label{sec:chp:expr:ops}

Standard binary arithmetic operations.  
Tentative type restriction: operands must be of equal \int\ width.  
Return type is the same as operands.  

Old CAST-style syntax for boolean logic operations.  

Proposal: use C-style syntax so we may distinguish bitwise from 
logical operations.  

Proposal: operator overloading to define arithmetic on user-defined types.  
(Then we could call this a Hierarchical Operator-Overloading Object-Oriented
Circuit Description Language, or HOOOORCD.)
Low priority.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Bit Slices}
\label{sec:chp:expr:bits}

TODO: add support for bit slices.  
Add public bit-array ports to the intrinsic \int\ definition.  
Add a built-in (private) type for bits.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Channels}
\label{sec:chp:channels}

Chapter~\ref{sec:channels} presented the notion of channels
in the context of general nonmeta languages.  

We (provisionally) stated that the fundamental channel types, 
such as \ttt{chan(bool)}, were abstract in that they describe
\emph{what} information was communicated over a channel, 
but not \emph{how} (encoding and protocol).  

As far as the CHP level is concerned, 
the implementation is irrelevant (?) to the 
concurrent program semantics and functional behavior (and simulation).  

Where does the implementation come into play?
In automatic production-rule generation and mixed-level simuation
involving production rule details.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statements}
\label{sec:chp:stmts}

This section describes the various statements that CHP supports.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Communications}
\label{sec:chp:stmts:comm}

To receive data over a channel, one simply writes: 

\begin{itemize}
\item \tit{CHP-receive} : \tit{channel-reference} \query
	\ttt{(} \tit{data-reference-list} \ttt{)}
\end{itemize}

\noindent
For example, \ttt{X?(x, w)} means: receive values $x$ and $w$ over
the two fields of channel $X$.  

To send data over a channel, one writes:

\begin{itemize}
\item \tit{CHP-send} : \tit{channel-reference} \bang
	\ttt{(} \tit{nonmeta-expr-list} \ttt{)}
\end{itemize}

\noindent
For example, \ttt{Y!(y, z)} means: send values $y$ and $z$ over
the two fields of channel $Y$.  

The channels referenced in sends and receives may be 
either fundamental channel types or user-defined channel types.  
However, the channel reference must be scalar (0-dimensional).  
The variables in the reference list or expression list must type-check
against the fields of the underlying fundamental channel type.  
Please refer to Section~\ref{sec:channels:fundamental} 
regarding fundamental channel types.  
If any types are template-parameter dependent, then type-checking
is deferred until the template types have been instantiated.  

Operational semantics:
Sends and receives in CHP have blocking semantics, i.e., 
a communication does not complete until its complement (the other side)
is also reached.  
After both sides of the communication have `synchronized,'
can the communication proceed.  

Execution clarification:
Suppose we have the statement \ttt{X[i]!(y[j])}, where \ttt{i} and \ttt{j}
are nonmeta (run-time) variables.  
If we reach this program point, and find that \ttt{X[i]} is blocked
(not ready to send), then we must suspend further execution until
one of the following conditions changes:
\begin{itemize}
\item \ttt{X[k]} receive executes for \emph{some} value \ttt{k}
\item \ttt{i} changes the reference to a different channel
\end{itemize}
If we were to be precise, and track dependencies dynamically 
(rather than conservatively and statically), 
we could narrow the first conditional to only \ttt{X[i]} receiving.  
Only at the time of execution,
do we evaluate the value of \ttt{y[j]} for sending.  
The value and reference of \ttt{y[j]} is \emph{permitted to change} between
the time it is blocked and the time the communication is executed!
(Can we trap or alert when this is not intended?)

TODO: Probes

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Assignments}
\label{sec:chp:stmts:assign}

The syntax for a variable assignment is simple:

\begin{itemize}
\item \tit{CHP-assignment} : \tit{lvalue} \assign\ \tit{rvalue}
\end{itemize}

\noindent
For example, \ttt{x := y} assigns the value of $y$ to $x$.  
The \emph{lvalue} must refer to a scalar instance of a data type, 
while the \emph{rvalue} may be any (nonmeta) expression.  
The types for \emph{lvalue} and \emph{rvalue} must match.  

Execution: just assign the current value of the rvalue to the lvalue.
Assignments are atomic, so we need not consider changing references.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Wait}
\label{sec:chp:stmts:wait}

When a wait statement is reached, the program simply waits for a condition
to become true before proceeding.  

\begin{itemize}
\item \tit{CHP-wait} : \ttt{[} \tit{CHP-expr} \ttt{]}
\end{itemize}

The expression must, of course, be boolean in value.  

Execution: 
When arriving at a wait event, evaluate the guard expresions.
If true, then proceed immediately to the event that follows. 
Otherwise, block this event pending any change on variables or channels
that could possibly change the value of the expression.  
In implementation, the set may be precise or conservative, but 
the resulting evaluation must remain equivalent.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Composition}
\label{sec:chp:stmts:comp}

CHP statements may be composed either sequentially or concurrently.  

\begin{itemize}
\item \tit{CHP-sequence} : \tit{CHP-stmt} \seq\ \tit{CHP-stmt} ...
\item \tit{CHP-concurrence} : \tit{CHP-stmt} \concur\ \tit{CHP-stmt} ...
\end{itemize}

Concurrent composition has higher precedence than sequential composition, 
so $X,Y;Z$ is interpreted as $(X,Y);Z$.  
However, one may explictly parenthesize $X,(Y;Z)$.  

Execution of concurrent branches behaves like a fork and join (barrier).
Upon initial execution, each branch is begun concurently, 
but the execution is not completely until all branches have reached
the join-barrier.  
(This can be easily implemented as a decrementing barrier counter.)

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Skip}
\label{sec:chp:stmts:skip}

Skipping this section...

Note on syntax: A skip statement may only appear by itself in a 
CHP body, i.e. never in a sequential or concurrent composition.  
It may appear in-place of any \tit{CHP-stmt-list}.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Flow Control}
\label{sec:chp:flow}

This section describes the various flow control statements available in CHP.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loops}
\label{sec:chp:flow:loop}

Loops never end.  
Most hardware one will describe with CHP will contain a loop.  
(What good is a program that only works once?)

\begin{itemize}
\item \tit{CHP-loop} : \chpbeginloop\ \tit{CHP-stmt-list} \chpendloop
\end{itemize}

Execution: after the last action in the loop executes, schedule
the first action for execution.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Guarded Commands}
\label{sec:chp:flow:guardedcmd}

\begin{itemize}
\item \tit{CHP-guarded-command} : \tit{CHP-expr} \prsrarrow\ \tit{CHP-stmt-list}
\end{itemize}

A special case of a guarded commands is an else-clause, 
which replaces the guard expression with the keyword \ttt{else}.  
An else clause may only appear at the end of deterministic selections, 
but not any other selection statements.  

Execution: 
Interpretation depends on the context in which the guarded command appears, 
e.g. deterministic vs. nondeterministic selection, or do-while loops.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Deterministic Selection}
\label{sec:chp:flow:detsel}

\begin{itemize}
\item \tit{CHP-det-selection} :
	\lbracket\ \tit{CHP-det-guarded-command-list} \rbracket
\item \tit{CHP-det-guarded-command-list} :
	\tit{CHP-guarded-command} \thickbar\ ...
\end{itemize}

The guarded command list must contain at least two guarded commands
(else it's not a selection).  
The last guarded statement may be an else clause.  

Operational Semantics: 
(Basically exclusive switch-case.)
Only one of the guards is allowed to be true at a time (mutual exclusion).  
If more than one guard is ever true, then there is an error in the program.  
A deterministic selection blocks until one of its guards has become true
and its guarded commands executed.  

Execution: 
Since branches are executed mutually exclusively, as soon as any branch
finishes executing its last event, the events that immediately follow 
the selection may be processes as if in the same sequence.  
If at any time more than one guard evaluates true, a diagnostic is
required, though signaling and error is recommended.  

If initially none of the guards evaluate true, 
then the selection is blocked until one of them becomes true.  
(This can be accomplished by registering all dependent variables
on a global watch-list.  
When any variable on the watch-list changes status, then subscribed
expressions are re-evaluated, to see if new events may be scheduled.)

If the guards include an else-clause, then this selection never blocks, 
because the else-clause will guarantee that one clause will execute.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Nondeterministic Selection}
\label{sec:chp:flow:nondetsel}

\begin{itemize}
\item \tit{CHP-nondet-selection} :
	\lbracket\ \tit{CHP-nondet-guarded-command-list} \rbracket
\item \tit{CHP-nondet-guarded-command-list} :
	\tit{CHP-guarded-command} \thinbar\ ...
\end{itemize}
% just realized reading the above can be confusing, overloaded ':'

Note: for the sake of a cleaner grammar, 
we use \thinbar\ instead of \oldthinbar\ to denote 
a nondeterministic selection.  
Can nondeterministic selections contain else-clauses?

Operational Semantics: nondeterministic selection blocks until at least
one guard becomes true.  
While any number of guards may be true, one of the true guards is 
chosen arbitrarily\footnote{Weakly fair.} as the path of execution.  

Execution:
More than one guard is allowed to be true, but only branch is chosen
to be executed.  
Q: Do we use the notion of a time-window before evaluating guards?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Do-While}
\label{sec:chp:flow:dowhile}

\begin{itemize}
\item \tit{CHP-det-selection} :
	\chpbeginloop\ \tit{CHP-det-guarded-command-list} \chpendloop
\end{itemize}

No else clauses allowed.  

Operational Semantics:
Loop until all guards are false.  

Execution:
Never blocks because there is an implicit else-clause that
skips/exits the loop.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions}
\label{sec:chp:ext}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{C and C++ Routines}
\label{sec:chp:ext:c}

Calling C/C++ functions.  

