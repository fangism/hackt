% "chapters/CHP.tex"

%	$Id: CHP.tex,v 1.4 2006/06/28 22:17:38 fang Exp $

\chapter{Communicating Hardware Processes}
\label{sec:chp}

This chapter describes the CHP sub-language, which is based on
Hoare's CSP~\cite{ref:csp}.  
CHP operates in the non-meta language domain of \hac, 
meaning that the instances and values referenced may be
resolved at compile-time, even after instantiation.  
In fact, most values and references are only resolved at run-time.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions}
\label{sec:chp:expr}

This section describes the kinds of expressions that CHP supports.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Value References}
\label{sec:chp:expr:values}

CHP describes the computation and communication of data variables
over channels.  
Since CHP describes the run-time behavior of programs, 
the values referenced are only resolved at run-time, 
just like in a traditional C program.  
The data-types referenced may \bool, \int, enums, or user-defined (structs)
(Chapter~\ref{sec:datatypes}).  

The indices used to address values may themselves be run-time variables.  
For example, in \ttt{x[i]}, \ttt{i} may be an \int\ received over a channel.  
Operationally, this means we need run-time array bounds checks on indices, 
and existence checks in the case of sparse arrays.  

In CHP, \pint s are considered \int\ttt{<32>} values and
\pbool s are considered \bool values as far as type-checking is concerned.  
(Proposal: support for wildcard (automatic) widths when interpreting
\pint\ as \int.)  

Note: the current implementation does not \emph{yet} support ranged
references (\ttt{x[i..j]}). 
We don't expect this to be difficult, but implementation will be deferred
until this feature is warranted.  

UPDATE: nonmeta languages, including CHP, no longer support 
aggregate instance or value references.  
This means meta-valued ranges cannot appear in any nonmeta language.  
Nor can implicit non-scalar collection references appear in nonmeta language.  
Simply put, all references in nonmeta languages must be scalar
(0-dimensional).  

Arbitrarily complex indexed and member references
are supported in the nonmeta languages, such as CHP.
However, it is up to the downstream toolchain to interpret or 
impose further restrictions on the references. 
For example, a reference such as \ttt{x[pi][j].y[k]}, where
\ttt{pi} is a meta-valued index and \ttt{j} and \ttt{k} are nonmeta
valued integers could lead to a very difficult synthesis or analysis.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Operators}
\label{sec:chp:expr:ops}

Standard binary arithmetic operations.  
Tentative type restriction: operands must be of equal \int\ width.  
Return type is the same as operands.  

Old CAST-style syntax for boolean logic operations.  

Proposal: use C-style syntax so we may distinguish bitwise from 
logical operations.  

Proposal: operator overloading to define arithmetic on user-defined types.  
(Then we could call this a Hierarchical Operator-Overloading Object-Oriented
Circuit Description Language, or HOOOORCD.)
Low priority.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Bit Slices}
\label{sec:chp:expr:bits}

TODO: add support for bit slices.  
Add public bit-array ports to the intrinsic \int\ definition.  
Add a built-in (private) type for bits.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Channels}
\label{sec:chp:channels}

Chapter~\ref{sec:channels} presented the notion of channels
in the context of general nonmeta languages.  

We (provisionally) stated that the fundamental channel types, 
such as \ttt{chan(bool)}, were abstract in that they describe
\emph{what} information was communicated over a channel, 
but not \emph{how} (encoding and protocol).  

As far as the CHP level is concerned, 
the implementation is irrelevant (?) to the 
concurrent program semantics and functional behavior (and simulation).  

Where does the implementation come into play?
In automatic production-rule generation and mixed-level simuation
involving production rule details.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statements}
\label{sec:chp:stmts}

This section describes the various statements that CHP supports.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Communications}
\label{sec:chp:stmts:comm}

To receive data over a channel, one simply writes: 

\begin{itemize}
\item \tit{CHP-receive} : \tit{channel-reference} \query
	\ttt{(} \tit{data-reference-list} \ttt{)}
\end{itemize}

\noindent
For example, \ttt{X?(x, w)} means: receive values $x$ and $w$ over
the two fields of channel $X$.  

To send data over a channel, one writes:

\begin{itemize}
\item \tit{CHP-send} : \tit{channel-reference} \bang
	\ttt{(} \tit{nonmeta-expr-list} \ttt{)}
\end{itemize}

\noindent
For example, \ttt{Y!(y, z)} means: send values $y$ and $z$ over
the two fields of channel $Y$.  

The channels referenced in sends and receives may be 
either fundamental channel types or user-defined channel types.  
However, the channel reference must be scalar (0-dimensional).  
The variables in the reference list or expression list must type-check
against the fields of the underlying fundamental channel type.  
Please refer to Section~\ref{sec:channels:fundamental} 
regarding fundamental channel types.  
If any types are template-parameter dependent, then type-checking
is deferred until the template types have been instantiated.  

Operational semantics:
Sends and receives in CHP have blocking semantics, i.e., 
a communication does not complete until its complement (the other side)
is also reached.  
After both sides of the communication have `synchronized,'
can the communication proceed.  

TODO: Probes

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Assignments}
\label{sec:chp:stmts:assign}

The syntax for a variable assignment is simple:

\begin{itemize}
\item \tit{CHP-assignment} : \tit{lvalue} \assign\ \tit{rvalue}
\end{itemize}

\noindent
For example, \ttt{x := y} assigns the value of $y$ to $x$.  
The \emph{lvalue} must refer to a scalar instance of a data type, 
while the \emph{rvalue} may be any (nonmeta) expression.  
The types for \emph{lvalue} and \emph{rvalue} must match.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Wait}
\label{sec:chp:stmts:wait}

When a wait statement is reached, the program simply waits for a condition
to become true before proceeding.  

\begin{itemize}
\item \tit{CHP-wait} : \ttt{[} \tit{CHP-expr} \ttt{]}
\end{itemize}

The expression must, of course, be boolean in value.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Composition}
\label{sec:chp:stmts:comp}

CHP statements may be composed either sequentially or concurrently.  

\begin{itemize}
\item \tit{CHP-sequence} : \tit{CHP-stmt} \seq\ \tit{CHP-stmt} ...
\item \tit{CHP-concurrence} : \tit{CHP-stmt} \concur\ \tit{CHP-stmt} ...
\end{itemize}

Concurrent composition has higher precedence than sequential composition, 
so $X,Y;Z$ is interpreted as $(X,Y);Z$.  
However, one may explictly parenthesize $X,(Y;Z)$.  


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Skip}
\label{sec:chp:stmts:skip}

Skipping this section...

Note on syntax: A skip statement may only appear by itself in a 
CHP body, i.e. never in a sequential or concurrent composition.  
It may appear in-place of any \tit{CHP-stmt-list}.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Flow Control}
\label{sec:chp:flow}

This section describes the various flow control statements available in CHP.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loops}
\label{sec:chp:flow:loop}

Loops never end.  
Most hardware one will describe with CHP will contain a loop.  
(What good is a program that only works once?)

\begin{itemize}
\item \tit{CHP-loop} : \chpbeginloop\ \tit{CHP-stmt-list} \chpendloop
\end{itemize}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Guarded Commands}
\label{sec:chp:flow:guardedcmd}

\begin{itemize}
\item \tit{CHP-guarded-command} : \tit{CHP-expr} \prsrarrow\ \tit{CHP-stmt-list}
\end{itemize}

A special case of a guarded commands is an else-clause, 
which replaces the guard expression with the keyword \ttt{else}.  
An else clause may only appear at the end of deterministic selections, 
but not any other selection statements.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Deterministic Selection}
\label{sec:chp:flow:detsel}

\begin{itemize}
\item \tit{CHP-det-selection} :
	\lbracket\ \tit{CHP-det-guarded-command-list} \rbracket
\item \tit{CHP-det-guarded-command-list} :
	\tit{CHP-guarded-command} \thickbar\ ...
\end{itemize}

The guarded command list must contain at least two guarded commands
(else it's not a selection).  

Operational Semantics: 
(Basically exclusive switch-case.)
Only one of the guards is allowed to be true at a time (mutual exclusion).  
If more than one guard is ever true, then there is an error in the program.  
A deterministic selection blocks until one of its guards has become true
and its guarded commands executed.  


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Nondeterministic Selection}
\label{sec:chp:flow:nondetsel}

\begin{itemize}
\item \tit{CHP-nondet-selection} :
	\lbracket\ \tit{CHP-nondet-guarded-command-list} \rbracket
\item \tit{CHP-nondet-guarded-command-list} :
	\tit{CHP-guarded-command} \thinbar\ ...
\end{itemize}
% just realized reading the above can be confusing, overloaded ':'

Note: for the sake of a cleaner grammar, 
we use \thinbar\ instead of \oldthinbar\ to denote 
a nondeterministic selection.  

Operational Semantics: nondeterministic selection blocks until at least
one guard becomes true.  
While any number of guards may be true, one of the true guards is 
chosen arbitrarily\footnote{Weakly fair.} as the path of execution.  


% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Do-While}
\label{sec:chp:flow:dowhile}

\begin{itemize}
\item \tit{CHP-det-selection} :
	\chpbeginloop\ \tit{CHP-det-guarded-command-list} \chpendloop
\end{itemize}

Operational Semantics:
Loop until all guards are false.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions}
\label{sec:chp:ext}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{C and C++ Routines}
\label{sec:chp:ext:c}

Calling C/C++ functions.  

