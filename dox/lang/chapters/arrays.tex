% "chapters/arrays.tex"

%	$Id: arrays.tex,v 1.6 2006/02/21 23:07:32 fang Exp $

\chapter{Arrays}
\label{sec:arrays}

In many languages, arrays are useful for collective or repetitive constructs.  
In \hac, arrays come in two flavors: sparse and dense.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dense arrays}
\label{sec:arrays:dense}

Dense arrays, which may be multidimensional, have the constraint that
each dimension is precisely covered by a set of contiguous indices.  

The syntax for dense arrays is similar to that of C declarations,
with a few extensions.  

[listing of examples]

Notion of densely packed.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sparse arrays}
\label{sec:arrays:sparse}

A sparse array, on the other hand, is a generalization of a 
(possibly multidimensional) set, whose indices need not be continuous.  

One feature of \hac\ is that one may arbitrarily extend 
arrays, as sets of indices, with multiple declarations.  
A dense array can be made sparse by adding indexed instances that
break the dense condition.
A sparse array can be made dense by filling in indices to satisfy
the dense condition.  
The only constraint is that one cannot re-instantiate an index
that has been previously instantiated.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Size-equivalence}
\label{sec:arrays:size}

\index{size-equivalent}

Two arrays are \emph{size-equivalent} if the following are true:
\begin{enumerate}
\item The number of dimensions match.
\item Both are densely packed.  
\item The size of each dimension is equal.  
\end{enumerate}

The range of indices covered by each dimension need not be equal.  
\emph{Range-equivalence} is a stronger relationship that 
requires that the respective upper and lower bounds of two arrays match.  

Any array that is sparse cannot be size-equivalent to any other array, 
even if the set of indices contained are identical!  

When we refer to instances as being type-equivalent, 
we also mean that they are size-equivalent.  
A connection between two instances is legal if and only if 
they are type-equivalent and size-equivalent.  
In Chapter blah, we discuss connections more in-depth.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Declarations}
\label{sec:arrays:declarations}

Arrays of any type (parameters, channels, processes, datatypes) 
are declared the same way.  
Two syntaces are available for declarations. 
For example, a 1-D array may be declared using:
\begin{itemize}
\item \tit{type identifier} \ttt{[} \tit{range} \ttt{]} \hfill
	(where \tit{range} : \tit{pint} .. \tit{pint})
\item \tit{type identifier} \ttt{[} \tit{pint} \ttt{]} \hfill
	($\equiv$ \tit{type identifier} \ttt{[} 0 ..\tit{eval(pint)}-1 \ttt{]})
\end{itemize}
The first form explicitly specifies the range to instantiate, 
whereas the second form implicitly starts instantiating from 0 and 
ends at one less than the evaluated integer argument.  
The second form is just a convenient syntax for a common construct.  

Multidimensional arrays are declared with multiple dimension specifiers.  
Each dimension of a multidimensional array may be specified using
either style.  

Instance declarations that extend an existing array are no different, 
as long as the added range doesn't overlap with previous declarations.  

Object implementation detail:
Ranges of the second form are expanded out in the intermediate format.  

Tracking the state of instantiations w.r.t. references.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{References}
\label{sec:arrays:references}

Referencing arrays can be a little tricky.  
One may reference dense subsets of either sparse or dense arrays
by specifying the precise range of each dimension.  
An error occurs if not every instance referenced has been instantiated.  

For example, given the declaration \ttt{int z[100]}, 
the reference \ttt{z[0..9]} would refer to the
1-D array of length 10 containing z[0] through z[9].  
\ttt{z[0..0]} refers to the 1-D array of length 1 containing z[0], 
which is \emph{not} size-equivalent to \ttt{z[0]}, 
a 0-D (single instance) reference to z[0], 
because the number of dimensions do not match.  

Indexing an array with a single \pint\ results in a size-type of one less
dimension, in other words, every dimension singly indexed is \emph{collapsed}.  
Dimensions indexed with an explicit range are \emph{preserved}.  
Consider the following examples, given that \ttt{y} is a 2-D array:
\begin{itemize}
\item \ttt{y[i][j]} is a 0-D array, or single instance
\item \ttt{y[i..i][j]} is a 1-D array of size 1
\item \ttt{y[i][j..j]} is a 1-D array of size 1
\item \ttt{y[i..i][j..j]} is a 2-D array of size 1 x 1
\end{itemize}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Implicit size}
\label{sec:arrays:references:implicit}

For convenience, one may refer to the entire collection
of an array with just the name of the instance.  
However, such an \emph{implicit} collection reference is valid
if and only if the implied collection (or sub-array) is densely packed.  

[some valid and invalid examples]

The idea of implicit collections extends to higher dimensions as well.  
Supposing the first $m$ out of $n$ dimensions are indexed, 
with $k$ unspecified dimensions, then the number of dimensions of the 
reference is $m-d+k$ or $n-d$,
where $d$ is the number of collapsed dimensions in $m$.  
In addition, for such a reference to be valid, 
the set of subarrays rooted at the nodes indexed by the 
first $m$ dimensions must all be \emph{range-equivalent}, 
not just size-equivalent.  
Implicit array references that do not satisfy this are considered errors.  

[tons of examples]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aggregates}
\label{sec:arrays:aggregate}

For convenience, we often want to reference a collection of instances
or expressions, and group them into the same entity.  
This section describes the various modes of \emph{aggregate} references
supported by the \hac\ language.  

\medskip
\noindent
\tit{complex-expr-term}
: \tit{array-construction}
$|$ \tit{loop-concatenation}
$|$ \tit{simple-expr}
\medskip

(Here, \tit{simple-expr} is actually a \tit{shift-expr} in the grammar, 
to eliminate ambiguity with repsect to the \ttt{<} and \ttt{>} operators, 
which also wrap around template arguments.)

The following subsections explain the various array-related constructs.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Array concatenation}
\label{sec:arrays:aggregate:concatenation}

The syntax for concatenating arrays:

\medskip
\noindent
\tit{array-concatenation}\\
: \tit{array-concatenation} \ttt{\#} \tit{complex-expr-term}\\
$|$ \tit{complex-expr-term}
\medskip

Semantics: 
The result is an array of the same dimensionality as its constituents, 
but the size of the first dimension is the sum of the first dimension
of its constituents.  The constituents, therefore, cannot be scalars.  
In 2 or higher dimensions, the sizes of all trailing dimensions
(past the first) must match to form a valid concatenation.  
This construction is valid for both meta-expressions and instance-references.  

Example:
1D-arrays of size $[M], [N], [P]$ would be concatenated to form
a 1D-array of size $[M+N+P]$.
2D-arrays of size $[M][Q], [N][Q], [P][Q]$ would be concatenated to form
a 2D-array of size $[M+N+P][Q]$.

\tbf{Status}: not yet implemented, not deemed difficult, low-medium priority

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Array construction}
\label{sec:arrays:aggregate:construction}

The syntax for building higher-dimension arrays:

\medskip
\noindent
\tit{array-construction} : \ttt{\{} \tit{construction-list} \ttt{\}}\\
\tit{construction-list}\\
: \tit{construction-list} \ttt{,} \tit{complex-expr-term}\\
$|$ \tit{complex-expr-term}
\medskip

Semantics:
This construct takes $N$-dimension references and produces an 
$N+1$-dimension array of references.  
Technically, each element is first promoted one dimension
(creating an $N+1$-dimension array with leading dimensions size $[1]$)
and the results are then concatenated.  
The following are equivalent: \ttt{\{ x, y \}} vs. \ttt{\{x\} \# \{y\}}.
The dimension constraint for matching trailing dimensions also applies here.  
This construction is valid for both meta-expressions and instance-references.  

Example:
This is most commonly used for grouping scalars into a 1D-array.  

\tbf{Status}: implemented for 1D-array contruction from scalars, 
	not difficult to add higher dimensions.  

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Loop concatenation}
\label{sec:arrays:aggregate:loopcat}

The syntax for loop-style concatenation:

\medskip
\noindent
\ttt{( \# :} \tit{identifier} \ttt{:} \tit{range} \ttt{:}
	\tit{complex-expr-term} \ttt{)}
\medskip

Semantics:

Example:

Status: not yet implemented, low priority.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Issues}
\label{sec:arrays:issues}

Interpreter vs. compiler.

Tracking what instances are available at the point-of-reference.  

