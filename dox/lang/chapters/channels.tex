% "chapters/channels.tex"

%	$Id: channels.tex,v 1.5 2006/11/15 21:56:44 fang Exp $

\chapter{Channels}
\label{sec:channels}

Processes communicate to each other via channels.  
Channels are an abstract notion of a point-to-point medium
of communication between sender and receiver.
(\hac\ does not yet support multi-sender or multi-receiver communication
primitives.)  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sending and Receiving}
\label{sec:channel:sendrecv}

Without going into the details of channels, we can define a notion of 
directionality for channels.  
Suppose we have some channel type \ttt{chan(bool)}.  

\begin{verbatim}
chan(bool) X;
chan?(bool) Y;
chan!(bool) Z;
\end{verbatim}

This declares a channel \ttt{X} with unspecified direction (nondirectional), 
\ttt{Y} as a read-only (receive-only) directional channel, 
and \ttt{Z} as a send-only directional channel.  
Send-only and receive-only channels are the most useful in
process port declarations ---
what use are uni-directional channels in the global or local 
scopes\footnote{Should multi-module linkage ever be specified and implemented, 
a receive-only channel in one module could connect to 
a send-only channel in another module.}?

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\subsection{Connections and Directions}
\label{sec:channel:sendrecv:connect}

What are legal connections between channel instance references?

Q: Should legal programs be restricted to connecting
at most one-receiver to one-sender?

Q: Should dangling channels (one-way only) be allowed, rejected, or warned?
Does not count ports.  

Aliasing: is connecting two read-only channels legal for the sake of aliasing?
Connecting two read-only ports of different processes seems like an error.
Can we define precise alias semantics?

We use the following example program template to answer questions.  

\begin{verbatim}
defproc inner(chan(bool) A; chan?(bool) B; chan!(bool) C) { ... }
defproc outer(chan(bool) P; chan?(bool) Q; chan!(bool) R) {
  inner x(...), y(...);
}
\end{verbatim}

\begin{itemize}
\item \ttt{x(P,Q,R), y;} -- legal
\item \ttt{x, y; x.A = P; x.B = Q; x.C = R} -- legal, equivalent to the previous
\item \ttt{x, y(x.A, x.B, x.C);} -- legal?  two receive ports being aliased!
\item \ttt{x(P,R,Q), y;} -- error: connecting send-only to receive-only channel
\item \ttt{x, y(x.A, x.C, x.B);} -- error: equivalent to above
\end{itemize}

Goal: precise set of rules for channel connections.
Q: does it depend on whether or not referenced channel is local vs. port?

\tbf{Proposal}: a read-only port can take a directionless or 
read-only port (forwarded) channel as an argumnent.  
(Likewise for send-only ports.)  
(Update: accepted.)

Should we allow alias connection syntax for channels?
Aliasing is a symmetric relation, whereas port connections \emph{need not} be.  
Yes, but with the following additional semantic constraints:

\tbf{Proposal}:
Unidirectional channels should not be referenceable as aliases, only
connected through ports.  
Only nondirectional channels may use alias syntax.  
Thus, directional channels may only be connected by passing port arguments.  
Consequences: every physical channel must be connected to at least one
nondirectional channel.  
A send-receive pair must be connected using a nondirectional channel
of the same type.  
(Status: obsolete, in favor of the proposals below)

\tbf{Proposal}:
A nondirectional channel may be connected to only one read-only channel
and only one send-only channel.  
(Update: accepted, with possible exception of explicitly shared channels, 
proposed below.)
The following example would be rejected:

\begin{verbatim}
defproc bucket(chan?(bool) S) { ... }
chan(bool) R;
bucket a(R), b(R);
\end{verbatim}

Implementation detail: 
As aliases are built using a union-find, make sure the canonical node
always knows what direction of channels have been connected (propagation).  
We will track this with a set of flags indicating whether a channel
is already connected to a producer or consumer.  
Note, however, that send/receive use of a channel in CHP body counts as 
connecting a consumer/producer, respectively.  
Thus, channel connection checking should include a final pass over
the CHP's unrolled footprint.  

\tbf{Proposal}: 
Reject local channel declarations with directional qualifiers.  
Rationale: It doesn't make sense to have a uni-directional channel
in a local scope because any connection or use thereof would result
in a block.  
(Could this be useful for debugging, e.g. causing intentional deadlock?)

\tbf{Proposal}: Reject dangling channels.  
Channels that are missing connection to a producer or consumer
should be rejected.  Basically, when a channel is deduced as dangling, 
at least a diagnostic should be issued.  

\tbf{Proposal}: Shared channels:
Thus far, we've described one-to-one channels where producers
and consumers are exclusively paired.  
In some exceptional circumstances one might desire to share a 
channel among multiple senders or multiple receivers, 
where exclusive access is to be guaranteed by the programmer.  
The following semantics are proposed for sharing channels:
A channel is allowed to be connected to multiple receivers, if and only if
all participating receivers agree to share, 
by some implementation of `agree.'
Likewise, multiple senders may share a channel, if and only if
all participating senders agree to share.  
One end of communication on a channel is indifferent
to whether or not the other end is shared; 
a non-shared sender however may connect to shared receivers, 
and a non-shared receiver may connect to shared senders;
To mix shared and non-shared uses on the same end is considered
an error.  

Rationale: Since channel sharing is exceptional, we want to prevent
inadvertent sharing of channels.  Non-shared channels expect 
exclusive use of the channel, so to share them would violate
the fundamental assumption.  

Syntax: a port declared with \ttt{??} or \ttt{!!} indicates that
the channel may be shared (by receiving or sending).  
A \ttt{??} port channel may be connected locally to multiple receivers, 
and a \ttt{!!} port channel may be connected locally to multiple senders.  
When referenced externally, as a member of process, 
\ttt{??} ports may share the same channel as multiple receivers, and 
\ttt{!!} ports may share the same channel as multiple senders.  

TODO: examples.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fundamental Channel Types}
\label{sec:channels:fundamental}

Until now, we've used \ttt{chan(bool)} without discussing its meaning.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User-defined Channel Types}
\label{sec:channels:userdef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Issues}
\label{sec:channels:issues}

This section is the most of asked (but not necessarily answered) questions
pertaining to the channel aspects of the \hac\ language.  

\subsection{Typedefs}
\label{sec:channels:typedefs}

Q: Should channels be typedef-able?

\subsection{Relaxed Templates}
\label{sec:channels:relaxed_templates}

Q: Should channels ever involve relaxed template arguments?
A: No.  Can't see a good reason for allowing channel type to vary
	within a higher dimension collection.  This applies recursively
	to data-types which fall into the channel's type specification.  
	Can processes every be involved in channel type?  Probably not.  

