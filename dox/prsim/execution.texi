@c "hacprsim/execution.texi"
@c $Id: execution.texi,v 1.1 2007/08/20 21:12:31 fang Exp $

@node Execution
@chapter Execution

This chapter describes the internal event-driven execution algorithm.
The simulator is purely @emph{event-driven} in that events 
(changes in state) are the only things that can trigger other events.
There is no periodic tick apart from periodic event sources that 
a user can configure.  
Event-driven simulation is particularly suitable for asynchronous circuits
because it models how asynchronous circuits behave, that is, 
by reacting to changes in state.  
However, even synchronous circuits can be simulated effectively,
as circuits can simply respond to events on periodic clocks.  
The combination of asynchronous and synchronous circuits in simulation
is very natural.

@menu
* Time::
* Event queue::
* Production rules::
* Node values and pull-states::
* Expression evaluation::
* Stability::
@end menu

@c -----------------------------------------------------------------------------
@node Time
@section Time

@cindex time
Time in @hacprsim{} is real-valued and unitless.
The numerical values used and reported in @hacprsim{}
can be interpreted in any units the user deems appropriate, 
be it milliseconds or femtoseconds.  
The simulator maintains a notion of the present time, 
which is updated when the next event is executed or the user explicitly
advances the simulator a specific amount of time 
(via the @command{advance} command).  
Simulator time, like real time, only moves forward.  


@c -----------------------------------------------------------------------------
@node Event queue
@section Event queue

@cindex event queue
A simulator event is simply a referenced to a (boolean) node
with its new value, and the time at which the change should take place.
At the heart of the simulation engine is a single event queue
that is ordered by time of scheduled event.  

Implementation detail: The event queue is typically a priority queue 
that is implemented as a heapified array.  However, a heap doesn't
guarantee that events with the equal keyed value (time)
are dequeued in first-come-first-serve (FCFS) order.
Thus, we use a multimap (C++ STL), which guarantees FCFS-ordering.
In typical implementations of the STL, both @code{std::map} and 
@code{std::multimap} maintain an iterator to the min-element, 
so extracting the next event in time is an efficient operation.

@cindex instability
In addition to the basic priority queue operations, the simulator's event 
queue supports several other modification operations.  
An event in any position in the queue can be @emph{dequeued}, 
by marking it as a killed event, which is simply skipped during dequeue.
This can occur with @emph{unstable} rules, 
explained in @ref{Production rules}.
The event queue also permits rescheduling where the time
of an in-queue event can be modified and re-inserted.  
This potentially lets a user try out different timing or race scenarios.

Events can also be generated by the user interactively
(@ref{Simulation Commands}),
or through channel environment commands (@ref{Channel Commands}).

@cindex time
The simulator maintains the current time in a variable.
At any time @var{Tnow}, the next event in queue will be at @var{Tnext}
which is greater-than or equal-to @var{Tnow}.
When the next event is executed, the current time is
advanced to @var{Tnext}.

The event queue can be displayed interactively with the @command{queue}
command.

@c -----------------------------------------------------------------------------
@node Production rules
@section Production rules

@cindex production rules
Production rules specify the conditions under which events are generated
and scheduled.  Production rules are of the form: @code{G -> S}, where 
@code{G} is a guard-expression and @code{S} is node-value pair, 
representing an event.
When a guard-expression evaluates true, the simulation schedules
the corresponding event in the event queue.
The time of the new event is determined by the current simulation
mode, which may be a fixed or randomly chosen value.  

Consider the following time-annotated production rule:

@example
prs @{
  [after=10]  x &  y -> z-
  [after=5]  ~x | ~y -> z+
@}
@end example

@noindent
Say that at time 0, all values are @code{X} (unknown).
As an example, one sets @var{x} and @var{y} to 1 (still at time 0).
As the simulator advances, at time 0, the guard for the first rule
evaluates true, and causes an event on @code{z -> 0} to be scheduled 
at time 10.  At this time @var{z} is still @code{X}.
Since there no other event besides the one just scheduled, 
the simulator advances to time 10, when the event on @code{z -> 0}
is dequeued and executed.  
Now say that (at time 10), the user sets @var{x} to 0.
This schedules the event @code{z -> 1} at time 15.
At time 15, the event is dequeued and @var{z} is changed to 1.

@ref{Stability} describes what happens when the guard
of a rule evaluates false before the event for the
rule is executed.

TODO: weak rules

The @HAClangref{} contains a chapter on the 
PRS (production rule set) language.

@c -----------------------------------------------------------------------------
@node Node values and pull-states
@section Node values and pull-states

@cindex pull-state
At run-time, boolean nodes in the simulator can assume three possible values:
0, 1, X (unknown).
Boolean expressions on nodes are evaluated to the same values.  
Expressions involving X values are evaluated as follows:

@example
   ~X = X
1 & X = X
0 & X = 0
1 | X = 1
0 | X = X
@end example

We can also refer to the @emph{pull-state} on a node, which summarizes
the state of guard-expressions in rules that pull a node up or down.
The combination of opposing pull-states that determine
what the next value of a node should be, as summarized in the following table:

@multitable {xxxxxx} {xxxxx} {xxxxxxx} {xxxxxxx}
@item - @tab up-0 @tab up-X @tab up-1
@item down-0 @tab float @tab X @tab 1
@item down-X @tab X @tab w-interf @tab w-interf
@item down-1 @tab 0 @tab w-interf @tab interf
@end multitable

@cindex floating
In the @t{float} state, a node just retains is old value, 
no event is scheduled.  This models dynamically driven nodes
as perfectly state-holding.
The two @t{X} states are non-interfering states, where the pull
in one direction is unknown, so a @t{node -> X} event would be scheduled.
@cindex interference
@emph{Interference} refers to a conflicting pull in opposite directions,
which can mean a short-circuit between power supplies.  
@cindex weak interference
@emph{Weak interference}, denoted @t{w-interf} in the table, 
is any interference involving at least one X-pull, which translates
to a possible interference.
(The `weak' terminology comes from legacy tools.)
Any type of interference will schedule a @t{node -> X} event.

@cindex OR-combination
Since multiple rules may drive the same node in the same direction,
the effective pull-state in a given direction is the (parallel)
OR-combination of all rules for that direction.
However, since each rule may have its own set of attributes,
the evaluation engine does keep track of which individual rule fired.  

@c -----------------------------------------------------------------------------
@node Expression evaluation
@section Expression evaluation

This section decribes how expressions are evaluated and propagated.
Expressions come from guards of production rules.  

The state of an expression is maintained as a tree of subexpression states.
The nodes of this tree represent the current state and value 
of a subexpression.
@cindex memoization
Node states are memoized in a way that counts the number of X values
and non-X values in children nodes.  
In an AND expression, the non-X values are 0s -- when there are
no more 0s and Xs, the subexpression evaluates to 1.
In an OR expression, the non-X values are 1s -- when there are no more
1s and Xs, the subexpression evaluates to 0.
Subexpression update are propagated up the tree by updating these counts.
Progation terminates when a subexpression's output does not change
(and hence, the root of the tree sees no change in state), 
or the update reaches the expression root and results in
a change in pull-state.
Unlike production rule firings, expression update progagation happens 
@emph{atomically}, that is, at no time 
can a user observe a state in which expressions have not been 
fully propagated.

There is a class of boolean value updates that occur atomically.
Examples of atomic bools can be found in @ref{Using Atomic Expressions}.
[TODO: document that, cross reference language manual too.]

@c -----------------------------------------------------------------------------
@node Stability
@section Stability

@cindex instability
A rule is stable if its guard is remains true until the 
time at which the output event fires.  
The simulator supports a few different modes of handling
unstable events.
Depending on the type of circuit you are simulating, 
you may want different policies for handling instabilities.
@xref{Instabilities in Synchronous Circuits}.

