% "chpsim/execution.tex"

\section{Event-driven Execution}
\label{sec:exec}

[Describe event-driven execution algorithm.]

See Figure~\ref{fig:event_algo}.

\begin{figure}[ht!]
\begin{center}
\resizex{5in}{\xfig{figs/chpsim_event_cycle}}
\caption{Obsolete: CHP simulator event life cycle}
\label{fig:event_exec}
\end{center}
\end{figure}

\begin{figure}[ht!]
\begin{center}
\resizex{5in}{\xfig{figs/chpsim_event_algo}}
\caption{CHP simulator event algorithm}
\label{fig:event_algo}
\end{center}
\end{figure}

\subsection{Event ordering}
\label{sec:exec:order}

The whole-program event graph is composed of concurrent event graphs
representing each process.  
The edges in the event graph represent the legal orderings between events, 
including cycles.  
Any process's execution trace is a projection of the entire program's
execution trace (and all possible traces).  

\subsection{Timing}
\label{sec:exec:timing}

The delays associated with each event are \emph{prefix} delays, 
i.e. the delays are applied before the event is 
\emph{checked for the first time}\footnote{One reason why 
a prefix-delay model was chosen was to facilitate
the pseudo-atomic execution of send-receive event pairs.
Pseudo-atomicity arises from the fact paired-events are still executed 
individually, but guaranteed to share the exact same timestamp.
Had we chosen to use suffix or infix delays, delays would be applied
\emph{after} unblocking, resulting in potentially different timestamps.}.
In other words, every successor of an event that just executed
is scheduled for future checking using the delay of each successor.  
When an event is checked for the first time, it is either blocked
or executed immediately.  
When an event is blocked, it is subscribed to its dependencies
(or some conservative superset thereof).  
When an event is unblocked, it is unsubscribed from its dependencies
and placed into the \emph{immediate execution queue} because
it has already paid its delay up front, 
and thus should not be delayed further.  
The immediate execution queue contains only unblocked events
that take precedence over the checking queue.  


