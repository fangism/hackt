/**
 * "art.l"
 * lexer for transistor stacks
 * copied and modified from "fhpg.l"
 */

/***************** FOREWORD ***************************************************
	why C? not C++?
		according to my sources on the web, it is easier/cleaner
		to keep the lexer in C, and import the lexer into a 
		C++ parser generated by yacc.  Thus, use [f]lex not flex++.  
		It only matters that we can use C++ for the parser when
		we're working with classes and objects.  

	quoted strings are restricted to single line, however, 
		the parser will concatenate sequences of strings
		into a single string.  

	yylval, passed to parser is a union of double, long, char*.  
		The char* member, string, is just pointer-copied, 
		with no memory management.  Thus, the parser should
		actually strcpy() the string into it's own structures.  
		strcpy() is probably performed by the constructors.  
		see "fhpg.yy" and "fhpg.cc"

	yylineno: seems buggy, so not using the option, keeping
		track manually with mylineno.  
		Thus no other pattern may allow newline characters, we must 
		force a stop at each newline, and treat it separately.  

	column_position: manually keeping track of column position of tokens
		get moderately complicated for multi-line tokens, 
		such as raw-source and extended comments.  
		How is it done?  Since comments and sources may span multiple
		lines and start anywhere on a line, and we only have access
		to the global yyleng upon each match, we need to remember
		how much we've matched since the last newline.  
		case 1) start of source (anywhere): while the source
		is on the 

	To do: 
		See if we can use the single character tokens' characters
		as the return values to the parser.  

		Implement the #line directive to interpret the output
		of flattened, preprocessed files.  

******************************************************************************/
/****** DEFINITIONS **********************************************************/

%option noyywrap

%{
/* scanner-specific header */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "art_parser.h"
using namespace ART::parser;
#include "y.tab.h"			/* symbols generated by yacc */
#include "art_lex.h"

#define	STRING_MAX_LEN		1024

/* line and position tracking data for tokens */
	token_position current = { 1, 0, 1, 0};	/* globally accessible */
static	token_position comment_pos = { 1, 0, 1, 0 };
static	token_position string_pos = { 1, 0, 1, 0 };
	/* even though strings may not be multi-line */

/* for string matching */
static	char string_buf[STRING_MAX_LEN];
static	char* string_buf_ptr = NULL;

/* macros for tracking single line tokens (no new line) */
#define TOKEN_UPDATE	current.col += yyleng;
#define	NEWLINE_UPDATE	{ current.line++; current.col = 1; }
#define	STRING_UPDATE	{ TOKEN_UPDATE; 				\
		assert(string_buf_ptr -string_buf < STRING_MAX_LEN);	\
			}

/* macros for tracking long, multiline tokens */
/* pass into p either source_pos or comment_pos */
#define	MULTILINE_START(p)						\
			{ p.col = current.col;				\
			p.line = current.line;				\
			p.leng = yyleng;				\
			TOKEN_UPDATE; }
#define MULTILINE_MORE(p)						\
			if (p.line == current.line) {			\
				current.col = yyleng +p.col +p.off;	\
			} else {					\
				current.col = yyleng -p.leng;		\
			}
#define MULTILINE_NEWLINE(p)						\
			{ p.leng = yyleng -1; NEWLINE_UPDATE; }

#define LINE_COL(c)	fprintf(stderr, "on line %ld:%ld", c.line, c.col);

int allow_nested_comments = 0;
static int comment_level = 0;		/* useful for nested comments */

/* debugging switches */
int token_feedback = 0;
int string_feedback = 0;
int comment_feedback = 0;		/* reporting of comment state */
	/*	0 = off, 
		1 = nested levels only, 
		2 = null and endline comments, 
		3 = ignored text feedback details
	*/

%}

DIGIT		[0-9]
IDHEAD		[a-zA-Z_]
IDBODY		[a-zA-Z0-9_]
INT		[+-]?{DIGIT}+
EXP		[eE]{INT}
FRACTIONAL	"."{DIGIT}+
FLOAT		({INT}{FRACTIONAL}{EXP}?)|({INT}{FRACTIONAL}?{EXP})
ID		{IDHEAD}{IDBODY}*
BADID		({INT}{ID})|({FLOAT}{ID})
WHITESPACE	[ \t]+
NEWLINE		"\n"

UNICHARTOKEN	[][(){}<>*%/=:;|!?~&^.+-]

AT		"@"
POUND		"#"
DOLLAR		"$"

PLUSPLUS	"++"
MINUSMINUS	"--"
LARROW		"<-"
RARROW		"->"
EQUAL		"=="
NOTEQUAL	"!="
LE		"<="
GE		">="
IMPLIES		"=>"
INSERT		">>"
EXTRACT		"<<"
FWDSLASH	"\\"
LOGICAL_AND	"&&"
LOGICAL_OR	"||"
BEGINLOOP	"*["
BEGINPROB	"%["
ENDPROB		"]%"
THICKBAR	"[]"
SCOPE		"::"
DEFINEOP	"<:"
RANGE		".."

ENDLINECOMMENT	"//"(.*)$
NULLCOMMENT	"/*"("*"+)"/"
OPENCOMMENT	"/"("*"+)[^/]
CLOSECOMMENT	"*"+"/"

OPENSTRING	"\""
MORESTRING	[^\\\"\n]+
CLOSESTRING	"\""

OCTAL_ESCAPE	"\\"[0-7]{1,3}
BAD_ESCAPE	"\\"[0-9]+

/****** keywords ****/
DEFINE		"define"
DEFCHAN		"defchan"
DEFTYPE		"deftype"
DEFPROC		"defproc"
CHP		"chp"
HSE		"hse"
PRS		"prs"
SKIP		"skip"
ELSE		"else"
LOG		"log"
SEND		"send"
RECV		"recv"
SET		"set"
GET		"get"
INT_TYPE	"int"
BOOL_TYPE	"bool"
PINT_TYPE	"pint"
PBOOL_TYPE	"pbool"
CHANNEL		"chan"
TRUE		"true"
FALSE		"false"


/****** states ******/
%s incomment
%s instring
%s inescape

/****** rules ****************************************************************/
%%

<INITIAL>{

{LE}		{ TOKEN_UPDATE; return LE; }
{GE}		{ TOKEN_UPDATE; return GE; }
{EQUAL}		{ TOKEN_UPDATE; return EQUAL; }
{NOTEQUAL}	{ TOKEN_UPDATE; return NOTEQUAL; }
{THICKBAR}	{ TOKEN_UPDATE; return THICKBAR; }
{SCOPE}		{ TOKEN_UPDATE; return SCOPE; }
{RANGE}		{ TOKEN_UPDATE; return RANGE; }
{IMPLIES}	{ TOKEN_UPDATE; return IMPLIES; }
{RARROW}	{ TOKEN_UPDATE; return RARROW; }
{BEGINLOOP}	{ TOKEN_UPDATE; return BEGINLOOP; }
{BEGINPROB}	{ TOKEN_UPDATE; return BEGINPROB; }
{ENDPROB}	{ TOKEN_UPDATE; return ENDPROB; }
{PLUSPLUS}	{ TOKEN_UPDATE; return PLUSPLUS; }
{MINUSMINUS}	{ TOKEN_UPDATE; return MINUSMINUS; }
{DEFINEOP}	{ TOKEN_UPDATE; return DEFINEOP; }
{LOGICAL_AND}	{ TOKEN_UPDATE; return LOGICAL_AND; }
{LOGICAL_OR}	{ TOKEN_UPDATE; return LOGICAL_OR; }
{INSERT}	{ TOKEN_UPDATE; return INSERT; }
{EXTRACT}	{ TOKEN_UPDATE; return EXTRACT; }

{UNICHARTOKEN}	{ TOKEN_UPDATE; return yytext[0]; }

{WHITESPACE}	TOKEN_UPDATE;
{NEWLINE}	NEWLINE_UPDATE;
{NULLCOMMENT} { 
	if (comment_feedback > 1) {
		fprintf(stderr, "null comment ignored ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
}
{ENDLINECOMMENT} { 
	if (comment_feedback > 1) {
		fprintf(stderr, "end-of-line comment ignored ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
}
{FLOAT} {
	if (token_feedback) {
		fprintf(stderr, "float = %s ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
	yylval.double_val = atof(yytext);
	return FLOAT;
}

{INT}	{
	if (token_feedback) {
		fprintf(stderr, "int = %s ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
	yylval.long_val = atoi(yytext);
	return INT;
}

{ID}	{
	if (token_feedback) {
		fprintf(stderr, "identifier = \"%s\" ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
	yylval.text = new string(yytext);
	return ID;
}

{OPENCOMMENT} {
	/* crazy... allowing nested comments */
	comment_level++;
	if (comment_feedback) {
		fprintf(stderr, "start of comment-level %d ", comment_level);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	yymore();
	MULTILINE_START(comment_pos);
	BEGIN(incomment); 
}

{OPENSTRING}	{
	if (string_feedback) {
		fprintf(stderr, "start of quoted-string ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	/* no yymore(), skip open quote */
	string_buf_ptr = string_buf;
	MULTILINE_START(string_pos);	/* just for column positioning */
	BEGIN(instring); 
}

{CLOSECOMMENT} {
	fprintf(stderr, "*/ (close-comment) found outside of <comment> ");
	LINE_COL(current);
	fprintf(stderr, "\n");
	TOKEN_UPDATE;
	exit(1);
}

{BADID}	{ 
	fprintf(stderr, "bad identifier: \"%s\" ", yytext);
	LINE_COL(current);
	fprintf(stderr, "\n");
	TOKEN_UPDATE;
	exit(1);
}
.	{
	/* for everything else that doesn't match... */
	fprintf(stderr, "unexpected character: \'%s\' ", yytext);
	LINE_COL(current);
	fprintf(stderr, "\n");
	TOKEN_UPDATE;
}

}

<incomment>{
{NULLCOMMENT}	{ /********/ /*** does nothing ***/ /********/	
	if (comment_feedback > 1) {
		fprintf(stderr, "null-comment within comment ignored ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	MULTILINE_MORE(comment_pos);
	yymore();
}
{OPENCOMMENT} {
	if (allow_nested_comments) {
		comment_level++;
		if (comment_feedback) {
			fprintf(stderr, "start of comment-level %d ", 
				comment_level);
			LINE_COL(current);
			fprintf(stderr, "\n");
		}
		MULTILINE_MORE(comment_pos);
		yymore();
	} else {
		fprintf(stderr, "nested comments forbidden, found /* ");
		LINE_COL(current);
		fprintf(stderr, "\n");
		exit(1);
	}
}

{NEWLINE}	{ MULTILINE_NEWLINE(comment_pos); yymore(); }

[^*/\n]*	|
"*"+[^/\n]	|
"/"+[^*\n]	{
	if (comment_feedback > 2) {
		fprintf(stderr, "eaten up more comment ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	MULTILINE_MORE(comment_pos);
	yymore();
}
{CLOSECOMMENT} {
	MULTILINE_MORE(comment_pos);
	if (comment_feedback) {
		fprintf(stderr, "end of comment-level %d ", comment_level);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	comment_level--;
	if (!comment_level) {
		BEGIN(INITIAL); 
	} else {
		yymore();
	}
}
<<EOF>>	{
	MULTILINE_MORE(comment_pos);
	fprintf(stderr, "unterminated comment, starting on line %ld, "
		"got <<EOF>>\n", comment_pos.line);
	exit(1);
}
}

<instring>{
{NEWLINE}	{
	fprintf(stderr, "unterminated quoted-string on line %ld"
		", got \\n\n", current.line);
	STRING_UPDATE;
	exit(1);
}

{MORESTRING}	{
	// do escape seqences later... need a string buffer
	char *copy = yytext;
	while (*copy) {			/* until null-termination */
		*string_buf_ptr++ = *copy++;
	}
	/* don't really need yymore, just for tracking column position here */
	STRING_UPDATE;
}

{CLOSESTRING}	{
	*string_buf_ptr = '\0';		/* null-terminate */
	if (string_feedback) {
		fprintf(stderr, "end of quoted-string: \"%s\" ", string_buf);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	STRING_UPDATE;
	BEGIN(INITIAL);
	yylval.text = new string(string_buf);
	return STRING;
}

"\\0"	{ *string_buf_ptr++ = '\0';	STRING_UPDATE;	}
"\\b"	{ *string_buf_ptr++ = '\b';	STRING_UPDATE;	}
"\\f"	{ *string_buf_ptr++ = '\f';	STRING_UPDATE;	}
"\\n"	{ *string_buf_ptr++ = '\n';	STRING_UPDATE;	}
"\\r"	{ *string_buf_ptr++ = '\r';	STRING_UPDATE;	}
"\\t"	{ *string_buf_ptr++ = '\t';	STRING_UPDATE;	}
"\\\\"	{ *string_buf_ptr++ = '\\';	STRING_UPDATE;	}

{OCTAL_ESCAPE}	{
	int result;
	sscanf(yytext +1, "%o", &result);
	if ( result > 0xff ) {
		fprintf(stderr, "bad octal escape sequence %s ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
		exit(1);
	}
	*string_buf_ptr++ = result;
	STRING_UPDATE;
}

{BAD_ESCAPE}	{
	fprintf(stderr, "bad octal escape sequence %s ", yytext);
	LINE_COL(current);
	fprintf(stderr, "\n");
	exit(1);
}
}

%%
/****** user-code ************************************************************/

