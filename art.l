/**
 * "art.l"
 * lexer for transistor stacks
 * copied and modified from "fhpg.l"
 */

/***************** FOREWORD ***************************************************
	why C? not C++?
		according to my sources on the web, it is easier/cleaner
		to keep the lexer in C, and import the lexer into a 
		C++ parser generated by yacc.  Thus, use [f]lex not flex++.  
		It only matters that we can use C++ for the parser when
		we're working with classes and objects.  

	quoted strings are restricted to single line, however, 
		the parser will concatenate sequences of strings
		into a single string.  

	yylval, passed to parser is a union of double, long, char*.  
		The char* member, string, is just pointer-copied, 
		with no memory management.  Thus, the parser should
		actually strcpy() the string into it's own structures.  
		strcpy() is probably performed by the constructors.  
		see "fhpg.yy" and "fhpg.cc"

	yylineno: seems buggy, so not using the option, keeping
		track manually with mylineno.  
		Thus no other pattern may allow newline characters, we must 
		force a stop at each newline, and treat it separately.  

	column_position: manually keeping track of column position of tokens
		get moderately complicated for multi-line tokens, 
		such as raw-source and extended comments.  
		How is it done?  Since comments and sources may span multiple
		lines and start anywhere on a line, and we only have access
		to the global yyleng upon each match, we need to remember
		how much we've matched since the last newline.  
		case 1) start of source (anywhere): while the source
		is on the 

	To do: 
		Implement the #line directive to interpret the output
		of flattened, preprocessed files.  

******************************************************************************/
/****** DEFINITIONS **********************************************************/

%option noyywrap

%{
/* scanner-specific header */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "art_parser.h"
using namespace ART::parser;
#include "y.tab.h"			/* symbols generated by yacc */
#include "art_lex.h"

#define	STRING_MAX_LEN		1024

/* line and position tracking data for tokens */
	token_position current = { 1, 0, 1, 0};	/* globally accessible */
static	token_position comment_pos = { 1, 0, 1, 0 };
static	token_position string_pos = { 1, 0, 1, 0 };
	/* even though strings may not be multi-line */

/* for string matching */
static	char string_buf[STRING_MAX_LEN];
static	char* string_buf_ptr = NULL;

/* macros for tracking single line tokens (no new line) */
#define TOKEN_UPDATE	current.col += yyleng;
#define	NEWLINE_UPDATE	{ current.line++; current.col = 1; }
#define	KEYWORD_UPDATE	{ yylval.n = new token_keyword(yytext); TOKEN_UPDATE; }
#define	BOOL_UPDATE	{ yylval.n = new token_bool(yytext); TOKEN_UPDATE; }
#define	MULTICHAR_UPDATE						\
			{ yylval.n = new token_string(yytext); TOKEN_UPDATE; }
#define	STRING_UPDATE	{ TOKEN_UPDATE; 				\
		assert(string_buf_ptr -string_buf < STRING_MAX_LEN);	\
			}

/* macros for tracking long, multiline tokens */
/* pass into p either source_pos or comment_pos */
#define	MULTILINE_START(p)						\
			{ p.col = current.col;				\
			p.line = current.line;				\
			p.leng = yyleng;				\
			TOKEN_UPDATE; }
#define MULTILINE_MORE(p)						\
			if (p.line == current.line) {			\
				current.col = yyleng +p.col +p.off;	\
			} else {					\
				current.col = yyleng -p.leng;		\
			}
#define MULTILINE_NEWLINE(p)						\
			{ p.leng = yyleng -1; NEWLINE_UPDATE; }

#define LINE_COL(c)	fprintf(stderr, "on line %ld:%ld", c.line, c.col);

int allow_nested_comments = 0;
static int comment_level = 0;		/* useful for nested comments */

/* debugging switches */
int token_feedback = 0;
int string_feedback = 0;
int comment_feedback = 0;		/* reporting of comment state */
	/*	0 = off, 
		1 = nested levels only, 
		2 = null and endline comments, 
		3 = ignored text feedback details
	*/

%}

DIGIT		[0-9]
IDHEAD		[a-zA-Z_]
IDBODY		[a-zA-Z0-9_]
INT		[+-]?{DIGIT}+
EXP		[eE]{INT}
FRACTIONAL	"."{DIGIT}+
FLOAT		({INT}{FRACTIONAL}{EXP}?)|({INT}{FRACTIONAL}?{EXP})
ID		{IDHEAD}{IDBODY}*
BADID		({INT}{ID})|({FLOAT}{ID})
WHITESPACE	[ \t]+
NEWLINE		"\n"

UNICHARTOKEN	[][(){}<>*%/=:;|!?~&^.,+-]

AT		"@"
POUND		"#"
DOLLAR		"$"

PLUSPLUS	"++"
MINUSMINUS	"--"
LARROW		"<-"
RARROW		"->"
EQUAL		"=="
NOTEQUAL	"!="
LE		"<="
GE		">="
IMPLIES		"=>"
INSERT		">>"
EXTRACT		"<<"
FWDSLASH	"\\"
LOGICAL_AND	"&&"
LOGICAL_OR	"||"
BEGINLOOP	"*["
BEGINPROB	"%["
ENDPROB		"]%"
THICKBAR	"[]"
SCOPE		"::"
DEFINEOP	"<:"
RANGE		".."

ENDLINECOMMENT	"//"(.*)$
NULLCOMMENT	"/*"("*"+)"/"
OPENCOMMENT	"/"("*"+)[^/]
CLOSECOMMENT	"*"+"/"

OPENSTRING	"\""
MORESTRING	[^\\\"\n]+
CLOSESTRING	"\""

OCTAL_ESCAPE	"\\"[0-7]{1,3}
BAD_ESCAPE	"\\"[0-9]+

/****** keywords ****/
NAMESPACE	"namespace"
OPEN		"open"
AS		"as"
DEFINE		"define"
DEFCHAN		"defchan"
DEFTYPE		"deftype"
DEFPROC		"defproc"
CHP		"chp"
HSE		"hse"
PRS		"prs"
SKIP		"skip"
ELSE		"else"
LOG		"log"
SEND		"send"
RECV		"recv"
SET		"set"
GET		"get"
INT_TYPE	"int"
BOOL_TYPE	"bool"
PINT_TYPE	"pint"
PBOOL_TYPE	"pbool"
CHANNEL		"chan"
TRUE		"true"
FALSE		"false"

/* consider recording all tokens' (including punctuation) positions? */

/****** states ******/
%s incomment
%s instring
%s inescape

/****** rules ****************************************************************/
%%

<INITIAL>{

{LE}		{ MULTICHAR_UPDATE; return LE; }
{GE}		{ MULTICHAR_UPDATE; return GE; }
{EQUAL}		{ MULTICHAR_UPDATE; return EQUAL; }
{NOTEQUAL}	{ MULTICHAR_UPDATE; return NOTEQUAL; }
{THICKBAR}	{ MULTICHAR_UPDATE; return THICKBAR; }
{SCOPE}		{ MULTICHAR_UPDATE; return SCOPE; }
{RANGE}		{ MULTICHAR_UPDATE; return RANGE; }
{IMPLIES}	{ MULTICHAR_UPDATE; return IMPLIES; }
{RARROW}	{ MULTICHAR_UPDATE; return RARROW; }
{BEGINLOOP}	{ MULTICHAR_UPDATE; return BEGINLOOP; }
{BEGINPROB}	{ MULTICHAR_UPDATE; return BEGINPROB; }
{ENDPROB}	{ MULTICHAR_UPDATE; return ENDPROB; }
{PLUSPLUS}	{ MULTICHAR_UPDATE; return PLUSPLUS; }
{MINUSMINUS}	{ MULTICHAR_UPDATE; return MINUSMINUS; }
{DEFINEOP}	{ MULTICHAR_UPDATE; return DEFINEOP; }
{LOGICAL_AND}	{ MULTICHAR_UPDATE; return LOGICAL_AND; }
{LOGICAL_OR}	{ MULTICHAR_UPDATE; return LOGICAL_OR; }
{INSERT}	{ MULTICHAR_UPDATE; return INSERT; }
{EXTRACT}	{ MULTICHAR_UPDATE; return EXTRACT; }

{UNICHARTOKEN}	{ yylval.n = new token_char(yytext[0]); 
			TOKEN_UPDATE; return yytext[0]; }

{NAMESPACE}	{ KEYWORD_UPDATE; return NAMESPACE; }
{OPEN}		{ KEYWORD_UPDATE; return OPEN; }
{AS}		{ KEYWORD_UPDATE; return AS; }
{DEFINE}	{ KEYWORD_UPDATE; return DEFINE; }
{DEFCHAN}	{ KEYWORD_UPDATE; return DEFCHAN; }
{DEFTYPE}	{ KEYWORD_UPDATE; return DEFTYPE; }
{DEFPROC}	{ KEYWORD_UPDATE; return DEFPROC; }
{CHP}		{ KEYWORD_UPDATE; return CHP_LANG; }
{HSE}		{ KEYWORD_UPDATE; return HSE_LANG; }
{PRS}		{ KEYWORD_UPDATE; return PRS_LANG; }
{SKIP}		{ KEYWORD_UPDATE; return SKIP; }
{ELSE}		{ KEYWORD_UPDATE; return ELSE; }
{LOG}		{ KEYWORD_UPDATE; return LOG; }
{SEND}		{ KEYWORD_UPDATE; return SEND; }
{RECV}		{ KEYWORD_UPDATE; return RECV; }
{SET}		{ KEYWORD_UPDATE; return SET; }
{GET}		{ KEYWORD_UPDATE; return GET; }
{INT_TYPE}	{ KEYWORD_UPDATE; return INT_TYPE; }
{BOOL_TYPE}	{ KEYWORD_UPDATE; return BOOL_TYPE; }
{PINT_TYPE}	{ KEYWORD_UPDATE; return PINT_TYPE; }
{PBOOL_TYPE}	{ KEYWORD_UPDATE; return PBOOL_TYPE; }
{CHANNEL}	{ KEYWORD_UPDATE; return CHANNEL; }
{TRUE}		{ BOOL_UPDATE; return BOOL_TRUE; }
{FALSE}		{ BOOL_UPDATE; return BOOL_FALSE; }


{WHITESPACE}	TOKEN_UPDATE;
{NEWLINE}	NEWLINE_UPDATE;
{NULLCOMMENT} { 
	if (comment_feedback > 1) {
		fprintf(stderr, "null comment ignored ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
}
{ENDLINECOMMENT} { 
	if (comment_feedback > 1) {
		fprintf(stderr, "end-of-line comment ignored ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	TOKEN_UPDATE;
}
{FLOAT} {
	if (token_feedback) {
		fprintf(stderr, "float = %s ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	yylval.n = new token_float(atof(yytext));
	TOKEN_UPDATE;
	return FLOAT;
}

{INT}	{
	if (token_feedback) {
		fprintf(stderr, "int = %s ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	yylval.n = new token_int(atoi(yytext));
	TOKEN_UPDATE;
	return INT;
}

{ID}	{
	if (token_feedback) {
		fprintf(stderr, "identifier = \"%s\" ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	yylval.n = new token_identifier(yytext);
	TOKEN_UPDATE;
	return ID;
}

{OPENCOMMENT} {
	/* crazy... allowing nested comments */
	comment_level++;
	if (comment_feedback) {
		fprintf(stderr, "start of comment-level %d ", comment_level);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	yymore();
	MULTILINE_START(comment_pos);
	BEGIN(incomment); 
}

{OPENSTRING}	{
	if (string_feedback) {
		fprintf(stderr, "start of quoted-string ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	/* no yymore(), skip open quote */
	string_buf_ptr = string_buf;
	MULTILINE_START(string_pos);	/* just for column positioning */
	BEGIN(instring); 
}

{CLOSECOMMENT} {
	fprintf(stderr, "*/ (close-comment) found outside of <comment> ");
	LINE_COL(current);
	fprintf(stderr, "\n");
	TOKEN_UPDATE;
	exit(1);
}

{BADID}	{ 
	fprintf(stderr, "bad identifier: \"%s\" ", yytext);
	LINE_COL(current);
	fprintf(stderr, "\n");
	TOKEN_UPDATE;
	exit(1);
}
.	{
	/* for everything else that doesn't match... */
	fprintf(stderr, "unexpected character: \'%s\' ", yytext);
	LINE_COL(current);
	fprintf(stderr, "\n");
	TOKEN_UPDATE;
}

}

<incomment>{
{NULLCOMMENT}	{ /********/ /*** does nothing ***/ /********/	
	if (comment_feedback > 1) {
		fprintf(stderr, "null-comment within comment ignored ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	MULTILINE_MORE(comment_pos);
	yymore();
}
{OPENCOMMENT} {
	if (allow_nested_comments) {
		comment_level++;
		if (comment_feedback) {
			fprintf(stderr, "start of comment-level %d ", 
				comment_level);
			LINE_COL(current);
			fprintf(stderr, "\n");
		}
		MULTILINE_MORE(comment_pos);
		yymore();
	} else {
		fprintf(stderr, "nested comments forbidden, found /* ");
		LINE_COL(current);
		fprintf(stderr, "\n");
		exit(1);
	}
}

{NEWLINE}	{ MULTILINE_NEWLINE(comment_pos); yymore(); }

[^*/\n]*	|
"*"+[^/\n]	|
"/"+[^*\n]	{
	if (comment_feedback > 2) {
		fprintf(stderr, "eaten up more comment ");
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	MULTILINE_MORE(comment_pos);
	yymore();
}
{CLOSECOMMENT} {
	MULTILINE_MORE(comment_pos);
	if (comment_feedback) {
		fprintf(stderr, "end of comment-level %d ", comment_level);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	comment_level--;
	if (!comment_level) {
		BEGIN(INITIAL); 
	} else {
		yymore();
	}
}
<<EOF>>	{
	MULTILINE_MORE(comment_pos);
	fprintf(stderr, "unterminated comment, starting on line %ld, "
		"got <<EOF>>\n", comment_pos.line);
	exit(1);
}
}

<instring>{
{NEWLINE}	{
	fprintf(stderr, "unterminated quoted-string on line %ld"
		", got \\n\n", current.line);
	STRING_UPDATE;
	exit(1);
}

{MORESTRING}	{
	// do escape seqences later... need a string buffer
	char *copy = yytext;
	while (*copy) {			/* until null-termination */
		*string_buf_ptr++ = *copy++;
	}
	/* don't really need yymore, just for tracking column position here */
	STRING_UPDATE;
}

{CLOSESTRING}	{
	*string_buf_ptr = '\0';		/* null-terminate */
	if (string_feedback) {
		fprintf(stderr, "end of quoted-string: \"%s\" ", string_buf);
		LINE_COL(current);
		fprintf(stderr, "\n");
	}
	STRING_UPDATE;
	BEGIN(INITIAL);
	yylval.n = new token_quoted_string(string_buf);
	return STRING;
}

"\\0"	{ *string_buf_ptr++ = '\0';	STRING_UPDATE;	}
"\\b"	{ *string_buf_ptr++ = '\b';	STRING_UPDATE;	}
"\\f"	{ *string_buf_ptr++ = '\f';	STRING_UPDATE;	}
"\\n"	{ *string_buf_ptr++ = '\n';	STRING_UPDATE;	}
"\\r"	{ *string_buf_ptr++ = '\r';	STRING_UPDATE;	}
"\\t"	{ *string_buf_ptr++ = '\t';	STRING_UPDATE;	}
"\\\\"	{ *string_buf_ptr++ = '\\';	STRING_UPDATE;	}

{OCTAL_ESCAPE}	{
	int result;
	sscanf(yytext +1, "%o", &result);
	if ( result > 0xff ) {
		fprintf(stderr, "bad octal escape sequence %s ", yytext);
		LINE_COL(current);
		fprintf(stderr, "\n");
		exit(1);
	}
	*string_buf_ptr++ = result;
	STRING_UPDATE;
}

{BAD_ESCAPE}	{
	fprintf(stderr, "bad octal escape sequence %s ", yytext);
	LINE_COL(current);
	fprintf(stderr, "\n");
	exit(1);
}
}

%%
/****** user-code ************************************************************/

