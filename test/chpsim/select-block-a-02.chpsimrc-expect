same trace with fixed-per-event delays (using defaults) 
everything except times stamps should match because 
there is little exposed concurrency 
event queue:
	time	eid	pid	event
	0	0	0	null
a : bool a = 0
b : bool b = 0
c : bool c = 0
e : bool e = 0
step 5 
	0	0	0	null
	1	29	0	
	11	27	0	c := false
	11	28	0	e := false
	11	26	0	
event queue:
	time	eid	pid	event
	12	25	0	
a : bool a = 0
b : bool b = 0
c : bool c = 0
e : bool e = 0
time: 11
event[18]: null: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (currently not subscribed to its dependencies)
in queue: no
All event subscriptions:
step 1 
	12	25	0	
event[18]: null: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[4]: "e" : 18 
step 1 
	22	2	0	[~e]
All event subscriptions:
bool[4]: "e" : 18 
event queue:
	time	eid	pid	event
	23	17	0	
step 4 
	23	17	0	
	33	15	0	a := false
	33	16	0	b := false
	33	14	0	
event 18 still subscribed to `e' 
event queue:
	time	eid	pid	event
	43	13	0	e := true
event[18]: null: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[4]: "e" : 18 
	43	13	0	e := true
should wake up event 18, now in queue 
event queue:
	time	eid	pid	event
	53	12	0	a := false
	53	18	0	[e]
event[18]: null: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (currently not subscribed to its dependencies)
in queue: yes
All event subscriptions:
should have no more subscriptions 
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (currently not subscribed to its dependencies)
in queue: no
step 4 
	53	12	0	a := false
	53	18	0	[e]
	63	11	0	b := false
	73	10	0	a := false
event queue:
	time	eid	pid	event
	83	9	0	b := false
event 24 should be subscribed to `a' and `b' 
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[1]: "a" : 24 
bool[2]: "b" : 24 
a : bool a = 0
b : bool b = 0
c : bool c = 0
e : bool e = 1
step 2 
	83	9	0	b := false
	93	7	0	b := false
time: 93
event queue:
	time	eid	pid	event
	103	6	0	a := true
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[1]: "a" : 24 
bool[2]: "b" : 24 
now a+ should release event 24 
	103	6	0	a := true
event queue:
	time	eid	pid	event
	103	3	0	null
	113	22	0	c := c
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (currently not subscribed to its dependencies)
in queue: no
All event subscriptions:
step 2 
	103	3	0	null
	113	22	0	c := c
event queue:
	time	eid	pid	event
	113	21	0	null
event 2 should now be blocked on `e' 
event[2]: null: [~e], pid: 0, #pred: 1, succ: 17 
bool deps: 4 
source: [~e]
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[4]: "e" : 2 
step 3 
	113	21	0	null
	123	20	0	c := ~c
	133	19	0	e := false
time: 133
event 2 should be released 
event queue:
	time	eid	pid	event
	143	2	0	[~e]
event[2]: null: [~e], pid: 0, #pred: 1, succ: 17 
bool deps: 4 
source: [~e]
status: (currently not subscribed to its dependencies)
in queue: yes
All event subscriptions:
bool[4]: "e" : 18 
now event 18 is waiting for handshake on `e' 
step 5 
	143	2	0	[~e]
	144	17	0	
	154	15	0	a := false
	154	16	0	b := false
	154	14	0	
event queue:
	time	eid	pid	event
	164	13	0	e := true
time: 154
now we just let it run a while... 
