same trace with fixed-per-event delays (using defaults) 
everything except times stamps should match because 
there is little exposed concurrency 
event queue:
	time	eid	pid	event
	0	0	0	null
a : bool a = 0
b : bool b = 0
c : bool c = 0
e : bool e = 0
step 5 
	0	0	0	null
	1	29	0	
	11	27	0	c := false
	11	28	0	e := false
	11	26	0	
event queue:
	time	eid	pid	event
	12	25	0	
a : bool a = 0
b : bool b = 0
c : bool c = 0
e : bool e = 0
time: 11
event[18]: wait: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (currently not subscribed to its dependencies)
in queue: no
All event subscriptions:
step 1 
	12	25	0	
event[18]: wait: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[4]: "e" : 18 
step 1 
	12	2	0	[~e]
All event subscriptions:
bool[4]: "e" : 18 
event queue:
	time	eid	pid	event
	13	17	0	
step 4 
	13	17	0	
	23	15	0	a := false
	23	16	0	b := false
	23	14	0	
event 18 still subscribed to `e' 
event queue:
	time	eid	pid	event
	33	13	0	e := true
event[18]: wait: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[4]: "e" : 18 
	33	13	0	e := true
should wake up event 18, now in queue 
event queue:
	time	eid	pid	event
	33	18	0	[e]
	43	12	0	a := false
event[18]: wait: [e], pid: 0, #pred: 1, succ: 24 
bool deps: 4 
source: [e]
status: (currently not subscribed to its dependencies)
in queue: yes
All event subscriptions:
should have no more subscriptions 
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (currently not subscribed to its dependencies)
in queue: no
step 4 
	33	18	0	[e]
	43	12	0	a := false
	53	11	0	b := false
	63	10	0	a := false
event queue:
	time	eid	pid	event
	73	9	0	b := false
event 24 should be subscribed to `a' and `b' 
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[1]: "a" : 24 
bool[2]: "b" : 24 
a : bool a = 0
b : bool b = 0
c : bool c = 0
e : bool e = 1
step 2 
	73	9	0	b := false
	83	7	0	b := false
time: 83
event queue:
	time	eid	pid	event
	93	6	0	a := true
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[1]: "a" : 24 
bool[2]: "b" : 24 
now a+ should release event 24 
	93	6	0	a := true
event queue:
	time	eid	pid	event
	93	3	0	null
	103	22	0	c := c
event[24]: select: , pid: 0, #pred: 1, succ: 22 23 
bool deps: 1 2 
source: deterministic: {
  a -> c := c
  b -> c := c
}
status: (currently not subscribed to its dependencies)
in queue: no
All event subscriptions:
step 2 
	93	3	0	null
	103	22	0	c := c
event queue:
	time	eid	pid	event
	103	21	0	null
event 2 should now be blocked on `e' 
event[2]: wait: [~e], pid: 0, #pred: 1, succ: 17 
bool deps: 4 
source: [~e]
status: (blocked and subscribed to its dependencies)
in queue: no
All event subscriptions:
bool[4]: "e" : 2 
step 3 
	103	21	0	null
	113	20	0	c := ~c
	123	19	0	e := false
time: 123
event 2 should be released 
event queue:
	time	eid	pid	event
	123	2	0	[~e]
event[2]: wait: [~e], pid: 0, #pred: 1, succ: 17 
bool deps: 4 
source: [~e]
status: (currently not subscribed to its dependencies)
in queue: yes
All event subscriptions:
bool[4]: "e" : 18 
now event 18 is waiting for handshake on `e' 
step 5 
	123	2	0	[~e]
	124	17	0	
	134	15	0	a := false
	134	16	0	b := false
	134	14	0	
event queue:
	time	eid	pid	event
	144	13	0	e := true
time: 134
now we just let it run a while... 
