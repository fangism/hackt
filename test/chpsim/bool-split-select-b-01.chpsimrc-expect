	0	0	8	null
	10	6	3	
	20	14	3	split.C?(split.c)
	20	2	2	c.S!(0)
	20	15	3	split.I?(split.x)
	20	1	1	src.S!(true)
	30	13	3	
	40	12	3	[ split.c==0 -> ... [] split.c==1 -> ... [] split.c==2 -> ... [] split.c==3 -> ... ]
	50	8	3	split.O[0]!(split.x)
	50	16	4	snk[0].B?(snk[0].b)
	60	7	3	null
	70	6	3	
	80	14	3	split.C?(split.c)
	80	5	2	c.S!(1)
	80	15	3	split.I?(split.x)
	80	1	1	src.S!(true)
	90	13	3	
	100	12	3	[ split.c==0 -> ... [] split.c==1 -> ... [] split.c==2 -> ... [] split.c==3 -> ... ]
	110	9	3	split.O[1]!(split.x)
	110	17	5	snk[1].B?(snk[1].b)
	120	7	3	null
	130	6	3	
	140	14	3	split.C?(split.c)
	140	4	2	c.S!(2)
	140	15	3	split.I?(split.x)
	140	1	1	src.S!(true)
	150	13	3	
	160	12	3	[ split.c==0 -> ... [] split.c==1 -> ... [] split.c==2 -> ... [] split.c==3 -> ... ]
	170	10	3	split.O[2]!(split.x)
	170	18	6	snk[2].B?(snk[2].b)
	180	7	3	null
	190	6	3	
	200	14	3	split.C?(split.c)
	200	3	2	c.S!(4)
	200	15	3	split.I?(split.x)
	200	1	1	src.S!(true)
	210	13	3	
event queue:
check queue:
	(empty)
time: 220
assert-queue should fail because this is deadlocked 
split.c : int split.c = 4
assert failed: expecting non-empty event queue.
... at line 11
