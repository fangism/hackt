\- void HAC::SIM::PRSIM::State::check_structure() const
| :  checking Expr 1:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 2:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 3:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 4:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 5:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 6:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 7:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 8:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 9:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 10:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Expr 11:
| \- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| /- void HAC::SIM::PRSIM::State::check_expr(HAC::SIM::expr_index_type) const
| :  checking Node 1:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| :  checking Node 2:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| :  checking Node 3:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| :  checking Node 4:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| :  checking Node 5:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| :  checking Node 6:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| :  checking Node 7:
| \- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
| /- void HAC::SIM::PRSIM::State::check_node(HAC::SIM::node_index_type) const
/- void HAC::SIM::PRSIM::State::check_structure() const
\- void HAC::SIM::PRSIM::State::initialize()
/- void HAC::SIM::PRSIM::State::initialize()
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting pb to 1 at 0
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 1 at time 0
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting pbx to X at 0
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting wl to 0 at 0
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 2 at time 0
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting wlx to 0 at 0
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 3 at time 0
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 0
| :  event_index = 1
| :  examining node: pb
| :  former value: X
| :  new value: 1
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 1
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 1 from X -> 1
| | :  examining expression ID: 4
| | :  type: or<1> (parent: 2)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 1 X: 0(/1) pull: 1
| | :  examining expression ID: 2
| | :  type: and<2> (parent: 8)
| | :  before: ctdn: 0 X: 2(/2) pull: 2
| | :  is_and()
| | :  after : ctdn: 0 X: 1(/2) pull: 2
| | :  end of propagation.
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 1
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	0	pb : 1
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 0
| :  event_index = 2
| :  examining node: wl
| :  former value: X
| :  new value: 0
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 2
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 2 from X -> 0
| | :  examining expression ID: 3
| | :  type: or<1> (parent: 2)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 0 X: 0(/1) pull: 0
| | :  examining expression ID: 2
| | :  type: and<2> (parent: 8)
| | :  before: ctdn: 0 X: 1(/2) pull: 2
| | :  is_and()
| | :  after : ctdn: 1 X: 0(/2) pull: 0
| | :  examining expression ID: 8
| | :  type: or<2> (pull-dn: 5)
| | :  before: ctdn: 0 X: 2(/2) pull: 2
| | :  is_or()
| | :  after : ctdn: 0 X: 1(/2) pull: 2
| | :  end of propagation.
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 2
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	0	wl : 0
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 0
| :  event_index = 3
| :  examining node: wlx
| :  former value: X
| :  new value: 0
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 3 from X -> 0
| | :  examining expression ID: 6
| | :  type: or<1> (parent: 5)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 0 X: 0(/1) pull: 0
| | :  examining expression ID: 5
| | :  type: and<2> (parent: 8)
| | :  before: ctdn: 0 X: 2(/2) pull: 2
| | :  is_and()
| | :  after : ctdn: 1 X: 1(/2) pull: 0
| | :  examining expression ID: 8
| | :  type: or<2> (pull-dn: 5)
| | :  before: ctdn: 0 X: 1(/2) pull: 2
| | :  is_or()
| | :  after : ctdn: 0 X: 0(/2) pull: 0
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 0
| :  no pending event on this node being pulled down.
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 3
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	0	wlx : 0
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
precharge 
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting _pchg to 0 at 0
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 3 at time 0
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 0
| :  event_index = 3
| :  examining node: _pchg
| :  former value: X
| :  new value: 0
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 7 from X -> 0
| | :  examining expression ID: 1
| | :  type: nor<1> (pull-up: 5)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 0 X: 0(/1) pull: 1
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 1
| :  no pending event on this node being pulled up.
| :  pulling up (on or weak)
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 3 at time 10
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 7
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	0	_pchg : 0
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 10
| :  event_index = 3
| :  examining node: _bl
| :  former value: X
| :  new value: 1
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 5 from X -> 1
| | :  examining expression ID: 9
| | :  type: or<1> (pull-dn: 6)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 1 X: 0(/1) pull: 1
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: blst with pull state 1
| :  no pending event on this node being pulled down.
| :  pulling down (on or weak)
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing pending ID 3
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 5 from X -> 1
| | :  examining expression ID: 10
| | :  type: nor<1> (pull-up: 6)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 1 X: 0(/1) pull: 0
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: blst with pull state 0
| :  pending, but not excl event on this node.
| :  checking for upguard anomaly: guard=0, val=0
| \- bool HAC::SIM::PRSIM::State::__diagnose_violation(std::ostream&, uchar, HAC::SIM::event_index_type, HAC::SIM::PRSIM::Event&, HAC::SIM::node_index_type, HAC::SIM::PRSIM::NodeState&, const HAC::SIM::PRSIM::EventCause&, bool, bool)
| | :  event_update = 1
| /- bool HAC::SIM::PRSIM::State::__diagnose_violation(std::ostream&, uchar, HAC::SIM::event_index_type, HAC::SIM::PRSIM::Event&, HAC::SIM::node_index_type, HAC::SIM::PRSIM::NodeState&, const HAC::SIM::PRSIM::EventCause&, bool, bool)
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| | :  checking pending event ID: 3
| | :  ... on node blst
| | :  current pull-states: up=0, dn=1
| | :  no interference.
| | :  prior enqueued event on this node (possibly killed): 3
| | :  moving - event to event queue
| | :  enqueuing event ID 3 at time 20
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 5
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	10	_bl : 1	[by _pchg:=0]
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 20
| :  event_index = 3
| :  examining node: blst
| :  former value: X
| :  new value: 0
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 6 from X -> 0
| | :  examining expression ID: 11
| | :  type: nor<1> (pull-up: 5)
| | :  before: ctdn: 0 X: 1(/1) pull: 2
| | :  is_or()
| | :  after : ctdn: 0 X: 0(/1) pull: 1
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 1
| :  no pending event on this node being pulled up.
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 6
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	20	blst : 0	[by _bl:=1]
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting _pchg to 1 at 20
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 3 at time 20
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 20
| :  event_index = 3
| :  examining node: _pchg
| :  former value: 0
| :  new value: 1
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 7 from 0 -> 1
| | :  examining expression ID: 1
| | :  type: nor<1> (pull-up: 5)
| | :  before: ctdn: 0 X: 0(/1) pull: 1
| | :  is_or()
| | :  after : ctdn: 1 X: 0(/1) pull: 0
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 0
| :  no pending event on this node being pulled up.
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 7
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	20	_pchg : 1
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
experimenting... 
time: 20
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting wlx to 1 at 20
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 3 at time 20
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 20
| :  event_index = 3
| :  examining node: wlx
| :  former value: 0
| :  new value: 1
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 3 from 0 -> 1
| | :  examining expression ID: 6
| | :  type: or<1> (parent: 5)
| | :  before: ctdn: 0 X: 0(/1) pull: 0
| | :  is_or()
| | :  after : ctdn: 1 X: 0(/1) pull: 1
| | :  examining expression ID: 5
| | :  type: and<2> (parent: 8)
| | :  before: ctdn: 1 X: 1(/2) pull: 0
| | :  is_and()
| | :  after : ctdn: 0 X: 1(/2) pull: 2
| | :  examining expression ID: 8
| | :  type: or<2> (pull-dn: 5)
| | :  before: ctdn: 0 X: 0(/2) pull: 0
| | :  is_or()
| | :  after : ctdn: 0 X: 1(/2) pull: 2
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 2
| :  no pending event on this node being pulled down.
| :  pulling down (on or weak)
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing pending ID 3
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| | :  checking pending event ID: 3
| | :  ... on node _bl
| | :  current pull-states: up=0, dn=0
| | :  no interference.
| | :  prior enqueued event on this node (possibly killed): 3
| | :  moving - event to event queue
| | :  enqueuing event ID 3 at time 30
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 3
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	20	wlx : 1
event queue:
:  3	30	_bl : X	[from wlx:=1]	(weak)

expect _bl -> X queued 
time: 24
setting another pull-down rule on to overtake X 
\- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
| :  setting wl to 1 at 24
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing event ID 2 at time 24
/- int HAC::SIM::PRSIM::State::set_node_time(HAC::SIM::node_index_type, uchar, HAC::SIM::real_time, bool)
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 24
| :  event_index = 2
| :  examining node: wl
| :  former value: 0
| :  new value: 1
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 2
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 2 from 0 -> 1
| | :  examining expression ID: 3
| | :  type: or<1> (parent: 2)
| | :  before: ctdn: 0 X: 0(/1) pull: 0
| | :  is_or()
| | :  after : ctdn: 1 X: 0(/1) pull: 1
| | :  examining expression ID: 2
| | :  type: and<2> (parent: 8)
| | :  before: ctdn: 1 X: 0(/2) pull: 0
| | :  is_and()
| | :  after : ctdn: 0 X: 0(/2) pull: 1
| | :  examining expression ID: 8
| | :  type: or<2> (pull-dn: 5)
| | :  before: ctdn: 0 X: 1(/2) pull: 2
| | :  is_or()
| | :  after : ctdn: 1 X: 1(/2) pull: 1
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 1
| :  checking for dnguard anomaly: guard=1, val=2
| \- bool HAC::SIM::PRSIM::State::__diagnose_violation(std::ostream&, uchar, HAC::SIM::event_index_type, HAC::SIM::PRSIM::Event&, HAC::SIM::node_index_type, HAC::SIM::PRSIM::NodeState&, const HAC::SIM::PRSIM::EventCause&, bool, bool)
| | :  event_update = 1
| /- bool HAC::SIM::PRSIM::State::__diagnose_violation(std::ostream&, uchar, HAC::SIM::event_index_type, HAC::SIM::PRSIM::Event&, HAC::SIM::node_index_type, HAC::SIM::PRSIM::NodeState&, const HAC::SIM::PRSIM::EventCause&, bool, bool)
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 2
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	24	wl : 1
event queue:
:  3	30	_bl : X	[from wlx:=1]	(weak)
Fanins of node `_bl':
[after 10]	~_pchg:1 -> _bl+:1
[after 20, weak]	~blst:0 -> _bl+:1
[after 20, weak]	(wl:1 & pb:1)<1> | 
[after 20, weak]	(wlx:1 & pbx:X)<X><1> -> _bl-:1
time: 28
_bl : 1	[by _pchg:=1]
blst : 0	[by _bl:=1]
step: expect pull-down to overtake previous pull down 
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 30
| :  event_index = 3
| :  examining node: _bl
| :  former value: 1
| :  new value: X
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 5 from 1 -> X
| | :  examining expression ID: 9
| | :  type: or<1> (pull-dn: 6)
| | :  before: ctdn: 1 X: 0(/1) pull: 1
| | :  is_or()
| | :  after : ctdn: 0 X: 1(/1) pull: 2
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: blst with pull state 2
| :  no pending event on this node being pulled down.
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 5 from 1 -> X
| | :  examining expression ID: 10
| | :  type: nor<1> (pull-up: 6)
| | :  before: ctdn: 1 X: 0(/1) pull: 0
| | :  is_or()
| | :  after : ctdn: 0 X: 1(/1) pull: 2
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: blst with pull state 2
| :  no pending event on this node being pulled up.
| :  pulling up (on or weak)
| \- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| /- HAC::SIM::event_index_type HAC::SIM::PRSIM::State::__allocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::node_index_type, const HAC::SIM::PRSIM::EventCause&, HAC::SIM::rule_index_type, uchar, bool)
| :  enqueuing pending ID 3
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| | :  checking pending event ID: 3
| | :  ... on node blst
| | :  current pull-states: up=2, dn=2
| | :  some interference.
WARNING: weak-interference `blst'
>> cause: `_bl' (val: X)
| | :  moving - event to event queue
| | :  enqueuing event ID 3 at time 40
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 5
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	30	_bl : X	[by wlx:=1]
event queue:
:  3	40	blst : X	[from _bl:=X]
Fanins of node `_bl':
[after 10]	~_pchg:1 -> _bl+:X
[after 20, weak]	~blst:0 -> _bl+:X
[after 20, weak]	(wl:1 & pb:1)<1> | 
[after 20, weak]	(wlx:1 & pbx:X)<X><1> -> _bl-:X
time: 30
step 
\- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
| \- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| /- HAC::SIM::EventPlaceholder<HAC::SIM::real_time> HAC::SIM::PRSIM::State::dequeue_event()
| :  time = 40
| :  event_index = 3
| :  examining node: blst
| :  former value: 0
| :  new value: X
| \- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| | :  freeing index 3
| /- void HAC::SIM::PRSIM::State::__deallocate_event(HAC::SIM::PRSIM::NodeState&, HAC::SIM::event_index_type)
| \- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| | :  node 6 from 0 -> X
| | :  examining expression ID: 11
| | :  type: nor<1> (pull-up: 5)
| | :  before: ctdn: 0 X: 0(/1) pull: 1
| | :  is_or()
| | :  after : ctdn: 0 X: 1(/1) pull: 2
| /- HAC::SIM::PRSIM::State::evaluate_return_type HAC::SIM::PRSIM::State::evaluate(HAC::SIM::node_index_type, HAC::SIM::expr_index_type, uchar, uchar)
| :  propagated to output node: _bl with pull state 2
| :  no pending event on this node being pulled up.
| \- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| /- bool HAC::SIM::PRSIM::State::flush_pending_queue()
| \- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| /- void HAC::SIM::PRSIM::State::flush_exclhi_queue()
| \- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| /- void HAC::SIM::PRSIM::State::flush_excllo_queue()
| :  returning node index 6
/- std::pair<HAC::SIM::node_index_type, HAC::SIM::node_index_type> HAC::SIM::PRSIM::State::step()
	40	blst : X	[by _bl:=X]
time: 40
