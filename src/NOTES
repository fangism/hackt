# "NOTES"

Developer's Notes (transcripts of fangism muttering to himself...)

//=============================================================================
2005-01-05:
CRITICAL BUG: util/memory/pointer_classes:
	some destructors (excl_ptr) use release instead of reset, 
	should be reset, HOWEVER, changing to reset() causes type-check
	phase (perhaps others) to die horrible deaths.  
Currently, leave it incorrect as release(), because in the middle of 
	other modifications (need isolation).  
	Meanwhile, littered with debug code...

Added FIX_DEBUG predefine-style switch to pointer_classes.h, 
	need to isolate the problem.  
	gdb stacktrace shows functions called with an impossible call stack!
	lookup_namespace inside check_null_template_arguments !?!?
	memory corruption?
	Worst case, may need to trace EVERY pointer_class object...
	FIXED: is safe to remove this conditional macro (2005-01-11)
	Even if ONLY sticky_ptr is fixed, there is still problem!
	Problem was failed ownership transfer leading to 
		premature deallocation, and implicit defaul copy-constructor, 
		which gives wrong behavior.  
	Produce (emulate) test cases?

Time to use stacktrace!

Auto-configure debug mode vs. develop mode vs. release mode

test suit intended for develop mode or release mode

//=============================================================================
2004-12-12: Regarding unroll-time parameter resolution.

Dependencies: unroll-time type-resolution, with templates, 
	simple example being built-in datatype int<width>

Issues: need to resolve into constants, or detect error
	What kind of parameter objects do template arguments need?
	Something that can hold list of arbitrary collections, 
		guaranteed to be densely packed, but need not be implemented so.
	Currently, const_param_expr_list can only hold scalars.  
	Need an abstract placeholder besides const_param, 
		perhaps const_param_collection?
	However, we already have param_instance_collections, 
		as sparse multidimensional maps.  
	Would seem a waste to implement yet another set of arrays...

Observations:
	Assignment was already implemented as passing around flattened 
		lists of values while retaining dimensions requirements.  
		Seemed like a quick short cut to get things to work.
		We might be able to reuse this idea when "assigning"
		type parameters.  

Prerequisites: (what do I need to do...)
	For typedefs, may need a parameter value context stack.

Idea:
	An extension to passing around lists, we can implement as a
	dense vector that's arithmetically addressed, and will be 
	extensible to any number of dimensions.
	Indexed with any multikey.
	Also make a reference-array for indirection.  

//=============================================================================
regarding multikey_qmap:

	Instead of deriving in diamond-inheritance, 
	specialize multikey_qmap as a special case of multikey_map.  

//=============================================================================
