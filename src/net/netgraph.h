/**
	\file "net/netgraph.h"
	$Id: netgraph.h,v 1.1.2.6 2009/08/13 17:16:29 fang Exp $
 */

#ifndef	__HAC_NET_NETGRAPH_H__
#define	__HAC_NET_NETGRAPH_H__

#include <iosfwd>
#include <vector>
#include <string>
#include <map>
#include <set>
#include "Object/lang/cflat_context_visitor.h"

namespace HAC {
namespace NET {
using std::ostream;
using std::vector;
using std::string;
using std::map;
using std::set;
using entity::cflat_context_visitor;
using entity::state_manager;
using entity::footprint;
using entity::global_entry;
using entity::bool_tag;
using entity::process_tag;

typedef	size_t		index_type;
typedef	double		real_type;
class netlist;
class netlist_generator;
struct netlist_options;

// 0-indexed nodes or 1-indexed?
// extern const index_type	base_index = 1;

//=============================================================================
/**
	Extension of (local) node information.  
	Corresponds to an electrical node in the netlist. 
	Bother with redundant connectivity list?
 */
struct node {
	struct __logical_node_tag { };
	struct __supply_node_tag { };
	struct __internal_node_tag { };
	struct __auxiliary_node_tag { };
	static const __supply_node_tag		supply_node_tag;
	static const __logical_node_tag		logical_node_tag;
	static const __internal_node_tag	internal_node_tag;
	static const __auxiliary_node_tag	auxiliary_node_tag;
	/**
		Index may correspond to index in local bool instance pool.
	 */
	index_type			index;
	/**
		Name of node.
		Named nodes inherit their names from canonical names
		in the original local definition, possibly mangled.  
		Need disambioguous ways of naming internal and 
		auxiliary nodes.
	 */
	string				name;
	/**
		Logical nodes are those named in the original source.
		Internal nodes are special named nodes used to
		construct shared node networks.
		Supply nodes are implicit poewr supply nodes.
		Auxiliary nodes are those generated by subexpressions 
		(unnamed), and *cannot* cross subcircuit boundaries.  
	 */
	enum {
		NODE_TYPE_LOGICAL = 0,
		NODE_TYPE_INTERNAL = 1,
		NODE_TYPE_AUXILIARY = 2,
		NODE_TYPE_SUPPLY = 3
	};
	// is_named -- if this was a named node in original source, 
	//	otherwise is internal, auxiliary node.
	char				type;
	/**
		set to true if node participates in any device 
		(i.e. has any electrical connectivity whatsoever), 
		so unused nodes (e.g. in ports) can be skipped.  
	 */
	bool				used;
	// connectivity information needed? would be redundant with devices

	node(const string& s, const __supply_node_tag&) : 
		index(0), name(s), type(NODE_TYPE_SUPPLY), used(false) { }
	node(const index_type i, const __logical_node_tag&) : 
		index(i), name(), type(NODE_TYPE_LOGICAL), used(false) { }
	node(const string& s, const __internal_node_tag&) : 
		index(0), name(s), type(NODE_TYPE_INTERNAL), used(false) { }
	node(const __auxiliary_node_tag&) : 
		index(0), name(), type(NODE_TYPE_AUXILIARY), used(false) { }
	// only for VOID node
	node(const char* s, const __auxiliary_node_tag&) : 
		index(0), name(s), type(NODE_TYPE_AUXILIARY), used(false) { }
	node(const index_type a, const __auxiliary_node_tag&) : 
		index(a), name(), type(NODE_TYPE_AUXILIARY), used(false) { }


	bool
	is_logical_node(void) const { return type == NODE_TYPE_LOGICAL; }

	bool
	is_internal_node(void) const { return type == NODE_TYPE_INTERNAL; }

	// true if ndoe is automatically generated
	bool
	is_auxiliary_node(void) const { return type == NODE_TYPE_AUXILIARY; }

	ostream&
	emit(ostream&, const footprint&) const;

	ostream&
	dump_raw(ostream&) const;

};	// end struct node

//-----------------------------------------------------------------------------
/**
	Standard 4-terminal device for transistor.
 */
struct transistor {
	enum {
		NFET_TYPE,
		PFET_TYPE
	};
	/**
		Devices are somehow named after the rules from which
		they are derived.  
		TODO: need auto-enumeration
	 */
	string				name;
	index_type			source;
	index_type			gate;
	index_type			drain;
	/**
		Substrate contact.
	 */
	index_type			body;
	/// device width parameter
	real_type			width;
	/// device length parameter
	real_type			length;
	/// device type: nfet, pfet
	char				type;
	// TODO: support overriding of device type
	// e.g. hvt, lvt, svt...

	// allow a conf/tech file to define/enumerate additional types
	// attributes:
	// is_standard_keeper
	// is_combination_feedback_keeper
	char				attributes;

	template <class NP>
	void
	mark_used_nodes(NP&) const;

	template <class NP>
	ostream&
	emit(ostream&, const NP&, const footprint&, 
		const netlist_options&) const;

	ostream&
	dump_raw(ostream&) const;

};	// end struct transistor

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Generic 2-terminal device.
	Capacitor, resistor, or inductor.
 */
struct passive_device {
	/**
		Points to the two terminals.  
	 */
	index_type			t[2];
	// enum type: (R) resistor, (L) inductor, (C) capacitor
	// (D) diode should be separate as it can be tied to a model
	char				type;
};	// end struct device

//-----------------------------------------------------------------------------
/**
	Instantiation of a particular substructure type.
	spice card: x
 */
struct instance {
	/**
		Reference to subcircuit type.
		Translated from looking up netlist_map_type in the generator
		class, below.
		Can point to either a local subcircuit or externally
		defined subcircuit (associated to defproc).
		Beware of storing insertion-invalidated pointers.
	 */
	const netlist*			type;
	/**
		Local process index.
	 */
	index_type			pid;
	/**
		Port connections.
	 */
	typedef	vector<index_type>	actuals_list_type;

	actuals_list_type		actuals;

	explicit
	instance(const netlist& t, const index_type p) :
		type(&t), pid(p), actuals() { }

	template <class NP>
	ostream&
	emit(ostream&, const NP&, const footprint&) const;

	template <class NP>
	void
	mark_used_nodes(NP&) const;

	ostream&
	dump_raw(ostream&) const;

};	// end struct instance


//-----------------------------------------------------------------------------
/**
	Structures common to all netlists.  
 */
struct netlist_common {
	/**
		TODO: group transistors in a way that reflects
		original rule in PRS, if applicable.
		For now, flat list.
		TODO: print comment with origin rule before each
		group of transistors.
	 */
	typedef	vector<transistor>	transistor_pool_type;
	typedef	vector<passive_device>	passive_device_pool_type;
	transistor_pool_type		transistor_pool;
	passive_device_pool_type	passive_device_pool;

	template <class NP>
	void
	mark_used_nodes(NP&) const;

};	// end class netlist_common

//-----------------------------------------------------------------------------
/**
	Minimum requirements for any type of netlist.  
	Intended for use with subcircuits.
 */
struct local_netlist : public netlist_common {
	// does not have own list of internal nodes, defer to parent's
	// keep a local subset of nodes used, indexing into parent's collection
	// will use this
	typedef	set<index_type>		node_index_map_type;

	// name of local subcircuit, or just suffix, like :subs_0
	string				name;
	/**
		Mapping from parent node index to local node index.  
		Expected to be a sparse subset of parent's list.  
		Every node in this list will be a port of the 
		subcircuit definition.  (Maybe eventually optimize?)
		key= parent domain node index
	 */
	node_index_map_type			node_index_map;

	// does NOT have local subinstances, only devices

	// requires a parent netlist for reference
	ostream&
	emit(ostream&, const netlist& n) const;
};	// end class local_netlist

//-----------------------------------------------------------------------------
/**
	A graph.
	One netlist corresponds to a subcircuit, or in HAC a unique footprint.  
	TODO: support for special global nodes like Vdd, GND?
		can be automatic or overridden.
	Beware of using vectors and accidentally invalidating references
	and iterators after tail-insertion, which may cause reallocation.  
 */
class netlist : public netlist_common {
	/**
		Keep around footprint for node reference and printing.
	 */
	const footprint*		fp;
public:
friend class netlist_generator;
	/**
		Collection of physical nodes, can be from logical nodes, 
		internal nodes, or auxiliary nodes, or supply nodes.  
	 */
	typedef	vector<node>		node_pool_type;
	/**
		Collection of internal nodes.  
		key= prs footprint's local expression index for internal node
		value= index into node_pool for node
		For now, internal nodes are scoped in flat namespace
	 */
	typedef	map<index_type, index_type>	internal_node_map_type;
	/**
		index= local footprint index of node
		value= netlist index of node
		Information is somewhat redundant, but provides
		a reverse map.  
		0-value means node has not been used yet.  
	 */
	typedef	vector<index_type>	named_node_map_type;
	/**
		For local subcircuits only.  
		Such local circuits are not shared outside of this definition
		and are only instantiated once.  
		Not using map because subcircuits may be anonymous. 
	 */
	typedef	vector<local_netlist>	local_subcircuit_list_type;
	typedef	vector<instance>	instance_pool_type;
	/**
		Indices refer to local nodes which need not be the 
		exact same set of local port aliases.
		May include Vdd, GND.
		Internal nodes cannot be ports.  
	 */
	typedef	vector<index_type>	port_list_type;
private:
	/**
		Name can be inferred from the hierarchical name 
		of the footprint.  Will have to be mangled 
		so we save the result.  
	 */
	string				name;
	named_node_map_type		named_node_map;
	/**
		All local nodes, including ports and internal nodes.
		This is only stored in the primary netlist, 
		whereas the local subcircuit netlists use indirect
		references to parents' nodes.  
	 */
	node_pool_type			node_pool;
	instance_pool_type		instance_pool;
	internal_node_map_type		internal_node_map;
	local_subcircuit_list_type	local_subcircuits;
	/**
		List of local node indices.  
		NOTE: there cannot be any aliases in the ports.  
		Does not include GND and Vdd, which are handled separately.
	 */
	port_list_type			port_list;
	/**
		Running count of generated auxiliary nodes.
	 */
	index_type			aux_count;

public:
	netlist();
	~netlist();

	void
	bind_footprint(const footprint&, const netlist_options&);

	const string&
	get_name(void) const { return name; }

	index_type
	create_auxiliary_node(void);

	// TODO: combine lookup and create!
	index_type
	create_internal_node(const index_type, const string&);

	index_type
	lookup_internal_node(const index_type) const;

	index_type
	register_named_node(const index_type);

	bool
	named_node_is_used(const index_type) const;

	void
	append_instance(const global_entry<process_tag>&, const netlist&, 
		const index_type);

	void
	summarize_ports(void);

	ostream&
	emit(ostream&, const bool s, const netlist_options&) const;

	ostream&
	dump_raw(ostream&) const;

private:
	void
	mark_used_nodes(void);

};	// end class netlist

//=============================================================================
/**
	Overrideable options (configure).
	Many names borrowed from netgen for consistency and compatibility.
 */
struct netlist_options {
// geneeration-time options:
	/**
		Dimensions of standard devices to use when unspecified.  
		In absolute units instead of lambda.
	 */
	real_type			std_n_width;
	real_type			std_p_width;
	real_type			std_n_length;
	real_type			std_p_length;
	/**
		Dimensions of feedback (staticizer, keeper) devices 
		when unspecified.  
		In absolute units instead of lambda.
	 */
	real_type			stat_n_width;
	real_type			stat_p_width;
	real_type			stat_n_length;
	real_type			stat_p_length;

// output-time options:
	/**
		Units to be appended, e.g. "u" (micron), "e-1u", 
		"n" (nanometer).
	 */
	string				length_unit;
	/**
		lambda, or unit scale factor multiplier.
	 */
	real_type			lambda;
	/**
		Emit nested subcircuits.
		Othewise, emit subcircuit definitions prior to use.  
	 */
	bool				nested_subcircuits;
	/**
		If true, emit top-level instances and rules, otherwise, 
		emit only subcircuit definitions (library-only).
	 */
	bool				emit_top;

	netlist_options();
};	// end struct netlist_options

//=============================================================================
/**
	Visitor to do all the heavy-lifting and traversal.  
	TODO: warn against instantiating port processes with production rules.
	Would the rules belong to the caller or the callee?
	Certainly should NOT be duplicated.
	This is the reason for deftype, defchan, etc.
 */
class netlist_generator : public cflat_context_visitor {
	/**
		Primary structure for maintaining prerequisite ordering
		of emitting dependent subcircuits before they are used.
		Don't actually know if spice requires subcircuits
		to be defined before used, but this is safe.
		This way, only circuits that are used are emitted.
	 */
	typedef	std::map<const footprint*, netlist>
					netlist_map_type;
	typedef	entity::PRS::footprint	prs_footprint;
private:
	ostream& 			os;
	const netlist_options&		opt;
	netlist_map_type		netmap;

// local data used only during traversal:
	/**
		Need this for back-reference to expression pool.
	 */
	const prs_footprint*		prs;
	// need a place to hold netlist that belong to subcircuits
	// which don't have associated footprints, for now might 
	// only keep them around temporarily and locally
	netlist*			current_netlist;
	/**
		Where devices are to be added.  
		Can point to either primary subcircuit
		or local subcircuit.  
	 */
	netlist_common*			current_local_netlist;
	/**
		Usually GND, used for precharge, and local prs override.
		Overridden by prs <Vdd, GND>
	 */
	index_type			low_supply;
	/**
		Usually Vdd, used for precharge, and local prs override.
	 */
	index_type			high_supply;
	/**
		The base node (initially, Vdd/GND) to connect to the source
		terminal of the next device/expression.  
		This is necessary to correctly connect OR'd expressions.  
	 */
	index_type			foot_node;
	/**
		The output node (initially NULL) produced by the 
		last expression.  
	 */
	index_type			output_node;
	/**
		Default transistor is used unless overridden by directive.
		Usually determined by direction of pull of rule, 
		or pass-gate type.
	 */
	char				fet_type;
	/**
		In expression traversal, whether or not this level
		of expression is negated.  
		Use for automatic negation-normalization and
		CMOS-implementability checking.  
	 */
	bool				negated;
	/**
		The last specified device width, for automatic propagation.  
	 */
	real_type			last_width;
	/**
		The last specified device length, for automatic propagation.  
	 */
	real_type			last_length;
public:
	netlist_generator(const state_manager& _sm, 
		const footprint& _topfp, ostream& o, const netlist_options& p);
	~netlist_generator();

	// go!!!
	void
	operator () (void);

	void
	visit(const global_entry<process_tag>&);

	using cflat_context_visitor::visit;

	void
	visit(const global_entry<bool_tag>&);		// do nothing?
	void
	visit(const state_manager&);		// only visit processes
	void
	visit(const footprint&);
	void
	visit(const entity::PRS::footprint&);		// override
	void
	visit(const entity::PRS::footprint_rule&);
	void
	visit(const entity::PRS::footprint_expr_node&);		// do nothing?
	void
	visit(const entity::PRS::footprint_macro&);

	void
	visit(const entity::SPEC::footprint&);			// do nothing
	void
	visit(const entity::SPEC::footprint_directive&);	// do nothing

};	// end class netlist_generator

//=============================================================================

}	// end namespace NET
}	// end namespace HAC

#endif	// __HAC_NET_NETGRAPH_H__

