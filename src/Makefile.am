# "src/Makefile.am"
#	$Id: Makefile.am,v 1.35 2004/12/25 03:12:19 fang Exp $

AUTOMAKE_OPTIONS = 1.9 subdir-objects

SUBDIRS = util/test .

SUFFIXES = .yy .ll

include $(top_srcdir)/Make.stddef


###################### Are we using yacc or bison? ############################

# use autoconf-defined HAVE_BISON
GREP_FOR_BISON = $(GREP) "^YACC =" Makefile | $(GREP) -q bison

LEXYACC_PREFIX_SCRIPT = $(srcdir)/parser/lexyacc-prefix.awk

if HAVE_BISON
YACC_UNION_SCRIPT = $(srcdir)/parser/bison-union-type.awk
YACC_OUTPUT_H_SCRIPT = $(srcdir)/parser/bison-output-to-C.awk
parser/yacc_or_bison.h:
	@$(ECHO) "// \"$@\"" > $@
	@$(ECHO) "// automatically generated by Makefile" >> $@
	@$(ECHO) "#define USING_BISON 1" >> $@
	@$(ECHO) "#define USING_YACC 0" >> $@
else
YACC_UNION_SCRIPT = $(srcdir)/parser/yacc-union-type.awk
YACC_OUTPUT_H_SCRIPT = $(srcdir)/parser/yacc-output-to-C.awk
parser/yacc_or_bison.h:
	@$(ECHO) "// \"$@\"" > $@
	@$(ECHO) "// automatically generated by Makefile" >> $@
	@$(ECHO) "#define USING_BISON 0" >> $@
	@$(ECHO) "#define USING_YACC 1" >> $@
endif
# Automatically generated sources can just check for YYBISON definition.



########################### main dependencies #################################

bin_PROGRAMS = artc art++2obj artobjdump artobjunroll

noinst_PROGRAMS = art_persistent_table

# need to list auto-generated header first to guarantee correct build
# order in parallel builds.  

artc_SOURCES = art_main.cc
art_main.$(OBJEXT) art_main.lo: parser/art++-parse-prefix.h
artc_LDADD = libart++.la

art__2obj_SOURCES = art++2obj.cc
art++2obj.$(OBJEXT) art++2obj.lo: parser/art++-parse-prefix.h
art__2obj_LDADD = libart++.la

artobjdump_SOURCES = artobjdump.cc
artobjdump_LDADD = libart++.la

artobjunroll_SOURCES = artobjunroll.cc
artobjunroll_LDADD = libart++.la

art_persistent_table_SOURCES = test/art_persistent_table.cc
art_persistent_table_LDADD = libart++.la

# convenience libraries
noinst_LTLIBRARIES = libart++.la libbogus.la

# need these first!  (easy to just stick them here)
BUILT_SOURCES = parser/yacc_or_bison.h parser/art++-parse.h \
	parser/art++-parse.output.h

# libbogus.la is not actually used, hence the name.
# force use of lex/yacc suffix rules to generate the .c and .cc files
# the source files are post-processed via awk (below) into the real sources, 
# with symbol names with transformed prefixes.  
libbogus_la_SOURCES = \
	lexer/art++-lex.ll \
	parser/art++-parse.yy

# parser/libbogus_la-art++-parser.$(OBJEXT) \
#	parser/libbogus_la-art++-parser.lo \
#	parser/art++-parse.cc : parser/art++-parse.output.h

# parser/art++-parse-prefix.$(OBJEXT) \
#	parser/art++-parse-prefix.lo \
#	parser/art++-parse-prefix.cc : parser/art++-parse.output.h

AST_CC_FILES = \
	AST/art_parser_base.cc \
	AST/art_parser_expr.cc \
	AST/art_parser_token.cc \
	AST/art_parser_definition.cc \
	AST/art_parser_instance.cc \
	AST/art_parser_formal.cc \
	AST/art_parser_chp.cc \
	AST/art_parser_hse.cc \
	AST/art_parser_prs.cc

AST_H_FILES = $(AST_CC_FILES:.cc=.h) \
	AST/art_parser_fwd.h \
	AST/art_parser.h \
	AST/art_parser.tcc \
	AST/art_parser_debug.h

# all of these .cc files have a corresponding .h file
OBJECT_CC_FILES = \
	Object/art_context.cc \
	Object/art_object_base.cc \
	Object/art_object_expr.cc \
	Object/art_object_definition.cc \
	Object/art_object_type_ref.cc \
	Object/art_object_instance.cc \
	Object/art_object_instance_param.cc \
	Object/art_object_instance_bool.cc \
	Object/art_object_instance_int.cc \
	Object/art_object_instance_enum.cc \
	Object/art_object_instance_struct.cc \
	Object/art_object_instance_proc.cc \
	Object/art_object_instance_chan.cc \
	Object/art_object_instance_management_base.cc \
	Object/art_object_inst_ref.cc \
	Object/art_object_inst_ref_data.cc \
	Object/art_object_inst_stmt.cc \
	Object/art_object_assign.cc \
	Object/art_object_connect.cc \
	Object/art_object_control.cc \
	Object/art_object_module.cc \
	Object/art_object_namespace.cc \
	Object/art_built_ins.cc

# these source files have no .h file (use other name)
OBJECT_CC_NO_H_FILES = \
	Object/art_object_instance_pint.cc \
	Object/art_object_instance_pbool.cc

# these header files have source (.cc) files with different names
OBJECT_H_FILES = $(OBJECT_CC_FILES:.cc=.h) \
	Object/art_object_fwd.h \
	Object/art_object.h \
	Object/art_object_definition_base.h \
	Object/art_object_expr_base.h \
	Object/art_object_expr_const.h \
	Object/art_object_expr_param_ref.h \
	Object/art_object_instance_base.h \
	Object/art_object_instance_management_base.h \
	Object/art_object_inst_stmt_base.h \
	Object/art_object_inst_ref_base.h \
	Object/art_object_type_ref_base.h \
	Object/art_object_type_hash.h

UTIL_HEADER_FILES = \
	util/art_debug.h \
	util/art_switches.h \
	util/macros.h \
	util/STL/allocator_fwd.h \
	util/STL/deque_fwd.h \
	util/STL/functional_fwd.h \
	util/STL/list_fwd.h \
	util/STL/list.h \
	util/STL/list.tcc \
	util/STL/map_fwd.h \
	util/STL/map.h \
	util/STL/map.tcc \
	util/STL/namespace.h \
	util/STL/pair_fwd.h \
	util/STL/valarray_fwd.h \
	util/IO_utils.h \
	util/IO_utils.tcc \
	util/array_traits.h \
	util/discrete_interval_set_fwd.h \
	util/discrete_interval_set.h \
	util/discrete_interval_set.tcc \
	util/getopt_portable.h \
	util/hash_map.h \
	util/hash_qmap_fwd.h \
	util/hash_qmap.h \
	util/hash_qmap.tcc \
	util/hash_specializations.h \
	util/indent.h \
	util/likely.h \
	util/list_vector_fwd.h \
	util/list_vector.h \
	util/list_vector.tcc \
	util/memory/list_vector_pool.h \
	util/memory/pointer_classes_fwd.h \
	util/memory/pointer_classes.h \
	util/memory/pointer_traits.h \
	util/multidimensional_qmap_fwd.h \
	util/multidimensional_qmap.h \
	util/multidimensional_qmap.tcc \
	util/multidimensional_sparse_set_fwd.h \
	util/multidimensional_sparse_set.h \
	util/multidimensional_sparse_set.tcc \
	util/multikey_fwd.h \
	util/multikey.h \
	util/multikey.tcc \
	util/multikey_map_fwd.h \
	util/multikey_map.h \
	util/multikey_map.tcc \
	util/multikey_qmap_fwd.h \
	util/multikey_qmap.h \
	util/multikey_qmap.tcc \
	util/nested_iterator.h \
	util/operators.h \
	util/packed_array.h \
	util/packed_array.tcc \
	util/persistent.h \
	util/persistent_object_manager.h \
	util/persistent_object_manager.tcc \
	util/qmap_fwd.h \
	util/qmap.h \
	util/qmap.tcc \
	util/sstream.h \
	util/stacktrace.h \
	util/string_fwd.h \
	util/sublist.h \
	util/sublist.tcc \
	util/unique_list.h \
	util/unique_list.tcc \
	util/using_istream.h \
	util/using_ostream.h \
	util/binders.h \
	util/compose.h \
	util/conditional.h \
	util/ptrs_functional.h \
	util/obsolete/ptrs.h \
	util/obsolete/ptrs_fwd.h \
	util/obsolete/count_ptr.h \
	util/obsolete/count_ptr_fwd.h

# the generated lexer and parser sources aren't supposed to be distributed!
libart___la_SOURCES = \
	parser/yacc_or_bison.h \
	parser/art++-parse-prefix.h \
	parser/art++-parse-prefix.cc \
	parser/art++-union.cc \
	parser/art++-parse.output.h \
	lexer/art++-lex-prefix.cc \
	lexer/art_lex.cc \
	lexer/art_lex.h \
	$(AST_CC_FILES) $(AST_H_FILES) \
	$(UTIL_HEADER_FILES) \
	util/IO_utils.cc \
	util/indent.cc \
	util/persistent.cc \
	util/persistent_object_manager.cc \
	util/stacktrace.cc \
	$(OBJECT_CC_FILES) $(OBJECT_H_FILES) \
	$(OBJECT_CC_NO_H_FILES) \
	Object/art_object_IO.cc \
	config.h \
	art++.h

# note: Object/art_object_IO.cc only contains explicit template instantiations

# don't actually need -l[f]l
# libart___la_LDADD = @LEXLIB@


ARTXX_YACC_PREFIX = artxx_

# rules for the prefix-transformed versions of generated lexer/parser sources
# make these conditional on yacc vs. bison
if HAVE_BISON
parser/art++-parse-prefix.cc: parser/art++-parse.cc
	$(AWK) -f $(srcdir)/parser/yyerror_bison_hack.awk $? | \
	$(AWK) -f $(LEXYACC_PREFIX_SCRIPT) \
		-v PREFIX=$(ARTXX_YACC_PREFIX) > $@
else
parser/art++-parse-prefix.cc: parser/art++-parse.cc
	$(AWK) -f $(LEXYACC_PREFIX_SCRIPT) \
		-v PREFIX=$(ARTXX_YACC_PREFIX) $? > $@
endif

parser/art++-parse-prefix.h: parser/art++-parse.h
	$(AWK) -f $(LEXYACC_PREFIX_SCRIPT) \
		-v PREFIX=$(ARTXX_YACC_PREFIX) $? > $@

lexer/art++-lex-prefix.cc: lexer/art++-lex.cc
	$(AWK) -f $(LEXYACC_PREFIX_SCRIPT) \
		-v PREFIX=$(ARTXX_YACC_PREFIX) $? > $@

# can't depend on the .output alone, not a known dependence with .y[y]
ARTXX_PARSE_OUTPUT = parser/art++-parse.output
$(ARTXX_PARSE_OUTPUT): parser/art++-parse.h

$(ARTXX_PARSE_OUTPUT).h: $(ARTXX_PARSE_OUTPUT)
	@if $(GREP) "conflict" $?; then exit 1; fi
	$(AWK) -f $(YACC_OUTPUT_H_SCRIPT) $? | \
	$(AWK) -f $(LEXYACC_PREFIX_SCRIPT) \
		-v PREFIX=$(ARTXX_YACC_PREFIX) > $@


parser/art++.types: parser/art++-parse.yy
	$(CAT) $? | $(GREP) -v "#include" | $(CPP) -P | $(GREP) -v pragma | \
		$(SED) -e "/^%start/,$$$$d" -e "/%{/,/%}/d" | \
		$(SED) '/^[ \t]*$$/d' > $@

# extract num: first matched line, 3rd space-delimited field (#define foo bar)
# "cut" is not a good idea, if # define is separated... :(
# the last awk pipe eliminate extraneous whitespace not filtered by sed
GET_START_TOKEN_ENUM = \
	$(GREP) "define.*MINIMUM_BOGOSITY" parser/art++-parse.h | \
		$(HEAD) -n1 | $(SED) 's/^.*MINIMUM_BOGOSITY[ \t]*//g' | \
		$(AWK) '/.*/{printf($$1);}'


YACC_UNION_SCRIPT_ARGS = -v yaccfile=parser/art++.types \
		-v include="art_parser.h art++-parse-prefix.h" \
		-v namespace=ART::parser \
		-v type=ART::parser::node \
		-v token_enum=`$(GET_START_TOKEN_ENUM)`
# so far, yacc token enums start at 257 consistently, but we take no chances.

parser/art++-union.cc: $(ARTXX_PARSE_OUTPUT) parser/art++.types parser/art++-parse-prefix.h
	$(AWK) -f $(YACC_UNION_SCRIPT) \
		$(YACC_UNION_SCRIPT_ARGS) parser/art++-parse.output > $@


AM_CPPFLAGS = -DREGRESSION_TEST_MODE \
	-I$(srcdir)/parser -I$(srcdir)/util -I$(srcdir)/AST \
	-I$(srcdir)/lexer -I$(srcdir)/AST -I$(srcdir)/Object \
	-Iparser
# will need _build directories for "make distcheck" with auto-generated headers
# the last -Iparser is for the relative path in the build directory

# extremely anal-retentive
MORE_CFLAGS = -pipe -W -Wall -Wno-unused -Werror

AM_CFLAGS = $(MORE_CFLAGS)
AM_CXXFLAGS = $(MORE_CFLAGS)

AM_YFLAGS = -d -t -v
AM_LFLAGS = 

# doesn't work
# YACC_PREFIX = -DYACC_PREFIX=artxx_yy
# libart___la_CPPFLAGS = $(YACC_PREFIX) $(AM_CPPFLAGS)

# *COUGH* *HACK*:
# NO_FANCY_YYERROR tells lexer/art++-lex.cc to use un-transfomed symbol names
libbogus_la_CPPFLAGS = -DNO_FANCY_YYERROR $(AM_CPPFLAGS)

# artc_CPPFLAGS = $(AM_CPPFLAGS)
# art__2obj_CPPFLAGS = $(AM_CPPFLAGS)
# artobjdump_CPPFLAGS = $(AM_CPPFLAGS)

EXTRA_DIST = \
	parser/lexyacc-prefix.awk \
	parser/yacc-output-to-C.awk \
	parser/bison-output-to-C.awk \
	parser/yacc-union-type.awk \
	parser/bison-union-type.awk \
	parser/yyerror_bison_hack.awk \
	util/README \
	util/TODO \
	util/STL/README \
	util/obsolete/README \
	wc-l

TESTS = art_persistent_table

CLEANPARSER = \
	parser/yacc_or_bison.h \
	parser/art++-parse.$(OBJEXT) \
	parser/art++-parse.lo \
	parser/art++-parse.cc \
	parser/art++-parse.h \
	parser/art++-parse-prefix.lo \
	parser/art++-parse-prefix.$(OBJEXT) \
	parser/art++-parse-prefix.cc \
	parser/art++-parse-prefix.h \
	parser/art++-parse.output \
	parser/art++-parse.output.h \
	parser/libbogus_la-art++-parse.lo \
	parser/libbogus_la-art++-parse.$(OBJEXT) \
	parser/art++-union.lo \
	parser/art++-union.$(OBJEXT) \
	parser/art++-union.cc \
	parser/art++.types

CLEANLEXER = \
	lexer/art++-lex-prefix.$(OBJEXT) \
	lexer/art++-lex-prefix.lo \
	lexer/art++-lex-prefix.cc \
	lexer/art++-lex.cc \
	lexer/libbogus_la-art++-lex.lo \
	lexer/libbogus_la-art++-lex.$(OBJEXT)

CLEANFILES = $(CLEANPARSER) $(CLEANLEXER)

DISTCLEANFILES = 

clean-parser:
	-$(RM) $(CLEANPARSER)

clean-lexer:
	-$(RM) $(CLEANLEXER)

clean-AST:
	-$(RM) AST/*.$(OBJEXT)
	-$(RM) AST/*.lo

clean-Object:
	-$(RM) Object/*.$(OBJEXT)
	-$(RM) Object/*.lo

CLEANSUBDIRS = lexer parser AST Object util

# implies CLEANFILES
clean-local: clean-AST clean-Object clean-lexer clean-parser
	for d in $(CLEANSUBDIRS); do \
		$(RM) $$d/*.loT ; \
	done

dist-hook:
	for f in $(DISTCLEANFILES) $(CLEANFILES); do \
		$(RM) $(distdir)/$$f ; \
	done

