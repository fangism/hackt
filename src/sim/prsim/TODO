"sim/prsim/TODO"
#	$Id: TODO,v 1.4.8.3 2008/01/21 23:02:51 fang Exp $

===============================================================================
Simulation:

	Little buglet:
	* when interpreter reports syntax error, position is wrong because
		the construction of each token-position uses the 
		hackt-lexer/AST's global node_position.  
		the instref-lexer is incrementing only it's own private
		position counter.  This can be addressed by using a 
		stack of token positions, once we get to more advanced
		lexer generation manipulation.  Then each lexer/parser
		may use it's own and temporarily save away the previous
		counter.  

prsim:
	Add guile/Scheme interface for static queries and simulation control!
	
	category of 'debug' commands for inspecting state, etc...

	weak vs. possible: rename formerly 'weak' anomalies to 'possible'
		to avoid confusion with weak-rules.  (poor naming)

	direction-specific breakpoints

	breakpoint policies *per-node*
	breakpoint options: halt or error-out

	timestamp last causes -- automatic cycle time
		Will cost some more memory per node.
		Difficulty: easy (hour)

	deadlock diagnosis, akin to backtrace, but using fanin state analysis
		commands 'why' and 'whynot'.
		Difficulty: easy (few hours)

	unstab attribute: is checked on nodes, but only applied to rules
		so this needs to be fixed to check for rules.  
		Should wipe it from node attributes.
		Difficulty: easy (few hours)
		Q: what should unstable policy do? dequeue? re-queue overtake?
		This would require events to track which *rule* caused firing.

	interpreter commands:
		interp key [value]
			for interpreter mode flags:
			termination conditions: assert, syntax error, 
				bad-argument,...
			echo on, echo off (only heeded in batch mode)
		watch processes and structures?
		'getall-unique' (remove duplicates)
		vector support:
			Q: do we allow nodes to belong to multiple vectors?
				current state of old prsims cannot.
		use getopt-style interpretation?
		fix 'getall' to work with arrays (getall x, where x is array)
			dies on member arrays, but not top-level arrays
		line-continuation with '\'

	concept of environment variables?

	far future: expression evaluation! variable expansion!
		make use of existing interpreter functions in parser/
		better yet: attach guile Scheme interpreter (gprsim)

	Q: should initialize clear the watching state?
		in the old prsim, watch/break points are preserved
		so we keep that behavior for now.  

	for cleanliness:
		rewrite event queuing system to go through
			a pending map first before entering queue.
		rationale: current algorithm is a mess of cases.

	checking: mode to verify that all rules are CMOS implementable

	minor bug: fanout prints duplicate rules because literal
		may appear in different branches of same rule.  
		fix: collect unique-list (or set), then print

	trace recording, playback, and analysis (like chpsim)

graph-dumping:
	after restructuring rule maps by process (like chpsim),
	print out graph node in process clusters

execution model:
	weak rules (drive floating nodes, overpowered by normal rules)
		[status: drafted]
	TODO: interaction with coerced exclusive hi/lo rings?

mk and check rings:
	sort/order rings to eliminate duplicates which arise from
		poor hierarchy in the source.  
		e.g. use lexicograpichal ordering.  
		[difficulty: easy]
	filter rings that are strict subsets of others (redundancy)
		[difficulty: more difficult, got algorithm?]

state-allocation:
	consider alternative to re-allocating every rule for every
	instance, when the footprint can be reused, by adding
	one additional lookup through the parent process' footprint-frame.  
	Trade-off performance for memory (scalability).  
	This is similar to the idea behind chpsim's CHP footprints.  
	Instead of event-ids, we'll have expanded rule-ids.  
	Will be interesting to benchmark.  

sprsim:
	size-based timing prsim
	connect with chpsim in mixed simulation
	back for back-annotating sized-based delays to chpsim

grusim (pronounced 'gruesome')
	the GRand Unified SIMulator, haha.

parallelization:
	be able to run multiple instances of a manually partitioned
		hacprsim, by connecting their top-level instances
		through an interface, and managing through a 
		meta simulator (one simulator to combine them).  
		Might be able to multi-thread this way?

===============================================================================
