#!/usr/bin/awk -f
# "yacc-union-type.awk"
# David Fang, 2004
#	$Id: yacc-union-type.awk,v 1.3 2004/11/02 07:52:08 fang Exp $

# DISCLAIMER:
# Not guaranteed to work on 'bison -y' output, 
# only tested for traditional yacc.
# See "bison-union-type.awk"

# the goal of this script is to produce:
# a C function that takes as arguments:
#	a union object
#	a pair of states (enumerated) representing a transition
#		between states of the parser
# and returns a pointer to the correct member
#	as a pointer to a super-class of all members
# to use this function, make an external decaration reference to
# extern <base-type>* yy_union_resolve(const YYSTYPE&, const short, const short);

# To accomplish this, we need to know what state the parser was in
# when a particular symbol was shifted onto the stack.  
# What we have available when the parser encounters a syntax error
# are the entire state stack and value stack.  
# Walking the state stack from bottom to top tells us the precise
# state stransitions.  
# Where do we look up union-member type given the state transition?
# It's not in y.tab.c because it has no need to go figure out what
# the type IS, only that types match where they are expected.  
# We leverage the "human-readable" output of yacc, namely the -v option
# which produces "y.output".  
# y.output conveniently contains the information about what symbols caused
# transitions from one state to the next.  
# We just have to translate them into a form that can be used by C.  
# more on this later...

# input variables:
# type = the super-base class of all union members (without pointer)
#	the yacc file alone doesn't know anything about classes
# yaccfile = the yacc input file, preferably preprocessed with the command:
#	suggetsed creation of intermediate file:
#	grep -v "#include" <yacc-file.y> | cpp -P |
#		sed -e "/^%start/,$$$$d" -e "/%{/,/%}/d"
# enumfile = "y.tab.h" for symbol enumerations
# include (optional) = space-delimited list of headers to include
# namespace (optional) = space-delimited list of namespaces to use

# criteria for the union type for yylval:
# all members of the union must be pointers to classes with a common
# parent class.  

BEGIN {
	go_union = 0;
	member_count = 0;
	state_count = 0;

	if (yaccfile == "") {
		print "\"yaccfile\" must be defined as an argument!";
		exit 1;
	} 
	if (type == "") {
		print "\"type\" must be defined as an argument!";
		exit 1;
	}

	print "/*";
	print "This file was automatically generated by:";
	printf("awk -f yacc-union-type.awk -v type=" type " -v yaccfile=" \
		yaccfile " ");
	if (include != "") printf("-v include=\"" include "\" ");
	if (namespace != "") printf("-v namespace=\"" namespace "\" ");
	if (token_enum != "") printf("-v token_enum=\"" token_enum "\" ");
	print "<processed yacc-file>";
	print "*/";
	print "";

	# user-defined token symbols are enumerater from 257 and higher
	# allow this to be overriden by external automatic detection
	if (!length(token_enum))
		token_enum = 256 +1;	# default

	# need namespace first, before including headers
	# but namespaces need to be opened and declared before used!
	nns = split(namespace, ns_array);
	for (i=1; i<= nns; i++) {
		delete spaces;		# clear first
		depth = split(ns_array[i], spaces, "::");
		# just open and close (nested)
		for (j=1; j <= depth; j++)
			print "namespace " spaces[j] " {";
		for (j=1; j <= depth; j++)
			print "}";
		print "using namespace " ns_array[i] ";";
	}
	print "";

	nincs = split(include, inc_array);
	for (i=1; i<= nincs; i++) {
		print "#include \"" inc_array[i] "\"";
	}
	print "";

#	print "#include \"y.tab.h\"";	# for YYSTYPE
#		but is not always named y.tab.h! add to the "include" variable
	print "#include <assert.h>";
#	print "#include <iostream.h>";
	print "";

	process_union(yaccfile);
	process_symbol_types(yaccfile);

	print "#ifndef NULL";
	print "#define NULL\t0";
	print "#endif";
	print "";

	print "/* basic linked-list node with state key and union member type enumeration */";
	print "typedef struct _yy_state_map_link_ yy_state_map_link;";
	print "struct _yy_state_map_link_ {";

# no need for const-ness if the links are all static global constants
# also eliminates need for explicit constructor in gcc-3.2, 
# can use struct assignment, costs less compile-time memory than
# using constructors.  
#	print "\tconst int state;\t\t/* state number to match */";
#	print "\tconst int type_enum;\t\t/* enumerated type */";
	print "\tint state;\t\t/* state number to match */";
	print "\tint type_enum;\t\t/* enumerated type */";
	print "\tconst yy_state_map_link* next;";

#	gcc-3.2 requires constructor-style with non-static consts
#	print "\t_yy_state_map_link_(const int s, const int e, const yy_state_map_link* n) :";
#	print "\t\tstate(s), type_enum(e), next(n) { }";

	print "};";
	print "";

	print "/**";
	print "\tUse this function to resolve the union member type.";
	print "\t\\param u the union object to resolve.";
	print "\t\\param i the previous state of the transition.";
	print "\t\\param j the current state of the transition.";
	print "\t\\return wrapped pointer as the ultimate base type.";
	print " */";
	print type "*";
	print "yy_union_resolve(const YYSTYPE& u, const short i, const short j);";
	print "";
	print type "*";
	print "yy_union_lookup(const YYSTYPE& u, const int c);";
	print "";
}

function process_union(file, 
	# local variables
	member_type, member_id ) {
if (!got_union) {
	do { getline < file; } while(!match($0, "%union.*{"));
	# then we know we're in a union
	while (getline < file) {
	if (match($0, "[}]"))
		break;
	else if (NF >= 2) {
		member_type = $1;
		member_id = $2;
		gsub(";", "", member_id);
		# pointer handling, depends on here pointer is placed
		# only handles single pointers for now
		if (match(member_id,"[*]")) {
			gsub("[*]", "", member_id);
			member_type += "*";
		} else if (!match(member_type, "[*]")) {
			printf "union member must be a pointer!";
			exit 1;
		}
		type_of[member_id] = member_type;
#		print "union member " member_id " has type " member_type;
		enum_of[member_type] = member_count;
		member_id_array[member_count] = member_id;
		member_count++;
	}
	# else ignore line
	}	# end while
	got_union = 1;
}}

function process_symbol_types(file, 
	# local variables
	argc, i, member_id, member_type, symbol_id, first_symbol ) {
if (got_union) {
	while(getline < file) {
	argc = split($0, type_args);
	if (match($1,"%token") || match($1,"%type")) {
	# fix: need to handle un-typed tokens
	if (argc >= 2) {			# was 3
		# check if first item is a union member reference
		member_id = type_args[2];

		if (match(member_id, "<.*>")) {
			first_symbol = 3;
			gsub("[<>]","", member_id);	# strip angles
			member_type = type_of[member_id];  
#			print "found union member " member_id " \  
#				with type " member_type;
			if (member_type == "") {
				print "union member \"" member_id \
					"\" not found!";    
				exit 1;
			}
		} else {	# first item is a token
			member_type = "";
			first_symbol = 2;
		}

		for (i=first_symbol; i<= argc; i++) {
			symbol_id = type_args[i];
			symbol_type[symbol_id] = member_type;
#			print "symbol " symbol_id " returns member " \
#				member_id " with type " member_type;
			if (match($1, "type") && match(symbol_id, "'")) {
				# then token is a single character
				gsub("'", "", symbol_id);
#				print symbol_id " = " string_char_to_int(symbol_id);
				token_set[string_char_to_int(symbol_id)] = member_type;
			} else if (match($1, "token")) {
				# token is user-defined
#				print "#define " symbol_id " " token_enum;
				token_set[token_enum] = member_type;
				token_enum++;
			} # end if match "type"
		}
	} # end if argc
	} # end if match(...)
	# just read to end-of-file
} # end while
	# print out map of token_enum to type_enum
	printf("static int token_to_type_enum_map[" token_enum "] = {");
	for (i=0; i<token_enum; i++) {
		if (i % 10 == 0) printf("\n\t");	# for readability
		member_type = token_set[i];
		if (member_type == "") {
			printf("%3d, ", -1);	# should die
		} else {
			printf("%3d, ", enum_of[member_type]);
		}
	}
	print "};";
	print "";
} else {	# !got_union
	print "need to have completed process_union() before " \
		"invoking process_symbol_types().";
	exit 1;
}
}

# convert character to int
function string_char_to_int(char, 
	# local vars
	i, c) {
	for (i=0; i<256; i++) {
		c = sprintf("%c", i);
		if (char == c)
			return i;
	}
	return -1;
}



/^state [0-9]*/ {
	print "/************************** " $0 " **************************/";
	sc = 0;
	while (getline && length($0)) {
		sc = 0;
		# do nothing, ignore production rule states
	}
	while (getline) {
		# collect shift actions
	if (NF == 3) {
	if ($2 == "shift") {
# struct-style assignment is deprecated, use constructor instead.
		printf("static const yy_state_map_link yysml_" state_count \
			"_" sc " = { " $3 ", " enum_of[symbol_type[$1]] ", ");
		if (sc) printf("&yysml_" state_count "_" sc-1);
		else	printf("NULL");		# or 0
		print " }; /* shift */";
		sc++;
	}	# else ignore reduce
	} else if (NF == 2) {
		if ($2 != "error" && $2 != "accept") {		# sanity check
			print "expected \"error\" or \"accept\", aborting";
			exit 1;
		}
		else {
			getline;		# munch blank line
			break;
		}
	} else {
		# probably blank line
		break;
	}
	}	# end while
	while (getline && NF == 3 && $2 == "goto") {
		# collect goto actions
# struct-style assignment is deprecated, use constructor instead.
		printf("static const yy_state_map_link yysml_" state_count \
			"_" sc " = { " $3 ", " enum_of[symbol_type[$1]] ", ");
		if (sc) printf("&yysml_" state_count "_" sc-1);
		else	printf("NULL");		# or 0
		print " }; /* goto */";
		sc++;
	}
	print "";
	shift_count[state_count] = sc;
	state_count++;
}


END {

	for (mid in type_of) {
		type_str = type_of[mid];
		gsub("[*]", "", type_str);
		gsub("::", "_", type_str);
		print "static " type "* yy_union_get_" type_str \
			"(const YYSTYPE& u) {";
#		print "\tcerr << "\"" type_str "\";";
		print "\treturn u." mid ";";
		print "}";
	}
	print "";

	print "static const yy_state_map_link* yysma[" state_count "] = {";
	for (i=0; i<state_count; i++) {
		if (shift_count[i])
			print "\t&yysml_" i "_" shift_count[i] -1 ", ";
		else print "\tNULL, ";
	}
	print " };";
	print "static " type "* (*yy_union_get[" member_count "])(const YYSTYPE&) = {"
	for (i=0; i<member_count; i++) {
		type_str = type_of[member_id_array[i]];
		gsub("[*]", "", type_str);
		gsub("::", "_", type_str);
		print "\t&yy_union_get_" type_str ", ";
	}
	print "};";	# end of array of function pointers
	print "";
	print "/* definition of yy_union_resolve() */";
	print type "*";
	print "yy_union_resolve(const YYSTYPE& u, const short i, const short j) {";
	print "/* function body really starts here */";
	print "const yy_state_map_link* iter = yysma[i];";
	print "/* sequentially compare state keys */";
	print "while (iter) {";
	print "\tif(iter->state == j) break;";
	print "\titer = iter->next;";
	print "} /* end while */";
	print "if (iter && iter->state == j) {";
		print "\t/* then we've found a match, return appropriately wrapped pointer */";
		print "\t" type "* ret = (*yy_union_get[iter->type_enum])(u);";
		print "\treturn ret;";
	print "} else {";
		print "\treturn NULL;";
	print "}";
	print "}";
	print "";

# a union resolution lookup using yychar
	print type "*";
	print "yy_union_lookup(const YYSTYPE& u, const int c) {";
	print "\tconst int i = token_to_type_enum_map[c];";
	print "\tassert(i >= 0);";
	print "\treturn (*yy_union_get[i])(u);";
	print "}";
	print "";
}

