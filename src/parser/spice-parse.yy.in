/**
	\file "parser/spice-parse.yy.in"
	Quick little parser for parsing spice netlists.
	The grammar in here is an extremely small snippet
	of the spice language grammar.  
	Source: http://www.freeda.org/doc/SPICE/spice.pdf
	$Id: spice-parse.yy.in,v 1.10 2008/12/18 00:32:09 fang Exp $
 */

%{
#define	ENABLE_STACKTRACE		0

#include <iostream>

#include "parser/yacc-config.h"
#include "AST/node_list.h"
#include "AST/token_string.h"
#include "parser/spice-prefix.h"
#include "parser/spice-parse-options.h"
#include "parser/spice-parse.output.h"
#include "parser/spice-union.h"
#include "lexer/spice-lex-options.h"
#include "lexer/flex_lexer_state.h"
#include "util/using_ostream.h"
#include "lexer/file_manager.h"
#include "util/stacktrace.h"

// extern FILE* yyin;

#ifdef	LIBBOGUS
static flex::lexer_state	_lexer_state;
#endif


/**
	These were replaced with macros in "AST/node_list.h"
 */
#define	WRAP_LIST(left, list, right)	list->wrap(left, right)

#define	DELETE_TOKEN(tok)		delete tok

#define APPEND_LIST(list, delim, item)					\
	DELETE_TOKEN(delim); list->push_back(item)

%}

%union {
	token_identifier*	_token_identifier;
}

%{
extern	YY_DECL;

static void yyerror(const char* msg);

extern	ostream& yy_union_resolve_dump(const YYSTYPE&, const short, const short, ostream&);
extern	void yy_union_resolve_delete(const YYSTYPE&, const short, const short);
extern	ostream& yy_union_lookup_dump(const YYSTYPE&, const int, ostream&);
extern	void yy_union_lookup_delete(const YYSTYPE&, const int);

static
void
yyfreestacks(const short* yyss, const short* yyssp,
		const YYSTYPE* yyvs, const YYSTYPE* yyvsp,
		const YYSTYPE yylval, const int yychar,
		const flex::lexer_state& _lexer_state);
%}

%token	<_token_identifier>	SPICE_ID ESCAPEDID
/* delay conversion of numbers because they can be identifiers */
%token	<_token_identifier>	NUM
%token	<_token_identifier>	RES CAP IND DEV INST
/* keywords */
%token				END ENDS SUBCKT
%token				CONNECT

%start	spice_deck

/* YACC_PURE_PARSER: conditionally substituted by configure */
@YACC_PURE_PARSER@

%%

spice_deck
	: top_cards_opt end_opt
	;

end_opt
	: END
	|
	;

top_cards_opt
	: top_cards
	|
	;

top_cards
	: top_cards top_card
	| top_card
	;

top_card
	: subcircuit_definition
	| sub_card
	;

/* for now, no nested subcircuits */
subcircuit_definition
	: SUBCKT sub_cards_opt ENDS
	;

sub_cards_opt
	: sub_cards
	|
	;

sub_cards
	: sub_cards sub_card
	| sub_card
	;

sub_card
	: instance
	| resistor
	| capacitor
	| inductor
	| transistor
/*
	| diode
	| connect_stmt
	| vsrc
	| isrc
*/
	;

/* last 'terminal' is actually the instance type */
instance
	: INST terminals identifier parameters_opt
	;

terminals
	: terminals terminal
	| terminal
	;

terminal
	: identifier
	;

/* yes, spice allows almost anything, even numbers to be identifiers */
identifier
	: SPICE_ID
	| ESCAPEDID
	| NUM
	;

resistor
	: RES terminal terminal value
	;

capacitor
	: CAP terminal terminal value
	;

inductor
	: IND terminal terminal value
	;

transistor
	: DEV terminal terminal terminal terminal identifier parameters_opt
	;

value
	: NUM
	;

parameters_opt
	: parameters
	|
	;

parameters
	: parameters parameter
	| parameter
	;

parameter
	: SPICE_ID '=' value
	;

/**
connect_stmt
	: CONNECT terminal terminal
	;
**/

%%

#include "parser/yyfreestacks.cc"		// we've moved!
#include "parser/yyerror.cc"			// we've moved!

static
void yyerror(const char* msg) {
	STACKTRACE_VERBOSE;
	__yyerror(msg);		// standard implementation
	THROW_EXIT;
}

