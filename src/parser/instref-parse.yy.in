/**
	\file "parser/instref-parse.yy.in"
	Quick little parser for parsing instance-references.  
	This will be used in prsim and other simulators, for example.  
	The grammar in here is an extremely small snippet
	of the hackt language grammar.  
	$Id: instref-parse.yy.in,v 1.7 2008/03/21 00:20:32 fang Exp $
 */

%{
#define	ENABLE_STACKTRACE		0

#include <iostream>

#include "config.h"
#include "AST/AST.h"
#include "parser/instref-prefix.h"
#include "util/using_ostream.h"
#include "parser/instref-union.h"
#include "parser/instref-parse-options.h"
#include "parser/instref-parse.output.h"
#include "lexer/instref-lex-options.h"
#include "util/stacktrace.h"

/** work-around for bison-1.875 and gcc-3.x, until bison is fixed **/
#if defined (__GNUC__) && (3 <= __GNUC__)
#define __attribute__(arglist)			/* empty */
#endif

#ifndef	YYBISON
#define	YYBISON		0
#endif

#include "lexer/flex_lexer_state.h"

#if YYBISON
#if defined(USING_BISON) && !USING_BISON
#error	Inconsistency in configuration: YYBISON && !USING_BISON
#endif

#elif defined(YYBYACC) && YYBYACC

#if defined(USING_BYACC) && !USING_BYACC && !USING_YACC
// on many systems, yacc == byacc
#error	Inconsistency in configuration: YYBYACC && !USING_BYACC && !USING_YACC
#endif
#else   // !YYBISON && !YYBYACC

#if defined(USING_YACC) && !USING_YACC
#error	Inconsistency in configuration: !YYBISON && !YYBYACC && !USING_YACC
#endif

#endif  // YYBISON

// extern FILE* yyin;

#ifdef	LIBBOGUS
static flex::lexer_state	_lexer_state;
#endif


#define	WRAP_LIST(left, list, right)	list->wrap(left, right)

#define	DELETE_TOKEN(tok)		delete tok

#define APPEND_LIST(list, delim, item)					\
	DELETE_TOKEN(delim); list->push_back(item)

using namespace HAC::lexer;
using namespace HAC::parser;

%}

%union {
	token_int*		_token_int;
/*	token_bool*		_token_bool; 		*/
	token_identifier*	_token_identifier;
	node_position*		_node_position;
	qualified_id*		_qualified_id;
	expr*			_expr;
	expr_list*		_expr_list;
	range*			_range;
	range_list*		_range_list;
	dense_range_list*	_dense_range_list;
	id_expr*		_id_expr;
	HAC::parser::index_expr*	_index_expr;
	member_expr*		_member_expr;
	inst_ref_expr*		_inst_ref_expr;
}

%{
// extern	int	yylex(YYSTYPE*);
extern	YY_DECL;

static void yyerror(const char* msg);

extern	ostream& yy_union_resolve_dump(const YYSTYPE&, const short, const short, ostream&);
extern	void yy_union_resolve_delete(const YYSTYPE&, const short, const short);
extern	ostream& yy_union_lookup_dump(const YYSTYPE&, const int, ostream&);
extern	void yy_union_lookup_delete(const YYSTYPE&, const int);

// worry about yy_union business later

static
void
yyfreestacks(const short* yyss, const short* yyssp,
		const YYSTYPE* yyvs, const YYSTYPE* yyvsp,
		const YYSTYPE yylval, const int yychar,
		const flex::lexer_state& _lexer_state);
%}

%type	<_node_position>	'[' ']' '.'
%token	<_node_position>	SCOPE
%token	<_token_identifier>	ID
%token	<_token_int>		INT

%type	<_inst_ref_expr>	instref member_index_expr
%type	<_index_expr>		index_expr
%type	<_member_expr>		member_expr
%type	<_range_list>		index_list
/* %type	<_expr_list>		index_list	*/
%type	<_range>		index
/* %type	<_expr>			index		*/
%type	<_id_expr>		id_expr
%type	<_qualified_id>		absolute_id relative_id

%start	instref

/* YACC_PURE_PARSER: conditionally substituted by configure */
@YACC_PURE_PARSER@

%%

/* grammar taken from pieces of "parser/hackt-parse.yy.in" */

instref
	: member_index_expr
			// for pure-parsing, we pass in the return YYSTYPE&
			// as yylval.  This MUST be set when returning from
			// yyparse (except when exception thrown).
			{ $$ = $1; yylval._inst_ref_expr = $1; }
	;

member_index_expr
	: id_expr	{ $$ = $1; }
	| index_expr	{ $$ = $1; }
	| member_expr	{ $$ = $1; }
	;

index_expr
	: member_expr index_list
		{ $$ = new index_expr($1, $2); }
	| id_expr index_list
		{ $$ = new index_expr($1, $2); }
	;

member_expr
	: index_expr '.' ID
		{ $$ = new member_expr($1, $3); DELETE_TOKEN($2); }
	| member_expr '.' ID
		{ $$ = new member_expr($1, $3); DELETE_TOKEN($2); }
	| id_expr '.' ID
		{ $$ = new member_expr($1, $3); DELETE_TOKEN($2); }
	;

index_list
	: index_list index
		{ $$ = $1; $1->push_back($2); }
	| index
		{ $$ = new range_list($1); }
	/*	{ $$ = new expr_list($1); }	*/
	;

/* only integer constant expressions allowed... for now */
/* here we only allow single-valued indices, and no ranges */
/* multi-reference support can be added later when needed */
/* IDEA: for i in <inst_ref_collection> ; do ... ; done */
index
	: '[' INT ']'
		{ DELETE_TOKEN($1); $$ = new range($2); DELETE_TOKEN($3); }
	;

/**
// later: expression evaluation using constant symbols available in the module!
// can just use the context of the invoking module!  MUAHAHAAA!
expr
	: ...
	;

// paste expression grammar here:
// should probably 

**/

id_expr
	: absolute_id
		{ $$ = new id_expr($1); }
	| relative_id
		{ $$ = new id_expr($1); }
	;

absolute_id
	: SCOPE relative_id
		{ $$ = $2->force_absolute($1); }
	;

relative_id
	: relative_id SCOPE ID
		{ $$ = $1; APPEND_LIST($1, $2, $3); }
	| ID	{ $$ = new qualified_id($1); }
	;


%%

/* copied from "parser/hackt-parse.yy.in" */
static
void
yyfreestacks(const short* _yyss_, const short* _yyssp_,
		const YYSTYPE* _yyvs_, const YYSTYPE* _yyvsp_,
		const YYSTYPE _yylval_, const int _yychar_,
		const flex::lexer_state& _lexer_state) {
	STACKTRACE_VERBOSE;
	const short* s;
	const YYSTYPE* v;
	s=_yyss_+1;
	v=_yyvs_+1;
	for ( ; s <= _yyssp_ && v <= _yyvsp_; s++, v++) {
		if (v) {
			// cerr << "Deleting stack token..." << endl;
			yy_union_resolve_delete(*v, *(s-1), *s);
		}
	}
	if (!_lexer_state.at_eof()) {
		// cerr << "Deleting last token..." << endl;
		// free the last token (if not EOF)
		yy_union_lookup_delete(_yylval_, _yychar_);
	}
}

#if YYBISON
#define	YYMAXTOKEN	YYMAXUTOK
#define __symbol_names  yytname
#define __shift_table   yypact
#define __reduce_table  yydefact
#define __YYTABLESIZE   YYLAST
#else   // !YYBISON
#define __symbol_names  yyname
#define __shift_table   yysindex
#define __reduce_table  yyrindex
#define __YYTABLESIZE   YYTABLESIZE
#endif

static
void yyerror(const char* msg) {
	STACKTRACE_VERBOSE;
	const short* s;
	const YYSTYPE* v;
	// msg is going to be "syntax error" from y.tab.cc
	//	very useless in general
	cerr << "parse error: " << msg << endl;

	// copied from "parser/hackt-parse.yy.in"
#if     !defined(LIBBOGUS)
	// we've kept track of the position of every token
	cerr << "parser stacks:" << endl << "state\tvalue" << endl;
	
	/* bug fix: bad memory address with first *(s-1) if v is not
	 * guaranteed to be NULL, which it isn't!
	 * Thus we start with yyss+1, yyvs+1 for first valid stack entry.
	 */
	assert(!*yyss);         /* should be zero */
	cerr << *yyss;
	s=yyss+1;
	v=yyvs+1;
	for ( ; s <= yyssp && v <= yyvsp; s++, v++) {
		// how do we know which union member?
		// need to look at the state stack, and the transition
		// from the previous state
		/* assert(v); can have NULL on stack? yes. */
		if (v) {
			yy_union_resolve_dump(*v, *(s-1), *s, cerr << '\t');
		} else {
			cerr << "\t(null) ";
		}
		cerr << endl << *s;
	}
	// sanity check
	assert(s > yyssp && v > yyvsp);
//      NULL check not necessarily valid if last token normally returned NULL
	if (_lexer_state.at_eof()) {
		cerr << "\t" << __symbol_names[0];      // "end-of-file"
	} else {
//              The last token from the lexer, yychar, tells us the last
//              token type returned.  
//              can't use: yy_union_resolve_dump(yylval, *(s-1), *s, ...);
		yy_union_lookup_dump(yylval, yychar, cerr << '\t');
	}
	cerr << endl;

	// take current state off of top of stack and 
	// print out possible points in productions
	cerr << "in state " << *yyssp << ", possible rules are:" << endl;
	{       int i;
		assert(*yyssp < yynss);
		for (i=0; i < yysss[*yyssp].n; i++) {
			cerr << yysss[*yyssp].rule[i] << endl;
		}
	}

	// list possible expected tokens based on state table
	// code ripped off from YYDEBUG parts of y.tab.c
	cerr << "acceptable tokens are: " << endl;
	int accept_count = 0;
	{
		int _yychar_ = 0;
		int yyn;
		for ( ; _yychar_ <= YYMAXTOKEN; _yychar_++) {
			// try all terminal tokens
			if ((yyn = __shift_table[*yyssp]) &&
					(yyn += _yychar_) >= 0 &&
					yyn <= __YYTABLESIZE &&
					yycheck[yyn] == _yychar_) {
				cerr << '\t' << __symbol_names[_yychar_]
					<< " (shift)" << endl;
				accept_count++;
			} else if ((yyn = __reduce_table[*yyssp]) &&
					(yyn += _yychar_) >= 0 &&
					yyn <= __YYTABLESIZE &&
					yycheck[yyn] == _yychar_) {
				cerr << '\t' << __symbol_names[_yychar_]
					<< " (reduce)" << endl;
				accept_count++;
			}
		}
	}

	yyfreestacks(yyss, yyssp, yyvs, yyvsp, yylval, yychar, _lexer_state);
#endif
	THROW_EXIT;
}

