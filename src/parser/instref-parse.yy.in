/**
	\file "parser/instref-parse.yy.in"
	Quick little parser for parsing instance-references.  
	This will be used in prsim and other simulators, for example.  
	The grammar in here is an extremely small snippet
	of the hackt language grammar.  
	$Id: instref-parse.yy.in,v 1.4 2006/07/31 22:22:40 fang Exp $
 */

%{
#define	ENABLE_STACKTRACE		0

#include <iostream>

#include "config.h"
#include "AST/AST.h"
#include "parser/instref-prefix.h"
#include "util/using_ostream.h"
#include "parser/instref-union.h"
#include "parser/instref-parse-options.h"
#include "parser/instref-parse.output.h"
#include "lexer/instref-lex-options.h"
#include "util/stacktrace.h"

/** work-around for bison-1.875 and gcc-3.x, until bison is fixed **/
#if defined (__GNUC__) && (3 <= __GNUC__)
#define __attribute__(arglist)			/* empty */
#endif

#ifndef	YYBISON
#define	YYBISON		0
#endif

#include "lexer/flex_lexer_state.h"

#if YYBISON
#if defined(USING_BISON) && !USING_BISON
#error	Inconsistency in configuration: YYBISON && !USING_BISON
#endif

#elif defined(YYBYACC) && YYBYACC

#if defined(USING_BYACC) && !USING_BYACC && !USING_YACC
// on many systems, yacc == byacc
#error	Inconsistency in configuration: YYBYACC && !USING_BYACC && !USING_YACC
#endif
#else   // !YYBISON && !YYBYACC

#if defined(USING_YACC) && !USING_YACC
#error	Inconsistency in configuration: !YYBISON && !YYBYACC && !USING_YACC
#endif

#endif  // YYBISON

// extern FILE* yyin;

#ifdef	LIBBOGUS
static flex::lexer_state	_lexer_state;
#endif


#define	WRAP_LIST(left, list, right)	list->wrap(left, right)

#define	DELETE_TOKEN(tok)		delete tok

#define APPEND_LIST(list, delim, item)					\
	DELETE_TOKEN(delim); list->push_back(item)

using namespace HAC::lexer;
using namespace HAC::parser;

%}

%union {
	token_int*		_token_int;
/*	token_bool*		_token_bool; 		*/
	token_identifier*	_token_identifier;
	node_position*		_node_position;
	qualified_id*		_qualified_id;
	expr*			_expr;
	expr_list*		_expr_list;
	range*			_range;
	range_list*		_range_list;
	dense_range_list*	_dense_range_list;
	id_expr*		_id_expr;
	HAC::parser::index_expr*	_index_expr;
	member_expr*		_member_expr;
	inst_ref_expr*		_inst_ref_expr;
}

%{
// extern	int	yylex(YYSTYPE*);
extern	YY_DECL;

namespace HAC {
namespace lexer {
// TODO: rename this yy_at_eof, to avoid conflict with hackt-lex!
extern	int instref_at_eof(const flex::lexer_state&);	// from "instref-lex.ll"
}
}

static void yyerror(const char* msg);

extern	ostream& yy_union_resolve_dump(const YYSTYPE&, const short, const short, ostream&);
extern	void yy_union_resolve_delete(const YYSTYPE&, const short, const short);
extern	ostream& yy_union_lookup_dump(const YYSTYPE&, const int, ostream&);
extern	void yy_union_lookup_delete(const YYSTYPE&, const int);

// worry about yy_union business later

static
void
yyfreestacks(const short* yyss, const short* yyssp,
		const YYSTYPE* yyvs, const YYSTYPE* yyvsp,
		const YYSTYPE yylval, const int yychar,
		const flex::lexer_state& _lexer_state);
%}

%token	MINIMUM_BOGOSITY

%type	<_node_position>	'[' ']' '.'
%token	<_node_position>	SCOPE
%token	<_token_identifier>	ID
%token	<_token_int>		INT

%type	<_inst_ref_expr>	instref member_index_expr
%type	<_index_expr>		index_expr
%type	<_member_expr>		member_expr
%type	<_range_list>		index_list
/* %type	<_expr_list>		index_list	*/
%type	<_range>		index
/* %type	<_expr>			index		*/
%type	<_id_expr>		id_expr
%type	<_qualified_id>		absolute_id relative_id

%token	MAXIMUM_BOGOSITY

%start	instref
%pure_parser

%%

/* grammar taken from pieces of "parser/hackt-parse.yy.in" */

instref
	: member_index_expr
			// for pure-parsing, we pass in the return YYSTYPE&
			// as yylval.  This MUST be set when returning from
			// yyparse (except when exception thrown).
			{ $$ = $1; yylval._inst_ref_expr = $1; }
	;

member_index_expr
	: id_expr	{ $$ = $1; }
	| index_expr	{ $$ = $1; }
	| member_expr	{ $$ = $1; }
	;

index_expr
	: member_expr index_list
		{ $$ = new index_expr($1, $2); }
	| id_expr index_list
		{ $$ = new index_expr($1, $2); }
	;

member_expr
	: index_expr '.' ID
		{ $$ = new member_expr($1, $3); DELETE_TOKEN($2); }
	| member_expr '.' ID
		{ $$ = new member_expr($1, $3); DELETE_TOKEN($2); }
	| id_expr '.' ID
		{ $$ = new member_expr($1, $3); DELETE_TOKEN($2); }
	;

index_list
	: index_list index
		{ $$ = $1; $1->push_back($2); }
	| index
		{ $$ = new range_list($1); }
	/*	{ $$ = new expr_list($1); }	*/
	;

/* only integer constant expressions allowed... for now */
/* here we only allow single-valued indices, and no ranges */
/* multi-reference support can be added later when needed */
/* IDEA: for i in <inst_ref_collection> ; do ... ; done */
index
	: '[' INT ']'
		{ DELETE_TOKEN($1); $$ = new range($2); DELETE_TOKEN($3); }
	;

/**
// later: expression evaluation using constant symbols available in the module!
// can just use the context of the invoking module!  MUAHAHAAA!
expr
	: ...
	;

// paste expression grammar here:
// should probably 

**/

id_expr
	: absolute_id
		{ $$ = new id_expr($1); }
	| relative_id
		{ $$ = new id_expr($1); }
	;

absolute_id
	: SCOPE relative_id
		{ $$ = $2->force_absolute($1); }
	;

relative_id
	: relative_id SCOPE ID
		{ $$ = $1; APPEND_LIST($1, $2, $3); }
	| ID	{ $$ = new qualified_id($1); }
	;


%%

/* copied from "parser/hackt-parse.yy.in" */
static
void
yyfreestacks(const short* _yyss_, const short* _yyssp_,
		const YYSTYPE* _yyvs_, const YYSTYPE* _yyvsp_,
		const YYSTYPE _yylval_, const int _yychar_,
		const flex::lexer_state& _lexer_state) {
	STACKTRACE_VERBOSE;
	const short* s;
	const YYSTYPE* v;
	s=_yyss_+1;
	v=_yyvs_+1;
	for ( ; s <= _yyssp_ && v <= _yyvsp_; s++, v++) {
		if (v) {
			// cerr << "Deleting stack token..." << endl;
			yy_union_resolve_delete(*v, *(s-1), *s);
		}
	}
	if (!instref_at_eof(_lexer_state)) {
		// cerr << "Deleting last token..." << endl;
		// free the last token (if not EOF)
		yy_union_lookup_delete(_yylval_, _yychar_);
	}
}

#if YYBISON
#define __symbol_names  yytname
#define __shift_table   yypact
#define __reduce_table  yydefact
#define __YYTABLESIZE   YYLAST
#else   // !YYBISON
#define __symbol_names  yyname
#define __shift_table   yysindex
#define __reduce_table  yyrindex
#define __YYTABLESIZE   YYTABLESIZE
#endif

static
void yyerror(const char* msg) {
	STACKTRACE_VERBOSE;
	const short* s;
	const YYSTYPE* v;
	// msg is going to be "syntax error" from y.tab.cc
	//	very useless in general
	cerr << "parse error: " << msg << endl;

	// copied from "parser/hackt-parse.yy.in"
#if     !defined(LIBBOGUS)
	// we've kept track of the position of every token
	cerr << "parser stacks:" << endl << "state\tvalue" << endl;
	
	/* bug fix: bad memory address with first *(s-1) if v is not
	 * guaranteed to be NULL, which it isn't!
	 * Thus we start with yyss+1, yyvs+1 for first valid stack entry.
	 */
	assert(!*yyss);         /* should be zero */
	cerr << *yyss;
	s=yyss+1;
	v=yyvs+1;
	for ( ; s <= yyssp && v <= yyvsp; s++, v++) {
		// how do we know which union member?
		// need to look at the state stack, and the transition
		// from the previous state
		/* assert(v); can have NULL on stack? yes. */
		if (v) {
			yy_union_resolve_dump(*v, *(s-1), *s, cerr << '\t');
		} else {
			cerr << "\t(null) ";
		}
		cerr << endl << *s;
	}
	// sanity check
	assert(s > yyssp && v > yyvsp);
//      NULL check not necessarily valid if last token normally returned NULL
	if (instref_at_eof(_lexer_state)) {
		cerr << "\t" << __symbol_names[0];      // "end-of-file"
	} else {
//              The last token from the lexer, yychar, tells us the last
//              token type returned.  
//              can't use: yy_union_resolve_dump(yylval, *(s-1), *s, ...);
		yy_union_lookup_dump(yylval, yychar, cerr << '\t');
	}
	cerr << endl;

	// take current state off of top of stack and 
	// print out possible points in productions
	cerr << "in state " << *yyssp << ", possible rules are:" << endl;
	{       int i;
		assert(*yyssp < yynss);
		for (i=0; i < yysss[*yyssp].n; i++) {
			cerr << yysss[*yyssp].rule[i] << endl;
		}
	}

	// list possible expected tokens based on state table
	// code ripped off from YYDEBUG parts of y.tab.c
	cerr << "acceptable tokens are: " << endl;
	int accept_count = 0;
	{
		int _yychar_ = 0;
		int yyn;
		for ( ; _yychar_ <= MAXIMUM_BOGOSITY; _yychar_++) {
			// try all terminal tokens
			if ((yyn = __shift_table[*yyssp]) &&
					(yyn += _yychar_) >= 0 &&
					yyn <= __YYTABLESIZE &&
					yycheck[yyn] == _yychar_) {
				cerr << '\t' << __symbol_names[_yychar_]
					<< " (shift)" << endl;
				accept_count++;
			} else if ((yyn = __reduce_table[*yyssp]) &&
					(yyn += _yychar_) >= 0 &&
					yyn <= __YYTABLESIZE &&
					yycheck[yyn] == _yychar_) {
				cerr << '\t' << __symbol_names[_yychar_]
					<< " (reduce)" << endl;
				accept_count++;
			}
		}
	}

	yyfreestacks(yyss, yyssp, yyvs, yyvsp, yylval, yychar, _lexer_state);
#endif
	THROW_EXIT;
}

// the rest of this file came from an old "sim/prsim/Reference.cc"

#include <iterator>
#include <algorithm>
#include <cstdio>
#include <string>
#include "AST/parse_context.h"
#include "Object/module.h"
#include "Object/unroll/unroll_context.h"
#include "Object/traits/bool_traits.h"
#include "Object/expr/expr_dump_context.h"
#include "Object/ref/meta_instance_reference_subtypes.h"
#include "Object/ref/simple_meta_instance_reference.h"
#include "Object/inst/alias_empty.h"
#include "Object/inst/instance_alias_info.h"
#include "Object/ref/meta_reference_union.h"
#include "Object/entry_collection.h"
#include "common/TODO.h"
#include "util/libc.h"			// for tmpfile, rewind,...
#include "util/tokenize_fwd.h"		// for string_list
#include "util/memory/excl_ptr.h"
#include "util/memory/deallocation_policy.h"
#include "util/packed_array.h"		// for alias_collection_type

// extern	int instref_parse(void*, YYSTYPE&, FILE*);

namespace HAC {
namespace parser {
using entity::bool_tag;
using entity::state_manager;
using entity::unroll_context;
using entity::expr_dump_context;
using entity::module;
using entity::simple_bool_meta_instance_reference;
using entity::substructure_alias;
using entity::entry_collection;
using entity::index_set_type;
using std::vector;
using std::copy;
using std::string;
using std::ostream_iterator;
using util::string_list;
using util::memory::excl_ptr;
using util::memory::never_ptr;
using util::memory::FILE_tag;
#include "util/using_ostream.h"
//=============================================================================
/**
	Parses an instance-reference string, and returns an AST slice.
	\throw general exception if unable to write temporary file.  
	\return AST of reference, else NULL upon error.  
 */
excl_ptr<parser::inst_ref_expr>
parse_reference(const char* s) {
	STACKTRACE_VERBOSE;
	typedef	excl_ptr<FILE, FILE_tag>	FILE_ptr;
	typedef	excl_ptr<parser::inst_ref_expr>	return_type;
	NEVER_NULL(s);
	const FILE_ptr temp(tmpfile());	// will automatically close on return
	if (!temp) {
		// Woe is me!
		cerr << "Failed to create temporary file-buffer!" << endl;
		THROW_EXIT;
	}
	// TODO: look into setting the file buffer (setvbuf, setlinebuf...)
	/**
		libc WARNING! (a reminder of why I hate C...)
		FreeBSD man page:
		"The fputs() function returns 0 on success and EOF on error"
		SuSE-linux man page:
		"..fputs() return a non-negative number on success,
			or EOF on error."
		Thus we MUST compare against EOF, and not just check for 0.  
		TODO: This will be done away with once we emit
			C++-stream-style scanners and parsers.
	 */
	if (fputs(s, &*temp) == EOF) {
		cerr << "Error writing string to temporary file." << endl;
		THROW_EXIT;
	} else {
		// need newline or some whitespace to prevent
		// lexer from premature EOF-ing.
		fputc('\n', &*temp);
		// the flush doesn't seem necessary from experiments
		// hopefully this will save from frequent writes to the FS
		// fflush(&*temp);
		rewind(&*temp);		// same as fseek(temp, 0, SEEK_SET);
		YYSTYPE lval;
		try {
#ifndef	LIBBOGUS
			instref_parse(NULL, lval, &*temp);
#else
			instref_parse();
#endif
		} catch (...) {
			cerr << "Error parsing instance name: " << s << endl;
			return return_type(NULL);;
		}
		// cerr << "parsed node name successfully... " << endl;
		// here is our mini-parse-tree:
		return return_type(lval._inst_ref_expr);
	}
}

//=============================================================================
/**
	NOTE: parse::context can only accept a modifiable module&
		as a ctor argument, but we REQUIRE that the 
		module we pass be unscathed (const).
		To help enforce constness in this case, 
		we restrict the constructed context to be const
		which promises not to modify its internal 
		reference to the module.  Thus from this point
		we are restricted to using the context const-ly.  
	\return resolved IR of reference.  
 */
entity::meta_reference_union
check_reference(const parser::inst_ref_expr& ref_tree,
		const entity::module& m) {
	typedef	entity::meta_reference_union		return_type;
	STACKTRACE_VERBOSE;
/***
	And now for a slice of compiler pie:
	Oh by the way, once we enable non-const expressions
	in indices, this will automatically support 
	meta-expression evaluation using the values present in
	the module.  Yeah, baby.  
	Passing "true" as the 2nd arg says we want all names 
	publicly visible, see AST::parser::context::view_all_publicly.
***/
	const context c(m, true);
	return_type r;
	try {
		// NOTE: this checks for PUBLIC members only
		// but we should allow PRIVATE references too!
		// perhaps flag through context?
		r = ref_tree.check_meta_reference(c);
	} catch (...) {
		// temporary have shitty error-handling...
		// already have type-check error message
		return return_type();
	}
	if (!r) {
		// don't expect this message to ever happen...
		cerr << "Some other error type-checking..." << endl;
		return return_type();
	}
	return r;
}

//=============================================================================
/** 
	Composition of parse_reference and check_reference.  
	Some error message already given.  
 */
entity::meta_reference_union
parse_and_check_reference(const char* s, const module& m) {
	typedef	entity::meta_reference_union		return_type;
	typedef	excl_ptr<parser::inst_ref_expr>		lval_ptr_type;
	STACKTRACE_VERBOSE;
	const lval_ptr_type ref_tree = parse_reference(s);
	if (!ref_tree) {
		return return_type();
	}
	return check_reference(*ref_tree, m);
}

//=============================================================================
/**
	TODO: figure out a way to parse a string without
		going through a friggin' temp file.  
		This is really sad.  
		Need to convert parser to stream interface.
	TODO: be able to cache already checked references with a hash.  
	\param n the string that names the instance reference
	\param m the compiled module with the top-level namespace
		and allocated state_manager.  
 */
size_t
parse_node_to_index(const string& n, const module& m) {
	typedef	inst_ref_expr::meta_return_type		checked_ref_type;
#ifndef	INVALID_NODE_INDEX
#define	INVALID_NODE_INDEX	0
#endif
	STACKTRACE_VERBOSE;
	const checked_ref_type r(parse_and_check_reference(n.c_str(), m));
	if (!r) {
		return INVALID_NODE_INDEX;
	}
	// cerr << "Woo-hoo! we found it!" << endl;
	typedef	simple_bool_meta_instance_reference	bool_ref_type;
	const count_ptr<const bool_ref_type>
		b(r.inst_ref().is_a<const bool_ref_type>());
	if (!b) {
		// later: write another procedure
		// to print *collections* of bools
		// by prefix matching.
		cerr << "Error: " << n << " does not reference a bool (node)."
			<< endl;
		return INVALID_NODE_INDEX;
	}
	// reminder: this is a packed_array_generic
	// this code uses the allocation information from the 
	// alloc phase to find the canonical ID number.  
	const state_manager& sm(m.get_state_manager());
	const size_t ret = b->lookup_globally_allocated_index(sm);
#if 0
	cerr << "index = " << ret << endl;
#endif
	return ret;
}

//=============================================================================
/**
	Prints reference identity information. 
	TODO: check non-instance-references:
		namespaces, definitions, typedefs, value-references.
	\return 0 upon success, 1 upon error.  
 */
int
parse_name_to_what(ostream& o, const string& n, const module& m) {
	typedef	inst_ref_expr::meta_return_type		checked_ref_type;
	STACKTRACE_VERBOSE;
	const checked_ref_type r(parse_and_check_reference(n.c_str(), m));
	if (!r) {
		return 1;
	} else {
		o << n << " refers to ";
		r.inst_ref()->what(o) << " ";
		r.inst_ref()->dump_type_size(o) << endl;
		return 0;
	}
}

//=============================================================================
/**
	Accumlates a sequence of sub-nodes reachable from instance.  
	\return 0 upon success, 1 upon error.  
 */
int
parse_name_to_get_subnodes(ostream& o, const string& n, const module& m, 
		vector<size_t>& v) {
	typedef	inst_ref_expr::meta_return_type		checked_ref_type;
	STACKTRACE_VERBOSE;
	const checked_ref_type r(parse_and_check_reference(n.c_str(), m));
	if (!r) {
		return 1;
	} else {
		entry_collection e;
		r.inst_ref()->collect_subentries(m, e);
		const index_set_type& b(e.get_index_set<bool_tag>());
		v.resize(b.size());
		copy(b.begin(), b.end(), v.begin());
		return 0;
	}
}

//=============================================================================
/**
	Prints reference identity information. 
	TODO: check non-instance-references:
		namespaces, definitions, typedefs, value-references.
	\return 0 upon success, 1 upon error.  
 */
int
parse_name_to_aliases(ostream& o, const string& n, const module& m) {
	typedef	inst_ref_expr::meta_return_type		checked_ref_type;
	STACKTRACE_VERBOSE;
	const checked_ref_type r(parse_and_check_reference(n.c_str(), m));
	if (!r) {
		return 1;
	} else {
		string_list aliases;
		r.inst_ref()->collect_aliases(m, aliases);
		ostream_iterator<string> osi(o, " ");
		copy(aliases.begin(), aliases.end(), osi);
		return 0;
	}
}

//=============================================================================
}	// end namespace parser
}	// end namespace HAC

