#! `which awk` -f
# "yacc-output-to-C.awk"
# by Fang
#	$Id: yacc-output-to-C.awk,v 1.2 2004/11/02 07:52:07 fang Exp $

# takes the y.output file from yacc -v and converts it into C strings
# for use in error reporting

# chicken-before-the-egg

BEGIN {
	state_count = 0;
	print "/***";
	# FILENAME isn't available yet
	print "\t\"y.output.h\"";
	print "\tautomatically generated by: awk -f yacc-output-to-C.awk <y.output>";
	print "\tInclude this file in the declaration section of a yacc file.";
	print " **/";
	print "";
	print "#ifndef\t__Y_OUTPUT_H__";
	print "#define\t__Y_OUTPUT_H__";
	print "";
	print "typedef struct _yy_output_state_string_ {";
	print "\tconst int n;";
	print "\tconst char* const* rule;";

# NOTE: a constructor was added because gcc-3.2 requires a constructor
#	for structs with non-static const members.
#	gcc-3.3 and up don't require it.  
	print "\t_yy_output_state_string_(const int k, const char* const* r) :";
	print "\t\tn(k), rule(r) { }";

	print "} yy_output_state_string;\t\t/* end struct */"
	print "";
#	print "typedef const char* const*\t\tconst_string_array;";


# NOTE:
#	can't use const char* const rule[] because compilers complain
#	about "excess elements in aggregate initializers" in structs.
#	The solution presented here is a workaround.  

#	print "typedef struct {";
#	print "\tconst yy_output_state_string* sstrs;";
#	print "\tconst int n;";
#	print "} yy_output_state_string_set;"
#	print "";
#	print "const yy_output_state_string_set yysss = {";
#	print "  {";

}

function string_to_Cstring(str) {
	gsub("\t","\\t",str);
	gsub("\n","\\n",str);
	gsub("'","\\'",str);
	gsub("\"","\\\"",str);
	gsub("\\","\\\\",str);
	return "\"" str "\"";
}

/^state [0-9]*/ {
	print "/************************** " $0 " **************************/";
	rc = 0;
	print "static const char* const yy_rule_string_set_" \
		state_count "[] = {";
	while (getline && length($0)) {
		print "\t" string_to_Cstring($0) ",";
		rc++;
	}
	rule_count[state_count] = rc;
	print "};";		# end string array
	state_count++;
}

END {
	print "const int yynss = " state_count ";\t\t/* number of states */";
	print "const yy_output_state_string yysss[] = {";
	for (i=0; i<state_count; i++) {
#		print "  { " rule_count[i] ", yy_rule_string_set_" i " },"
#		gcc-3.2 doesn't like struct-style initialization
#		and requires constructor-style initialization.  
		print "\tyy_output_state_string(" rule_count[i] \
			", yy_rule_string_set_" i "),";
		# trailing comma is ok
	}
	print "};\t\t/* end yysss */";
	print "";
	print "#endif // __Y_OUTPUT_H__";
	print "";
}

