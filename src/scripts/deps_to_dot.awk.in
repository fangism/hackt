#!@AWK@ -f
# "deps_to_dot.awk"
#	$Id: deps_to_dot.awk.in,v 1.2 2006/01/22 06:53:25 fang Exp $
# Produces a dot (diagraph) input file from dependencies.  

BEGIN {
	this_script = "scripts/deps_to_dot.awk";
	print "# auto-generated by \"" this_script "\"";
	print "digraph D {";
	# clear files
	for (f in files)
		delete files[f];
	# files[f] will contain the original name of the file
	current_target = "";
}

# name mangling to produce valid node name
# should be one-to-one correspondence with the files assoc. array
function file_to_node (f, 
	# local var
	tmp) {
	gsub("chk$", "", f);
	tmp = f;		# save a copy
	gsub("[^A-Za-z0-9_]", "__", f);
	# gsub("[.]", "DOT", f);
	# gsub("[/]", "DIR", f);
	# gsub("[+]", "PLUS", f);
	# gsub("[-]", "DASH", f);
	# create nodes for first-time-seen files
	if (!length(files[f])) {
		files[f] = tmp;
		# TODO: style the nodes
		print f "\t[label=\"" tmp "\"];";
	}
	return f;
}

# our main workhorse
function extract_edges_from_array(tgt, toks, i, nf, 
	# local vars
	dep) {
	for ( ; i<nf; i++) {
		# ignore line continuations,
		# drop self-edges
		dep = toks[i];
		if (dep != "\\") {
			# produce edges in stream
			print tgt " -> " file_to_node(dep) ";";
		}
	}
}

# first, extract the target
/:/ {
	tgt = $1;
	gsub("[:]", "", tgt);
	current_target = file_to_node(tgt);
	nf = split($0, toks);
	# skip $1
	extract_edges_from_array(current_target, toks, 2, nf);
}

!/:/ {
	nf = split($0, toks);
	extract_edges_from_array(current_target, toks, 1, nf);
}


# pray dot doesn't run out of memory...

END {
	print "}";
}

