"TODO"
#	$Id: TODO,v 1.15.2.1 2006/03/26 23:36:30 fang Exp $

===============================================================================
NOTE: see util/TODO for library-related TODO
===============================================================================
Simulation:

	Write PRS rule and express walkers, and visitor functors!!!
	Model rule-walker after cflat_prs.
	In general, write walkers for everything, it's about time...
	Make walkers 'friendly'...

	Little buglet:
	* when interpreter reports syntax error, position is wrong because
		the construction of each token-position uses the 
		hackt-lexer/AST's global node_position.  
		the instref-lexer is incrementing only it's own private
		position counter.  This can be addressed by using a 
		stack of token positions, once we get to more advanced
		lexer generation manipulation.  Then each lexer/parser
		may use it's own and temporarily save away the previous
		counter.  

prsim:
	interpreter commands:
		source <script-file>
			should have a interpreter routine without readline.
		interp key [value]
			for interpreter mode flags:
			termination conditions: assert, syntax error, 
				bad-argument,...
			echo on, echo off (only heeded in batch mode)
		time
			echo the current simulation timestamp
		advance
			advance the simulation in time units instead of steps
		aliases <name>
			print all aliases of a node (can be slow)
			might walk entire hierarchy, or cache results?
			(not expected to be used often)
			could use smart traversal, conditional recursion
			*Just walk the alloc footprint frames?*
		set <node> <value> [[+] time]
			at a specific time (or relative to present)
		setr <node> <value>
			set node at random time
		break
			break points
		watch
			watch points
		mode run | reset
		use getopt-style interpretation?
	enable escape to shell commands via system?
	concept of environment variables?
	far future: expression evaluation! variable expansion!

===============================================================================
complete type creation: (20060128)
	The algorithm for hierarhical ID allocation is horked.
	The business with ring_nodes is not bullet proof and 
		prone to mistakes, as it is difficult to reason about
		correctness and completeness.
	Proposal: COMPLETE rewite unroll and create to use a union-find
		path compression approach to allocating unique IDs.
		The style makes it easy and efficient to combine alias sets, 
		is on the average less expensive than ring maintainence, 
		although, it will no longer be easy to iterate
		over rings of aliases.  
	Consider doing this at the time of major rewrite...

===============================================================================
loop development:

lookup and value resolution:
	needs consistent resolution (currently not maintainable, copy-pasted)
	needs to check the following:
		1) is loop variable?
		2) is reference to template formal?
		3) is definition/scope-local variable (need footprint)

===============================================================================

footprint pointer persistence may be complicated in footprint_frame.
	(partially done, for top-level state)
	possibly simplify by having each footprint contain back-reference?
	(not critical, can do later...)

creation: reject unique instances that are missing relaxed actuals
	(that should have them), only after complete hierarchical merge.
	can be classified as known bug.  

===============================================================================
Lookup semantics: (clarifications)
	Inspired by new documentation
	lookup-member:
		always excludes the template parameters.  
		One may, however, create a value copy (alias)
			member that is equivalent to a parameter.
			*that* member should be globally visible.  
			(Enter template meta programming.)
		Although within a definition references to template
			parameters should be legal.  

	Distinction between x.y, x::y
		x.y requires x to be an instance whose type has a scope.
		x::y requires x to be a namespace or definition with scope
		(we already accomplish this, look at the test cases'
			create dumps to see where this distinction is clear.)

	lookups rooted at typedefs:
		Always use the canonical type's members.  

===============================================================================
big stuff:

*** global and out-of-scope references? ***
	Or should we restrict to passing everything explicitly?
	Suggest creating global 'structs' with relevant signals 
		and passing those.  
	Rationale: for design automation tools, all signals are treated
		as ports, be they global or local.
	Proposal: need way to detect, make implicit global ports?

CFLAT:

compare memory usage between using flattened production rule arrays
	vs. arrays of definitions (like logic gates).

in general check memory usage of large arrays of things
	make benchmarks directory.

===============================================================================
CODE HYGIENE:
	(added 20060118)
	definition classes and type-reference classes need to be
		re-implemented using class_traits.
	The current state is a pain in the a** to maintain.  
	sketch of definition traits:
		has_port_formals (port_formals_parent_type) (boolean)
		has_own_scopespace (scopespace_parent_type)
		typedef_alias_type
		is_built_in
		is_templateable
	type-reference traits: (don't expect to be many)
		base_definition_type

===============================================================================
hackt diff (or objdiff):
	a program to detail the differences between two object files
	differences can be structural, 
	or source-code based (debug line numbers)
	or phase differences.  
	missing objects, 
	unrolling/creating state differences, etc...

	this would be useful in determining whether or not a source
	file has changed "non-trivially."

	the crude substitute for now would be to look at the 
	differences in the textual objdump.  

	also consider implementing this as a script in combination
		with executable.  
		run unix diff first, etc...

(200601--)
Need consistency checking between different ways of generating
		intermediate object files!
	This is now possible after reworking the connection
		data structure with precisely reconstructible union-finds.  

===============================================================================
Interactive shell:
	the hackt shell
	be able to run tool commands, flow control, launch simulations, etc.
		load/mount object files, run system commands via !

===============================================================================
compile (module):
	-fdump-* flags

===============================================================================
HACKT template stuff:
	In the case of redeclarations, 
	how do default parameter values translate from
	forward declaration to full prototype to definition?

===============================================================================
enhancements:

Library/Utilities:
ICE.h:
	add ICE_ASSERT combined INVARIANT with ICE macro

Error message:
	assigning already assigned variables could have more precise msg:
		(see parser/param/048.in case)

===============================================================================
parser:
	Later, check for existence of precompiled object and use that.  
	Also, need to include source information with each module,
		so later compile phases can report error's w.r.t. source.  
	Much error handling testing to be done...

	missing feature of yacc/bison-union-type.awk:
		doesn't support goto actions in the middle of grammar yet...
		will take some time to reverse-reverse-engineer my scripts...

	MEDIUM PRIORITY:
	factor out boilerplate code generated by *-union-types.awk, 
		need not be in awk source...
		Consider additional namespace scoping.  
		Can even use template.  

	Error reporting:
		Add error to context, and accumulate in a tree-like fashion.
		In general should pass error stream objects, etc...

	MEDIUM PRIORITY:
	replace the use of lexyacc_prefix.awk with a generated #define 
		substitution header.  Include that instead of transforming
		source file.  This will be needed for multi-parse/multi-lex
		compilation, and avoiding comflicts in libbogus.  

	HIGH PRIORITY:
	convert generated lexers into classes:
		instead of passing an extra foo argument, can simply refer
		to 'this'.
		Fold state information into lexer class.  
		Make tables into static const members.  
		This will greatly simplify the present name-hacking, and 
			leverage the automatic namespace isolation from classes.
		automatically find static table and function declarations and 
			generate a class definition!

===============================================================================
PRS and CHP

need to handle loops and conditionals *around* prs { ... } bodies
	need intermediate representation support for conditional PRS (easy)
	Tentatively not supported until issue is resolved.  

CHP:
	restrict references in the nonmeta language to be scalar?
		no aggregates?

===============================================================================
Expression resolutions:
	consider writing covariant member functions for
		many methods that implement a pure virtual base function.  
	caveat: covariant return types were not properly implemented
		until g++-3.4.x, therefore we'd have to check for
		covariant correctness during configure and work-around.
		Too much effort for now... just screw it.  

===============================================================================
External package dependence and support

	consider support for BSD histedit support, older non-wrapped
		version of readline, not exactly readline compatible.
		e.g. on Apple: /usr/include/histedit.h /usr/lib/libedit.dylib

===============================================================================
KNOWN BUGS

canonical name in alloc dump is missing parent namespace completely
	e.g.: parser/typedef/005.hac, probably in namespace/00{3,4,5}.hac too
	to fix: fix dump options in dump_canonical/hierarchical_name.

test cases:
parser/connect/120.hac, 121.hac
	regarding hierarchical propagation and checking of relaxed actuals
	(2005-08-18: punting)

===============================================================================
DEFECT REPORTS:
to resolve: how to interpret negative indices, 
	whether or not they should be allowed, 
	along with empty expression-loops in PRS.  
	(affects several test cases in parser/prs)

interleaving of instantiations and PRS:
	prs and instances are maintained in separate structures
	Semantically, all instances are unrolled first before anything 
	is done with PRS.  Thus, there may be code that looks wrong 
	(reference before instantiation) but will not be rejected in the 
	later compile-phases.  Is this a major issue?
	Related: flow control containing PRS bodies will need to
		"duplicate" the flow control stack in PRS for proper replay.  

