"TODO"
	$Id: TODO,v 1.9 2005/02/27 22:54:19 fang Exp $

Nothing really *needs* to be done in here.
This is more of a wish-list for the util/ directory.  

===============================================================================

Tired of gargantuan object files and executables with 
grossly-replicated inlined template code?  
Your compiler doesn't support *gasp* export template?

Make set of headers to split STL headers into:
	1) a forward declarations header (_fwd.h)
	2) a class definition header (.h)
	3) a template method definition (.tcc)
These files should go in a subdirectory, perhaps "STL"?

Issues: may have to copy-fudge standard headers
	and hack the #define's to check for inclusion.

Possible convention:
#define inclusions to intentionally interfere with STL headers.  
	Very hackish and not portable across compilers / versions.  

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

hash_qmap, qmap: replace inheritance from hash_map and map
	and wrap-adapt instead (containership).  
	Will be some hassle of replicating/wrapping every public method...
	But I feel it's worth it.  

Do this with hash_qmap, qmap, multikey_qmap, etc. first to see benefit.

-------------------------------------------------------------------------------
persistent_object_manager:
	upon exception thrown during load_objects, 
		properly delete all transients and rethrow, 
		to prevent bogus memory leak on exception. 

-------------------------------------------------------------------------------

Regarding memory pools:

	* Type-agnostic versions of pools that allocate pure blocks of memory, 
	  based on requested size (sizeof()).  
	  Set of explicit template instantiations to "cover" the needed sizes.
	  Goal: reduces unnecessary template code replication.  
	  Safe use of reinterpret_cast, just as with std::allocator.  

	* Reclamable memory pools, reclaim contiguous blocks of memory.  
	  Like list_vector_pool, but with ability to release empty blocks.  
	  List_vector_pool is only good for recycling, but not reclaiming.  

	* Reclamable pools with FIFO or LIFO replacement deallocation.  


In "list_vector.*":

	Implement insertion and deletion with vector fragmentation, 
		and map management.  

	Possibly track bit-map of free-indices?
	May need bit-manip adaptation or library...

-------------------------------------------------------------------------------

Regarding pointer-classes:
	Files: excl_ptr.h, count_ptr.h
	Migrate into the memory/ subdirectory. (DONE)
		-- renamed "pointer_classes.h"
	Overhaul to eliminate inheritance from abstract_ptr. (DONE)
		(That was just an experiment.)
	Implement pointer_traits concept, just like iterator_traits.
		(partially done)
	Combine pointer classes with const- counterparts to unify, 
		eliminate replication.  (DONE)
	sticky_pointer: can acquire ownership, but never transfer it, 
		useful for containers, replacement for some_ptr.  
		(partially done)
	unique_pointer: transferrable ownership, but not replicable, 
		not even by never_ptr.  
		(barely started)
	(Migrating from old-style to new will be painful...
		better get it over with AQAP.)
		(DONE)

	allocate size_t reference counts with fast allocator, 
		like list_vector_pool.

	what about allocator_traits?

write a series of tests exhausting ALL combinations of copy, transfer, 
	assignment for ALL pointer-classes!
	Use STL containers.
	Expect invariants everywhere.

-------------------------------------------------------------------------------

vectorization:
	See what valarray does already...
	File: aligned_vector.h
	Create it!
	Guarantees that memory access are aligned to specified boundary, 
		by padding the head of the vector.  
	Useful for vector arithmetic.  


	(not important)
	File: reserved_vector.h
	Constant capacity container, can be full.

-------------------------------------------------------------------------------

algorithms:
	File: optimized_algorithm.h
	Implement unrolling algorithms.

-------------------------------------------------------------------------------
numeric:
	for fun:
	primality...
	compile-time taylor expansion and evaluation of constants...
	doh, can't pass floats as template arguements... yet

-------------------------------------------------------------------------------
debug utils:
	File: stacktrace.h

===============================================================================
DONE
	(so we have some sense of accomplishment)

regarding pointer-classes:
	persistent_object_manager to take advantage of 
		pointer_traits and pointer_classes.  (done)
	Make it a friend class to pointer_manipulator.  (done)


-------------------------------------------------------------------------------
