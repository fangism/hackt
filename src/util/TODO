"TODO"
	$Id: TODO,v 1.7 2005/01/12 03:19:40 fang Exp $

Nothing really *needs* to be done in here.
This is more of a wish-list for the util/ directory.  

===============================================================================

Tired of gargantuan object files and executables with 
grossly-replicated inlined template code?  
Your compiler doesn't support *gasp* export template?

Make set of headers to split STL headers into:
	1) a forward declarations header (_fwd.h)
	2) a class definition header (.h)
	3) a template method definition (.tcc)
These files should go in a subdirectory, perhaps "STL"?

Issues: may have to copy-fudge standard headers
	and hack the #define's to check for inclusion.

Possible convention:
#define inclusions to intentionally interfere with STL headers.  
	Very hackish and not portable across compilers / versions.  

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

hash_qmap, qmap: replace inheritance from hash_map and map
	and wrap-adapt instead (containership).  
	Will be some hassle of replicating/wrapping every public method...
	But I feel it's worth it.  

Do this with hash_qmap, qmap, multikey_qmap, etc. first to see benefit.

-------------------------------------------------------------------------------

In "list_vector.*":

	Implement insertion and deletion with vector fragmentation, 
		and map management.  

-------------------------------------------------------------------------------

Regarding pointer-classes:
	Files: excl_ptr.h, count_ptr.h
	Migrate into the memory/ subdirectory. (DONE)
		-- renamed "pointer_classes.h"
	Overhaul to eliminate inheritance from abstract_ptr. (DONE)
		(That was just an experiment.)
	Implement pointer_traits concept, just like iterator_traits.
		(partially done)
	Combine pointer classes with const- counterparts to unify, 
		eliminate replication.  (DONE)
	sticky_pointer: can acquire ownership, but never transfer it, 
		useful for containers, replacement for some_ptr.  
		(partially done)
	unique_pointer: transferrable ownership, but not replicable, 
		not even by never_ptr.  
		(barely started)
	(Migrating from old-style to new will be painful...
		better get it over with AQAP.)
		(DONE)

	allocate size_t reference counts with fast allocator, 
		like list_vector_pool.

	what about allocator_traits?

write a series of tests exhausting ALL combinations of copy, transfer, 
	assignment for ALL pointer-classes!
	Use STL containers.
	Expect invariants everywhere.

-------------------------------------------------------------------------------

vectorization:
	See what valarray does already...
	File: aligned_vector.h
	Create it!
	Guarantees that memory access are aligned to specified boundary, 
		by padding the head of the vector.  
	Useful for vector arithmetic.  


	(not important)
	File: reserved_vector.h
	Constant capacity container, can be full.

-------------------------------------------------------------------------------

algorithms:
	File: optimized_algorithm.h
	Implement unrolling algorithms.

-------------------------------------------------------------------------------
debug utils:
	File: stacktrace.h

===============================================================================
DONE
	(so we have some sense of accomplishment)

regarding pointer-classes:
	persistent_object_manager to take advantage of 
		pointer_traits and pointer_classes.  (done)
	Make it a friend class to pointer_manipulator.  (done)


-------------------------------------------------------------------------------
