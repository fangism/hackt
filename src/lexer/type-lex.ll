/**
 *	\file "lexer/type-lex.ll"
 *	vi: ft=lex
 *	Will generate .cc (C++) file for the token-scanner.  
 *	$Id: type-lex.ll,v 1.2 2007/02/14 00:31:11 fang Exp $
 */

%{
/* scanner-specific header */

#define	ENABLE_STACKTRACE		0 && !defined(LIBBOGUS)

#include <iostream>
#include <iomanip>
#include <cstdlib>
#include "util/sstream.h"

#if 0
#ifdef	LIBBOGUS
// HACK: prevent the inclusion of "parser/type-prefix.h"
#define	__LEXYACC_TYPE__PREFIX_H__
#endif
#endif

#include "util/macros.h"
#include "util/using_ostream.h"
#include "parser/type-prefix.h"
#include "AST/AST.h"		/* everything needed for "y.tab.h" */
// #include "lexer/input_manager.h"
// #include "lexer/file_manager.h"
using namespace HAC::parser;

// DIRTY MAKE HACK ALERT
#if	defined(LIBBOGUS)
#include "parser/type-parse.h"		/* symbols generated by yacc */
#else
#include "parser/type-parse-real.h"	/* symbols generated by yacc */
#endif
// END DIRTY HACK ALERT

#include "lexer/hac_lex.h"
#include "lexer/type-lex-options.h"
#include "lexer/flex_lexer_state.h"
// #include "parser/type-union.h"
// #include "util/stacktrace.h"
// #include "util/sstream.h"
using flex::lexer_state;

/// generated in "parser/type-union.cc" for deleting tokens
extern
void
yy_union_lookup_delete(const YYSTYPE&, const int);

extern
std::ostream&
yy_union_lookup_dump(const YYSTYPE&, const int, std::ostream&);

namespace HAC {

// defined in "main/main_funcs.cc"
extern excl_ptr<root_body>
parse_to_AST(FILE*);

/**
	Namespace for the lexer variables and functions.  
 */
namespace lexer {

/**
	Maximum string length.  Can be extended arbitrarily.  
 */
#define	STRING_MAX_LEN		1024

/** line and position tracking data for tokens */
static	token_position CURRENT(1, 0, 1);
static	token_position string_pos(1, 0, 1);
	/* even though strings may not be multi-line */

/*
static	char string_buf[STRING_MAX_LEN];
static	char* string_buf_ptr = string_buf;
*/

/**
	Thie macro is intended for use with ostream& operator << .
	\param c is a token_position.  
 */
#define	LINE_COL(c)	"on line " << c.line << ":" << c.col

/* debugging switches -- consider making these macro-defined */
static const int token_feedback = 0;
/* static const int string_feedback = 0;	*/
	/*	0 = off, 
		1 = nested levels only, 
		2 = null and endline comments, 
		3 = ignored text feedback details
	*/

/**
	Debugging tool.  
	This will generate excessive feedback for every detailed
	action of the lexer, even in the middle of tokenizing.  
 */
static inline void
DEFAULT_TOKEN_FEEDBACK(__YYLEX_PARAM_VOID) {
	if (token_feedback) {
		cerr << "token = " << yytext <<
			" " LINE_COL(CURRENT) << endl;
	}
}

/* macros for tracking single line tokens (no new line) */

static inline void
TOKEN_UPDATE(__YYLEX_PARAM_VOID) {
	DEFAULT_TOKEN_FEEDBACK(__YYLEX_ARG_VOID);
	CURRENT.col += yyleng;
}

static inline void
NEWLINE_UPDATE(__YYLEX_PARAM_VOID) {
	CURRENT.line++; CURRENT.col = 1;
#if 0
	cerr << "Line number advanced to " << CURRENT.line << endl;
#endif
}

static inline void
KEYWORD_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._keyword_position = new keyword_position(yytext, CURRENT);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

static inline void
BOOL_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._token_bool = new token_bool(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

static inline void
INT_TYPE_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._token_int_type = new token_int_type(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

static inline void
BOOL_TYPE_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._token_bool_type = new token_bool_type(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

/**
static inline void
PINT_TYPE_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._token_pint_type = new token_pint_type(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

static inline void
PBOOL_TYPE_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._token_pbool_type = new token_pbool_type(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

static inline void
PREAL_TYPE_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._token_preal_type = new token_preal_type(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}
**/

static inline void
NODE_POSITION_UPDATE(YYSTYPE& lval __YYLEX_PARAM) {
	lval._node_position = new node_position(yytext, CURRENT);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

/**
static inline void
STRING_UPDATE(__YYLEX_PARAM_VOID) {
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	assert(string_buf_ptr -string_buf < STRING_MAX_LEN);
}

static inline void
STRING_FINISH(YYSTYPE& lval __YYLEX_PARAM) {
	STRING_UPDATE(__YYLEX_ARG_VOID);
	lval._token_quoted_string = new token_quoted_string(string_buf);
}
**/

/* macros for tracking long, multiline tokens */
/* pass into p either source_pos or comment_pos */
/**
static inline void
MULTILINE_START(token_position& p __YYLEX_PARAM) {
	p.col = CURRENT.col;
	p.line = CURRENT.line;
	p.leng = yyleng;
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
}

static inline void
MULTILINE_MORE(const token_position& p __YYLEX_PARAM) {
	if (p.line == CURRENT.line) {
		CURRENT.col = yyleng +p.col
#if USE_TOKEN_POSITION_OFFSET
			+p.off
#endif
		;
	} else {
		CURRENT.col = yyleng -p.leng;
	}
}
**/

static inline void
MULTILINE_NEWLINE(token_position& p __YYLEX_PARAM) {
	p.leng = yyleng -1; NEWLINE_UPDATE(__YYLEX_ARG_VOID);
}

/* checking whether or not we are at end of file, defined below */
extern
int
type_at_eof(const flex::lexer_state&);

}	/* end namespace lexer */
}	/* end namespace HAC */

using namespace HAC::lexer;

%}

DIGIT		[0-9]
HEXDIGIT	[0-9A-Fa-f]
IDHEAD		[a-zA-Z_]
IDBODY		[a-zA-Z0-9_]
INT		{DIGIT}+
SIGN_INT	[+-]?{INT}
EXP		[eE]{SIGN_INT}
FRACTIONAL	"."{INT}
FLOAT		({INT}{FRACTIONAL}{EXP}?)|({INT}{FRACTIONAL}?{EXP})
HEX		0x{HEXDIGIT}+

/* note: '-' signed ints are lexed as two tokens and combined in the parser
	as a unary expr, thus, no numerical tokens in the language 
	*start* with a sign.  
	A sign in the exponent of a floating-point number is acceptable.  
*/

ID		{IDHEAD}{IDBODY}*
BADID		({INT}{ID})|({FLOAT}{ID})
BADHEX		{HEX}{ID}
WHITESPACE	[ \t]+
NEWLINE		"\n"
WS		{WHITESPACE}

POSITIONTOKEN	[{}<>,#]

/**
PLUSPLUS	"++"
MINUSMINUS	"--"
LARROW		"<-"
RARROW		"->"
EQUAL		"=="
NOTEQUAL	"!="
LE		"<="
GE		">="
IMPLIES		"=>"
INSERT		">>"
EXTRACT		"<<"
FWDSLASH	"\\"
LOGICAL_AND	"&&"
LOGICAL_OR	"||"
**/

SCOPE		"::"

/**
OPENSTRING	"\""
MORESTRING	[^\\\"\n]+
CLOSESTRING	"\""
FILESTRING	"\"[^\"]+\""
OCTAL_ESCAPE	"\\"[0-7]{1,3}
BAD_ESCAPE	"\\"[0-9]+
**/

/****** keywords ****/
INT_TYPE	"int"
BOOL_TYPE	"bool"
/**
PINT_TYPE	"pint"
PBOOL_TYPE	"pbool"
PREAL_TYPE	"preal"
CHANNEL		"chan"
**/
TRUE		"true"
FALSE		"false"

/* consider recording all tokens' (including punctuation) positions? */

/* no string literals yet */

/*
	Explicitly stating options to guarantee proper definition of 
	macros in the generated source file, because I've turned on
	-Wundef for all translation units.  
 */
%option never-interactive
%option nomain
%option nostack
/** I wish! **/
/** 	%option reentrant	**/

/****** rules ****************************************************************/
%%

<INITIAL>{

{SCOPE}		{ NODE_POSITION_UPDATE(*yylval __YYLEX_ARG); return SCOPE; }

{INT_TYPE}	{ INT_TYPE_UPDATE(*yylval __YYLEX_ARG); return INT_TYPE; }
{BOOL_TYPE}	{ BOOL_TYPE_UPDATE(*yylval __YYLEX_ARG); return BOOL_TYPE; }
{TRUE}		{ BOOL_UPDATE(*yylval __YYLEX_ARG); return BOOL_TRUE; }
{FALSE}		{ BOOL_UPDATE(*yylval __YYLEX_ARG); return BOOL_FALSE; }

{WHITESPACE}	TOKEN_UPDATE(__YYLEX_ARG_VOID);
{NEWLINE}	NEWLINE_UPDATE(__YYLEX_ARG_VOID);

{FLOAT} {
	if (token_feedback) {
		cerr << "float = " << yytext << " " LINE_COL(CURRENT) << endl;
	}
	/* TODO: error handling of value-ranges */
	/* consider using stream conversions to avoid precision errors */
	HAC::entity::preal_value_type v;
	std::istringstream iss(yytext);	/* slower, but safer */
	iss >> v;
	/* could try to use faster, but unsafe istrstream (deprecated) */
	yylval->_token_float = new token_float(v);
	/* yylval->_token_float = new token_float(atof(yytext)); */
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	return FLOAT;
}

{INT}	{
	if (token_feedback) {
		cerr << "int = " << yytext << " " << LINE_COL(CURRENT) << endl;
	}
	/* TODO: error handling of value-ranges */
	/* consider using stream conversions to avoid precision errors */
	/* what if we need atol? */
	HAC::entity::pint_value_type v;
	std::istringstream iss(yytext);	/* slower, but safer */
	iss >> v;
	/* could try to use faster, but unsafe istrstream (deprecated) */
	yylval->_token_int = new token_int(v);
	/* yylval->_token_int = new token_int(atoi(yytext)); */
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	return INT;
}

{HEX}	{
	if (token_feedback) {
		cerr << "int = " << yytext << " " << LINE_COL(CURRENT) << endl;
	}
	/* TODO: error handling of value-ranges */
	/* consider using stream conversions to avoid precision errors */
	/* what if we need atol? */
	HAC::entity::pint_value_type v;
	std::istringstream iss(yytext);	/* slower, but safer */
	iss >> std::hex >> v;
	/* could try to use faster, but unsafe istrstream (deprecated) */
	yylval->_token_int = new token_int(v);
	/* yylval->_token_int = new token_int(atoi(yytext)); */
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	return INT;
}

{ID}	{
	if (token_feedback) {
		cerr << "identifier = \"" << yytext << "\" " << 
			LINE_COL(CURRENT) << endl;
	}
	yylval->_token_identifier = new token_identifier(yytext);
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	return ID;
}

{BADHEX}	{ 
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "bad hexadecimal integer: \"" << yytext << "\" " <<
		LINE_COL(CURRENT) << endl;
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	yylval->_token_identifier = NULL;
	THROW_EXIT;
}

{BADID}	{ 
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "bad identifier: \"" << yytext << "\" " <<
		LINE_COL(CURRENT) << endl;
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	yylval->_token_identifier = NULL;
	THROW_EXIT;
}

{POSITIONTOKEN} { NODE_POSITION_UPDATE(*yylval __YYLEX_ARG); return yytext[0]; }

.	{
	hackt_parse_file_manager.dump_file_stack(cerr);
	/* for everything else that doesn't match... */
	cerr << "unexpected character: \'" << yytext << "\' " <<
		LINE_COL(CURRENT) << endl;
	TOKEN_UPDATE(__YYLEX_ARG_VOID);
	THROW_EXIT;
}
}


%%
/****** user-code ************************************************************/

/**
	If this is already the outermost file, then return 1, 
		signaling the end of all input.  
	\return 0 to continue lexing, after restoring yyin to its 
		former value.  
 */
int yywrap(void) {
	return 1;		// no more input
}

namespace HAC {
namespace lexer {

/**
	Public function that indicates whether or not the lexer is
	in the EOF (end-of-file) state.  
	This must be defined in this file because it makes reference
	to a statically linked variable, (which makes it invisible 
	to the outside world).  
 */
int type_at_eof(const flex::lexer_state& foo) {
	assert(YY_CURRENT_BUFFER);
	return YY_CURRENT_BUFFER->yy_n_chars == 0;
}

}	/* end namespace lexer */
}	/* end namespace HAC */

