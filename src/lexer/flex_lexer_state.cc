/**
	\file "lexer/flex_lexer_state.cc"
	$Id: flex_lexer_state.cc,v 1.2 2007/11/19 07:49:17 fang Exp $
 */

#include "lexer/flex_lexer_state.h"

// generated by flex (and re-written by scripts):
#ifdef	LEXER_HAS_YYLEX_DESTROY
extern
int
yylex_destroy(flex::lexer_state&);
#else	// LEXER_HAS_YYLEX_DESTROY
extern
void
yy_delete_buffer(YY_BUFFER_STATE, flex::lexer_state&);
#endif	// LEXER_HAS_YYLEX_DESTROY


namespace flex {
//=============================================================================
// struct lexer_state method definitions

/**
	See notes on one-time memory leak:
http://flex.sourceforge.net/manual/Memory-leak-_002d-16386-bytes-allocated-by-malloc_002e.html
	This is actually not critical, but will satisfy memory checkers
	like valgrind.
 */
lexer_state::~lexer_state() {
#ifdef	LEXER_HAS_YYLEX_DESTROY
	// flex 2.5.31
	// newer flex supports stack of buffers
	yylex_destroy(*this);
#else
	// flex 2.5.4
	// old flex only supported one current_buffer
	yy_delete_buffer(yy_current_buffer, *this);
	// yy_init = 1;		// unnecessary at end-of-life
#endif
}

//=============================================================================
}	// end namespace flex

