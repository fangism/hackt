/**
	\file "lexer/flex_lexer_state.cc"
	$Id: flex_lexer_state.cc,v 1.2.8.1 2008/03/02 22:38:27 fang Exp $
 */

#include "lexer/flex_lexer_state.h"
#include "lexer/flex_buffer_state.h"	// auto-generated
#include "util/macros.h"

// TODO: re-generate "flex_lexer_common.cc" as member functions?

// generated by flex (and re-written by scripts):
extern
YY_BUFFER_STATE
yy_scan_string(const char*, flex::lexer_state&);
// defined in generated "lexer/flex_lexer_common.cc"

#ifdef	LEXER_HAS_YYLEX_DESTROY
extern
int
yylex_destroy(flex::lexer_state&);
#else	// LEXER_HAS_YYLEX_DESTROY
extern
void
yy_delete_buffer(YY_BUFFER_STATE, flex::lexer_state&);
#endif	// LEXER_HAS_YYLEX_DESTROY

extern "C" {
int
yywrap(void) {
	return 1;
}
}

namespace flex {
//=============================================================================
// struct lexer_state method definitions

/**
	\param str a NULL-terminated string to use for lexing.
 */
lexer_state::lexer_state(const char* str) : yyin(NULL), yyout(NULL),
		yy_current_buffer(NULL),
		yy_c_buf_p(NULL), yy_init(1), yy_start(0), 
		yy_more_flag(0), yy_more_len(0)
		FLEX_LEXER_CTOR_EXTRA_INIT
		{
	yy_scan_string(str, *this);
	// sets yy_current_buffer in yy_switch_to_buffer
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	See notes on one-time memory leak:
http://flex.sourceforge.net/manual/Memory-leak-_002d-16386-bytes-allocated-by-malloc_002e.html
	This is actually not critical, but will satisfy memory checkers
	like valgrind.
 */
lexer_state::~lexer_state() {
#ifdef	LEXER_HAS_YYLEX_DESTROY
	// flex 2.5.31
	// newer flex supports stack of buffers
	yylex_destroy(*this);
#else
	// flex 2.5.4
	// old flex only supported one current_buffer
	yy_delete_buffer(yy_current_buffer, *this);
	// yy_init = 1;		// unnecessary at end-of-life
#endif
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/**
	Public function that indicates whether or not the lexer is
	in the EOF (end-of-file) state.  
	This must be defined in this file because it makes reference
	to a statically linked variable, (which makes it invisible 
	to the outside world).  
 */
#if 0
// from old code
int hacflat_at_eof(const flex::lexer_state& foo) {
	assert(YY_CURRENT_BUFFER);
	return YY_CURRENT_BUFFER->yy_n_chars == 0;
}
#else
int
lexer_state::at_eof(void) const {
	NEVER_NULL(yy_current_buffer);
	return yy_current_buffer->YY_N_CHARS == 0;
	// was yy_n_chars until "lexer/purify_flex.awk"
}
#endif

//=============================================================================
}	// end namespace flex

