/**
 *	\file "lexer/hackt-lex.ll"
 *	Will generate .cc (C++) file for the token-scanner.  
 *	$Id: hackt-lex.ll,v 1.1.2.5 2005/11/09 03:27:37 fang Exp $
 *	This file was originally:
 *	Id: art++-lex.ll,v 1.17 2005/06/21 21:26:35 fang Exp
 *	in prehistory.  
 */

/***************** FOREWORD ***************************************************
	THESE COMMENTS NEED TO BE UPDATED.

	Do not use [f]lex++, just write C++ and compile with C++ compiler.  

	quoted strings are restricted to single line, however, 
		the parser will concatenate sequences of strings
		into a single string.  

	yylval, passed to parser is a union of double, long, char*.  
		The char* member, string, is just pointer-copied, 
		with no memory management.  Thus, the parser should
		actually strcpy() the string into it's own structures.  
		strcpy() is probably performed by the constructors.  

	yylineno: seems buggy, so not using the option, keeping
		track manually with mylineno.  
		Thus no other pattern may allow newline characters, we must 
		force a stop at each newline, and treat it separately.  

	column_position: manually keeping track of column position of tokens
		get moderately complicated for multi-line tokens, 
		such as raw-source and extended comments.  
		How is it done?  Since comments and sources may span multiple
		lines and start anywhere on a line, and we only have access
		to the global yyleng upon each match, we need to remember
		how much we've matched since the last newline.  
		case 1) start of source (anywhere): while the source
		is on the 

	TODO:
		Modified to throw exception on lexical error, 
		but parser needs to catch it to properly unwind the stack!

		After static type are implemented in unions, 
		use the appropriate yylval union member.  

		Implement the #line directive to interpret the output
		of flattened, preprocessed files.  

		Use fast token allocation from util library.  

******************************************************************************/
/****** DEFINITIONS **********************************************************/

%{
/* scanner-specific header */

#include <iostream>
#include <cstdlib>

#include "util/macros.h"
#include "util/using_ostream.h"
#include "AST/art_parser.h"		/* everything needed for "y.tab.h" */
#include "lexer/input_manager.h"
#include "lexer/file_manager.h"
using namespace ART::parser;


// DIRTY MAKE HACK ALERT
#if	defined(NO_FANCY_YYERROR)
#include "parser/hackt-parse.h"		/* symbols generated by yacc */
#else
#include "parser/hackt-parse-prefix.h"	/* symbols generated by yacc */
#endif
// END DIRTY HACK ALERT

#include "lexer/hac_lex.h"
#include "lexer/hackt-lex-options.h"

extern ART::lexer::file_manager
hackt_parse_file_manager;

namespace ART {
/**
	Namespace for the lexer variables and functions.  
 */
namespace lexer {

/**
	Maximum string length.  Can be extended arbitrarily.  
 */
#define	STRING_MAX_LEN		1024

/** line and position tracking data for tokens */
#define	CURRENT		hackt_parse_file_manager.current_position()
static	token_position comment_pos(1, 0, 1);
static	token_position string_pos(1, 0, 1);
	/* even though strings may not be multi-line */
/***
	Observation: comments will never contain strings to lex, 
		nor will strings ever lex comments.  
	Also note that a file cannot be referenced while inside a 
		comment or string.  
***/

/* for string matching */
static	char string_buf[STRING_MAX_LEN];
static	char* string_buf_ptr = NULL;

/**
	Thie macro is intended for use with ostream& operator << .
	\param c is a token_position.  
 */
#define	LINE_COL(c)	"on line " << c.line << ":" << c.col

int allow_nested_comments = 0;
static int comment_level = 0;		/* useful for nested comments */

/* debugging switches -- consider making these macro-defined */
static const int token_feedback = 0;
static const int string_feedback = 0;
static const int comment_feedback = 0;		/* reporting of comment state */
	/*	0 = off, 
		1 = nested levels only, 
		2 = null and endline comments, 
		3 = ignored text feedback details
	*/

/**
	Debugging tool.  
	This will generate excessive feedback for every detailed
	action of the lexer, even in the middle of tokenizing.  
 */
#define	DEFAULT_TOKEN_FEEDBACK						\
	if (token_feedback) {						\
		cerr << "token = " << yytext <<				\
			" " LINE_COL(CURRENT) << endl;			\
	}

/* macros for tracking single line tokens (no new line) */

static inline void
TOKEN_UPDATE(void) {
	DEFAULT_TOKEN_FEEDBACK
	CURRENT.col += yyleng;
}

static inline void
NEWLINE_UPDATE(void) {
	CURRENT.line++; CURRENT.col = 1;
#if 0
	cerr << "Line number advanced to " << CURRENT.line << endl;
#endif
}

static inline void
KEYWORD_UPDATE(void) {
	yylval._keyword_position = new keyword_position(yytext, CURRENT);
	TOKEN_UPDATE();
}

static inline void
LINKAGE_UPDATE(void) {
	yylval._token_keyword = new token_keyword(yytext); TOKEN_UPDATE();
}

static inline void
ELSE_UPDATE(void) {
	yylval._token_else = new token_else(yytext); TOKEN_UPDATE();
}

static inline void
BOOL_UPDATE(void) {
	yylval._token_bool = new token_bool(yytext); TOKEN_UPDATE();
}

static inline void
INT_TYPE_UPDATE(void) {
	yylval._token_int_type = new token_int_type(yytext); TOKEN_UPDATE();
}

static inline void
BOOL_TYPE_UPDATE(void) {
	yylval._token_bool_type = new token_bool_type(yytext); TOKEN_UPDATE();
}

static inline void
PINT_TYPE_UPDATE(void) {
	yylval._token_pint_type = new token_pint_type(yytext); TOKEN_UPDATE();
}

static inline void
PBOOL_TYPE_UPDATE(void) {
	yylval._token_pbool_type = new token_pbool_type(yytext); TOKEN_UPDATE();
}

/***
static inline void
MULTICHAR_UPDATE(void) {
	yylval._token_string = new token_string(yytext); TOKEN_UPDATE();
}
***/

static inline void
NODE_POSITION_UPDATE(void) {
	yylval._node_position = new node_position(yytext, CURRENT);
	TOKEN_UPDATE();
}

static inline void
STRING_UPDATE(void) {
	TOKEN_UPDATE();
	assert(string_buf_ptr -string_buf < STRING_MAX_LEN);
}

/* macros for tracking long, multiline tokens */
/* pass into p either source_pos or comment_pos */
static inline void
MULTILINE_START(token_position& p) {
	p.col = CURRENT.col;
	p.line = CURRENT.line;
	p.leng = yyleng;
	TOKEN_UPDATE();
}

static inline void
MULTILINE_MORE(const token_position& p) {
	if (p.line == CURRENT.line) {
		CURRENT.col = yyleng +p.col
#if USE_TOKEN_POSITION_OFFSET
			+p.off
#endif
		;
	} else {
		CURRENT.col = yyleng -p.leng;
	}
}

static inline void
MULTILINE_NEWLINE(token_position& p) {
	p.leng = yyleng -1; NEWLINE_UPDATE();
}

/* checking whether or not we are at end of file, defined below */
int at_eof(void);

}	/* end namespace lexer */
}	/* end namespace ART */

using namespace ART::lexer;

%}

DIGIT		[0-9]
IDHEAD		[a-zA-Z_]
IDBODY		[a-zA-Z0-9_]
INT		{DIGIT}+
SIGN_INT	[+-]?{INT}
EXP		[eE]{SIGN_INT}
FRACTIONAL	"."{INT}
FLOAT		({INT}{FRACTIONAL}{EXP}?)|({INT}{FRACTIONAL}?{EXP})

/* note: '-' signed ints are lexed as two tokens and combined in the parser
	as a unary expr, thus, no numerical tokens in the language 
	*start* with a sign.  
	A sign in the exponent of a floating-point number is acceptable.  
*/

ID		{IDHEAD}{IDBODY}*
BADID		({INT}{ID})|({FLOAT}{ID})
WHITESPACE	[ \t]+
NEWLINE		"\n"

POSITIONTOKEN	[][(){}<>*%/=:;|!?~&^.,#+-]

/* AT		"@"	*/
/* POUND		"#"	*/
/* DOLLAR		"$"	*/

PLUSPLUS	"++"
MINUSMINUS	"--"
LARROW		"<-"
RARROW		"->"
EQUAL		"=="
NOTEQUAL	"!="
LE		"<="
GE		">="
IMPLIES		"=>"
INSERT		">>"
EXTRACT		"<<"
FWDSLASH	"\\"
LOGICAL_AND	"&&"
LOGICAL_OR	"||"
ASSIGN		":="

/** syntactic sugar tokens, value is not important, return _node_position */
BEGINLOOP	"*["
BEGINPROB	"%["
ENDPROB		"]%"
THICKBAR	"[]"
SCOPE		"::"
DEFINEOP	"<:"
RANGE		".."

ENDLINECOMMENT	"//"(.*)$
NULLCOMMENT	"/*"("*"+)"/"
OPENCOMMENT	"/"("*"+)[^/]
CLOSECOMMENT	"*"+"/"

OPENSTRING	"\""
MORESTRING	[^\\\"\n]+
CLOSESTRING	"\""

OCTAL_ESCAPE	"\\"[0-7]{1,3}
BAD_ESCAPE	"\\"[0-9]+

/****** keywords ****/
IMPORT		"import"
NAMESPACE	"namespace"
OPEN		"open"
AS		"as"
TEMPLATE	"template"
DEFINE		"define"
DEFCHAN		"defchan"
DEFTYPE		"deftype"
DEFPROC		"defproc"
TYPEDEF		"typedef"
CHP		"chp"
HSE		"hse"
PRS		"prs"
SKIP		"skip"
ELSE		"else"
LOG		"log"
SEND		"send"
RECV		"recv"
SET		"set"
GET		"get"
ENUM		"enum"
INT_TYPE	"int"
BOOL_TYPE	"bool"
PINT_TYPE	"pint"
PBOOL_TYPE	"pbool"
CHANNEL		"chan"
TRUE		"true"
FALSE		"false"
EXTERN		"extern"
STATIC		"static"
EXPORT		"export"

/* consider recording all tokens' (including punctuation) positions? */

/****** states ******/
%s incomment
%s instring
%s inescape

/*
	Explicitly stating options to guarantee proper definition of 
	macros in the generated source file, because I've turned on
	-Wundef for all translation units.  
 */
%option never-interactive
%option nomain
%option nostack

/****** rules ****************************************************************/
%%

<INITIAL>{

{LE}		{ NODE_POSITION_UPDATE(); return LE; }
{GE}		{ NODE_POSITION_UPDATE(); return GE; }
{EQUAL}		{ NODE_POSITION_UPDATE(); return EQUAL; }
{NOTEQUAL}	{ NODE_POSITION_UPDATE(); return NOTEQUAL; }
{IMPLIES}	{ NODE_POSITION_UPDATE(); return IMPLIES; }
{RARROW}	{ NODE_POSITION_UPDATE(); return RARROW; }
{PLUSPLUS}	{ NODE_POSITION_UPDATE(); return PLUSPLUS; }
{MINUSMINUS}	{ NODE_POSITION_UPDATE(); return MINUSMINUS; }
{LOGICAL_AND}	{ NODE_POSITION_UPDATE(); return LOGICAL_AND; }
{LOGICAL_OR}	{ NODE_POSITION_UPDATE(); return LOGICAL_OR; }
{INSERT}	{ NODE_POSITION_UPDATE(); return INSERT; }
{EXTRACT}	{ NODE_POSITION_UPDATE(); return EXTRACT; }
{ASSIGN}	{ NODE_POSITION_UPDATE(); return ASSIGN; }

{BEGINLOOP}	{ NODE_POSITION_UPDATE(); return BEGINLOOP; }
{BEGINPROB}	{ NODE_POSITION_UPDATE(); return BEGINPROB; }
{ENDPROB}	{ NODE_POSITION_UPDATE(); return ENDPROB; }
{THICKBAR}	{ NODE_POSITION_UPDATE(); return THICKBAR; }
{SCOPE}		{ NODE_POSITION_UPDATE(); return SCOPE; }
{RANGE}		{ NODE_POSITION_UPDATE(); return RANGE; }
{DEFINEOP}	{ NODE_POSITION_UPDATE(); return DEFINEOP; }

{POSITIONTOKEN} { NODE_POSITION_UPDATE(); return yytext[0]; }

{IMPORT}	{ KEYWORD_UPDATE(); return IMPORT; }
{NAMESPACE}	{ KEYWORD_UPDATE(); return NAMESPACE; }
{OPEN}		{ KEYWORD_UPDATE(); return OPEN; }
{AS}		{ KEYWORD_UPDATE(); return AS; }
{TEMPLATE}	{ KEYWORD_UPDATE(); return TEMPLATE; }
{DEFINE}	{ KEYWORD_UPDATE(); return DEFINE; }
{DEFCHAN}	{ KEYWORD_UPDATE(); return DEFCHAN; }
{DEFTYPE}	{ KEYWORD_UPDATE(); return DEFTYPE; }
{DEFPROC}	{ KEYWORD_UPDATE(); return DEFPROC; }
{TYPEDEF}	{ KEYWORD_UPDATE(); return TYPEDEF; }
{CHP}		{ KEYWORD_UPDATE(); return CHP_LANG; }
{HSE}		{ KEYWORD_UPDATE(); return HSE_LANG; }
{PRS}		{ KEYWORD_UPDATE(); return PRS_LANG; }
{SKIP}		{ KEYWORD_UPDATE(); return SKIP; }
{ELSE}		{ ELSE_UPDATE(); return ELSE; }
{LOG}		{ KEYWORD_UPDATE(); return LOG; }
{SEND}		{ KEYWORD_UPDATE(); return SEND; }
{RECV}		{ KEYWORD_UPDATE(); return RECV; }
{SET}		{ KEYWORD_UPDATE(); return SET; }
{GET}		{ KEYWORD_UPDATE(); return GET; }
{ENUM}		{ KEYWORD_UPDATE(); return ENUM; }
{CHANNEL}	{ KEYWORD_UPDATE(); return CHANNEL; }
{INT_TYPE}	{ INT_TYPE_UPDATE(); return INT_TYPE; }
{BOOL_TYPE}	{ BOOL_TYPE_UPDATE(); return BOOL_TYPE; }
{PINT_TYPE}	{ PINT_TYPE_UPDATE(); return PINT_TYPE; }
{PBOOL_TYPE}	{ PBOOL_TYPE_UPDATE(); return PBOOL_TYPE; }
{TRUE}		{ BOOL_UPDATE(); return BOOL_TRUE; }
{FALSE}		{ BOOL_UPDATE(); return BOOL_FALSE; }
{EXTERN}	{ LINKAGE_UPDATE(); return EXTERN; }
{STATIC}	{ LINKAGE_UPDATE(); return STATIC; }
{EXPORT}	{ LINKAGE_UPDATE(); return EXPORT; }

{WHITESPACE}	TOKEN_UPDATE();
{NEWLINE}	NEWLINE_UPDATE();
{NULLCOMMENT} { 
	if (comment_feedback > 1) {
		cerr << "null comment ignored " << LINE_COL(CURRENT) << endl;
	}
	TOKEN_UPDATE();
}
{ENDLINECOMMENT} { 
	if (comment_feedback > 1) {
		cerr << "end-of-line comment ignored " <<
			LINE_COL(CURRENT) << endl;
	}
	TOKEN_UPDATE();
}
{FLOAT} {
	if (token_feedback) {
		cerr << "float = " << yytext << " " LINE_COL(CURRENT) << endl;
	}
	yylval._token_float = new token_float(atof(yytext));
	TOKEN_UPDATE();
	return FLOAT;
}

{INT}	{
	if (token_feedback) {
		cerr << "int = " << yytext << " " << LINE_COL(CURRENT) << endl;
	}
	yylval._token_int = new token_int(atoi(yytext));
	TOKEN_UPDATE();
	return INT;
}

{ID}	{
	if (token_feedback) {
		cerr << "identifier = \"" << yytext << "\" " << 
			LINE_COL(CURRENT) << endl;
	}
	yylval._token_identifier = new token_identifier(yytext);
	TOKEN_UPDATE();
	return ID;
}

{OPENCOMMENT} {
	/* crazy... allowing nested comments */
	comment_level++;
	if (comment_feedback) {
		cerr << "start of comment-level " << comment_level << " " <<
			LINE_COL(CURRENT) << endl;
	}
	yymore();
	MULTILINE_START(comment_pos);
	BEGIN(incomment); 
}

{OPENSTRING}	{
	if (string_feedback) {
		cerr << "start of quoted-string " << LINE_COL(CURRENT) << endl;
	}
	/* no yymore(), skip open quote */
	string_buf_ptr = string_buf;
	MULTILINE_START(string_pos);	/* just for column positioning */
	BEGIN(instring); 
}

{CLOSECOMMENT} {
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "*/ (close-comment) found outside of <comment> " <<
		LINE_COL(CURRENT) << endl;
	TOKEN_UPDATE();
	THROW_EXIT;
}

{BADID}	{ 
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "bad identifier: \"" << yytext << "\" " <<
		LINE_COL(CURRENT) << endl;
	TOKEN_UPDATE();
	yylval._token_identifier = NULL;
	THROW_EXIT;
}

.	{
	hackt_parse_file_manager.dump_file_stack(cerr);
	/* for everything else that doesn't match... */
	cerr << "unexpected character: \'" << yytext << "\' " <<
		LINE_COL(CURRENT) << endl;
	TOKEN_UPDATE();
	THROW_EXIT;
}
}

<incomment>{
{NULLCOMMENT}	{ /********/ /*** does nothing ***/ /********/	
	if (comment_feedback > 1) {
		cerr << "null-comment within comment ignored " << 
			LINE_COL(CURRENT) << endl;
	}
	MULTILINE_MORE(comment_pos);
	yymore();
}
{OPENCOMMENT} {
	if (allow_nested_comments) {
		comment_level++;
		if (comment_feedback) {
			cerr << "start of comment-level " << comment_level <<
				" " << LINE_COL(CURRENT) << endl;
		}
		MULTILINE_MORE(comment_pos);
		yymore();
	} else {
		hackt_parse_file_manager.dump_file_stack(cerr);
		cerr << "nested comments forbidden, found /* " <<
			LINE_COL(CURRENT) << endl;
		THROW_EXIT;
	}
}

{NEWLINE}	{ MULTILINE_NEWLINE(comment_pos); yymore(); }

[^*/\n]*	|
"*"+[^/\n]	|
"/"+[^*\n]	{
	if (comment_feedback > 2) {
		cerr << "eaten up more comment " << LINE_COL(CURRENT) << endl;
	}
	MULTILINE_MORE(comment_pos);
	yymore();
}
{CLOSECOMMENT} {
	MULTILINE_MORE(comment_pos);
	if (comment_feedback) {
		cerr << "end of comment-level " << comment_level << " " <<
			LINE_COL(CURRENT) << endl;
	}
	comment_level--;
	if (!comment_level) {
		BEGIN(INITIAL); 
	} else {
		yymore();
	}
}
<<EOF>>	{
	MULTILINE_MORE(comment_pos);
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "unterminated comment, starting on line "
		<< comment_pos.line << ", got <<EOF>>" << endl;
	THROW_EXIT;
}
}

<instring>{
{NEWLINE}	{
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "unterminated quoted-string on line " << CURRENT.line <<
		", got \\n" << endl;
	STRING_UPDATE();
	THROW_EXIT;
}

{MORESTRING}	{
	// do escape seqences later... need a string buffer
	char *copy = yytext;
	while (*copy) {			/* until null-termination */
		*string_buf_ptr++ = *copy++;
	}
	/* don't really need yymore, just for tracking column position here */
	STRING_UPDATE();
}

{CLOSESTRING}	{
	*string_buf_ptr = '\0';		/* null-terminate */
	if (string_feedback) {
		cerr << "end of quoted-string: \"" << string_buf << "\" " <<
			LINE_COL(CURRENT) << endl;
	}
	STRING_UPDATE();
	BEGIN(INITIAL);
	yylval._token_quoted_string = new token_quoted_string(string_buf);
	return STRING;
}

"\\0"	{ *string_buf_ptr++ = '\0';	STRING_UPDATE();	}
"\\b"	{ *string_buf_ptr++ = '\b';	STRING_UPDATE();	}
"\\f"	{ *string_buf_ptr++ = '\f';	STRING_UPDATE();	}
"\\n"	{ *string_buf_ptr++ = '\n';	STRING_UPDATE();	}
"\\r"	{ *string_buf_ptr++ = '\r';	STRING_UPDATE();	}
"\\t"	{ *string_buf_ptr++ = '\t';	STRING_UPDATE();	}
"\\\\"	{ *string_buf_ptr++ = '\\';	STRING_UPDATE();	}
"\\\'"	{ *string_buf_ptr++ = '\'';	STRING_UPDATE();	}
"\\\""	{ *string_buf_ptr++ = '\"';	STRING_UPDATE();	}

{OCTAL_ESCAPE}	{
	unsigned int result;
	sscanf(yytext +1, "%o", &result);
	if ( result > 0xff ) {
		hackt_parse_file_manager.dump_file_stack(cerr);
		cerr << "bad octal escape sequence " << yytext << " " <<
			LINE_COL(CURRENT) << endl;
		THROW_EXIT;
	}
	*string_buf_ptr++ = result;
	STRING_UPDATE();
}

{BAD_ESCAPE}	{
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "bad octal escape sequence " << yytext << " " <<
		LINE_COL(CURRENT) << endl;
	THROW_EXIT;
}
<<EOF>>	{
	hackt_parse_file_manager.dump_file_stack(cerr);
	cerr << "unterminated string, starting on line " << CURRENT.line << 
		", got <<EOF>>" << endl;
	THROW_EXIT;
}
}

%%
/****** user-code ************************************************************/

/**
	If this is already the outermost file, then return 1, 
		signaling the end of all input.  
	\return 0 to continue lexing, after restoring yyin to its 
		former value.  
 */
int yywrap(void) {
	const size_t d = hackt_parse_file_manager.file_depth();
	// cerr << "file-depth remaining = " << d << endl;
	if (d > 1) {
		input_manager::leave_file(yyin, hackt_parse_file_manager);
		return 0;
	}
	else	return 1;
	// or read another input file
}

namespace ART {
namespace lexer {
/**
	Public function that indicates whether or not the lexer is
	in the EOF (end-of-file) state.  
	This must be defined in this file because it makes reference
	to a statically linked variable, (which makes it invisible 
	to the outside world).  
 */
int at_eof(void) {
	assert(YY_CURRENT_BUFFER);
	return YY_CURRENT_BUFFER->yy_n_chars == 0;
}

}	/* end namespace lexer */
}	/* end namespace ART */

