#! /usr/bin/awk -f
# "yacc-output-to-C.awk"
# by Fang

# takes the y.output file from yacc -v and converts it into C strings
# for use in error reporting

# chicken-before-the-egg

BEGIN {
	state_count = 0;
	print "/***";
	# FILENAME isn't available yet
	print "\t\"y.output.h\"";
	print "\tautomatically generated by: awk -f yacc-output-to-C.awk <y.output>";
	print "\tInclude this file in the declaration section of a yacc file.";
	print " **/";
	print "";
	print "#ifndef\t__Y_OUTPUT_H__";
	print "#define\t__Y_OUTPUT_H__";
	print "";
	print "typedef struct {";
	print "\tconst int n;";
	print "\tconst char* const* rule;";
	print "} yy_output_state_string;"
	print "";
#	print "typedef const char* const*\t\tconst_string_array;";

# NOTE:
#	can't use const char* const rule[] because compilers complain
#	about "excess elements in aggregate initializers" in structs.
#	The solution presented here is a workaround.  

#	print "typedef struct {";
#	print "\tconst yy_output_state_string* sstrs;";
#	print "\tconst int n;";
#	print "} yy_output_state_string_set;"
#	print "";
#	print "const yy_output_state_string_set yysss = {";
#	print "  {";

}

function string_to_Cstring(str) {
	gsub("\t","\\t",str);
	gsub("\n","\\n",str);
	gsub("'","\\'",str);
	gsub("\"","\\\"",str);
	gsub("\\","\\\\",str);
	return "\"" str "\"";
}

/^state [0-9]*/ {
	print "/************************** " $0 " **************************/";
	rc = 0;
	print "static const char* const yy_rule_string_set_" \
		state_count "[] = {";
	while (getline && length($0)) {
		print "\t" string_to_Cstring($0) ",";
		rc++;
	}
	rule_count[state_count] = rc;
	print "};";		# end string array
	state_count++;
}

END {
	print "const int yynss = " state_count ";\t\t/* number of states */";
	print "const yy_output_state_string yysss[] = {";
	for (i=0; i<state_count; i++) {
		print "  { " rule_count[i] ", yy_rule_string_set_" i " },"
	}
	print "};";
	print "";
	print "#endif // __Y_OUTPUT_H__";
	print "";
}

